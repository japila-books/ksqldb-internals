{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"<p>Welcome to The Internals of ksqlDB online book! \ud83e\udd19</p> <p>I'm Jacek Laskowski, an IT freelancer specializing in Apache Spark, Delta Lake, Apache Kafka and Kafka Streams (with brief forays into a wider data engineering space, e.g. Trino and ksqlDB, mostly during Warsaw Data Engineering meetups).</p> <p>I'm very excited to have you here and hope you will enjoy exploring the internals of ksqlDB as much as I have.</p>  <p>Flannery O'Connor</p> <p>I write to discover what I know.</p>   \"The Internals Of\" series <p>I'm also writing other online books in the \"The Internals Of\" series. Please visit \"The Internals Of\" Online Books home page.</p>  <p>Expect text and code snippets from a variety of public sources. Attribution follows.</p> <p>Now, let's take a deep dive into ksqlDB \ud83d\udd25</p>  <p>Last update: 2022-09-06</p>","title":"The Internals of ksqlDB 0.27.2"},{"location":"AlterSourceCommand/","text":"<p><code>AlterSourceCommand</code> is...FIXME</p>","title":"AlterSourceCommand"},{"location":"Analysis/","text":"<p><code>Analysis</code> is an ImmutableAnalysis.</p>","title":"Analysis"},{"location":"Analysis/#creating-instance","text":"<p><code>Analysis</code> takes the following to be created:</p> <ul> <li> <code>RefinementInfo</code> <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> <code>pullLimitClauseEnabled</code> flag  <p><code>Analysis</code> is created when:</p> <ul> <li><code>Analyzer.Visitor</code> is created</li> </ul>","title":"Creating Instance"},{"location":"Analysis/#tablefunctions","text":"","title":"TableFunctions <p><code>Analysis</code> defines <code>tableFunctions</code> registry of <code>FunctionCall</code>s that are added in addTableFunction.</p>"},{"location":"Analysis/#addtablefunction","text":"","title":"addTableFunction <pre><code>void addTableFunction(\n  FunctionCall functionCall)\n</code></pre> <p><code>addTableFunction</code> adds the given <code>FunctionCall</code> to the tableFunctions registry.</p> <p><code>addTableFunction</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitTableFunctions</li> </ul>"},{"location":"Analysis/#gettablefunctions","text":"","title":"getTableFunctions <pre><code>List&lt;FunctionCall&gt; getTableFunctions()\n</code></pre> <p><code>getTableFunctions</code> returns the tableFunctions.</p> <p><code>getTableFunctions</code> is part of the ImmutableAnalysis abstraction.</p>"},{"location":"Analysis/#selectitems","text":"","title":"SelectItems <p><code>Analysis</code> defines <code>joinInfo</code> registry of <code>JoinInfo</code>s that are added in addJoin.</p>"},{"location":"Analysis/#addselectitem","text":"","title":"addSelectItem <pre><code>void addSelectItem(\n  SelectItem selectItem)\n</code></pre> <p><code>addSelectItem</code> adds the given <code>SelectItem</code> to the selectItems registry.</p> <p><code>addSelectItem</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitSelect</li> </ul>"},{"location":"Analysis/#getselectitems","text":"","title":"getSelectItems <pre><code>List&lt;SelectItem&gt; getSelectItems()\n</code></pre> <p><code>getSelectItems</code> returns the selectItems.</p> <p><code>getSelectItems</code> is part of the ImmutableAnalysis abstraction.</p>"},{"location":"Analysis/#joininfos","text":"","title":"JoinInfos <p><code>Analysis</code> defines <code>joinInfo</code> registry of <code>JoinInfo</code>s that are added in addJoin.</p>"},{"location":"Analysis/#addjoin","text":"","title":"addJoin <pre><code>void addJoin(\n  JoinInfo joinInfo)\n</code></pre> <p><code>addJoin</code> adds the given <code>JoinInfo</code> to the joinInfo registry.</p> <p><code>addJoin</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitJoinedSource</li> </ul>"},{"location":"Analysis/#isjoin","text":"","title":"isJoin <pre><code>boolean isJoin()\n</code></pre> <p><code>isJoin</code> is <code>true</code> when there is a <code>JoinInfo</code> in the joinInfo registry.</p> <p><code>isJoin</code> is part of the ImmutableAnalysis abstraction.</p>"},{"location":"Analysis/#adddatasource","text":"","title":"addDataSource <pre><code>void addDataSource(\n  SourceName alias,\n  DataSource dataSource)\n</code></pre> <p><code>addDataSource</code>...FIXME</p> <p><code>addDataSource</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitAliasedRelation</li> </ul>"},{"location":"Analyzer/","text":"","title":"Analyzer"},{"location":"Analyzer/#creating-instance","text":"<p><code>Analyzer</code> takes the following to be created:</p> <ul> <li> MetaStore <li> Topic Prefix <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> ksql.query.pull.limit.clause.enabled configuration property  <p><code>Analyzer</code> is created when:</p> <ul> <li><code>QueryAnalyzer</code> is created</li> </ul> <p></p>","title":"Creating Instance"},{"location":"Analyzer/#query-analysis","text":"","title":"Query Analysis <pre><code>Analysis analyze(\n  Query query,\n  Optional&lt;Sink&gt; sink)\n</code></pre> <p><code>analyze</code> creates a Visitor (for the given Query and a flag to indicate whether the sink is defined or not for persistent queries).</p> <p><code>analyze</code> requests the <code>Visitor</code> to process the given <code>Query</code> and analyzeNonStdOutSink if the sink is defined.</p> <p><code>analyze</code> requests the <code>Visitor</code> to validate the analysis.</p> <p>In the end, <code>analyze</code> requests the the <code>Visitor</code> for the Analysis.</p> <p><code>analyze</code> is used when:</p> <ul> <li><code>QueryAnalyzer</code> is requested to analyze a query</li> </ul>"},{"location":"Analyzer/#visitor","text":"","title":"Visitor <p><code>Visitor</code> is a DefaultTraversalVisitor to produce an <code>AstNode</code> that <code>Analyzer</code> uses to analyze queries.</p> <p><code>Visitor</code> is a <code>private final</code> class of <code>Analyzer</code>.</p>"},{"location":"Analyzer/#analysis","text":"","title":"Analysis <p><code>Visitor</code> creates an Analysis when created.</p> <p>The <code>Analysis</code> instance is mutated (changed) while visiting AST nodes while analyzing a query.</p>"},{"location":"Analyzer/#visitaliasedrelation","text":"","title":"visitAliasedRelation <pre><code>AstNode visitAliasedRelation(\n  AliasedRelation node,\n  Void context)\n</code></pre> <p><code>visitAliasedRelation</code> makes sure that the <code>Table</code> relation is registered in the MetaStore and requests the Analysis to register the alias with the DataSource.</p> <p><code>visitAliasedRelation</code> is part of the AstVisitor abstraction.</p>"},{"location":"Analyzer/#visitselect","text":"","title":"visitSelect <pre><code>AstNode visitSelect(\n  Select node,\n  Void context)\n</code></pre> <p><code>visitSelect</code>...FIXME</p> <p><code>visitSelect</code> is part of the AstVisitor abstraction.</p>"},{"location":"Analyzer/#visittablefunctions","text":"","title":"visitTableFunctions <pre><code>void visitTableFunctions(\n  Expression expression)\n</code></pre> <p><code>visitTableFunctions</code> creates a <code>TableFunctionVisitor</code> to <code>process</code> the given Expression.</p>"},{"location":"Analyzer_Visitor/","text":"<p><code>Visitor</code> is a DefaultTraversalVisitor.</p> <p><code>Visitor</code> is a <code>private final class</code> of Analyzer.</p>","title":"Visitor"},{"location":"Analyzer_Visitor/#creating-instance","text":"<p><code>Visitor</code> takes the following to be created:</p> <ul> <li> <code>Query</code> <li> <code>persistent</code> flag  <p><code>Visitor</code> is created when:</p> <ul> <li><code>Analyzer</code> is requested to analyze</li> </ul>","title":"Creating Instance"},{"location":"AstSanitizer/","text":"<p><code>AstSanitizer</code> utility is used to sanitize a Statement.</p>","title":"AstSanitizer"},{"location":"AstSanitizer/#sanitize","text":"","title":"sanitize <pre><code>Statement sanitize(\n  Statement node,\n  MetaStore metaStore,\n  Boolean lambdaEnabled,\n  boolean rowpartitionRowoffsetEnabled)\n</code></pre> <p><code>sanitize</code> creates a DataSourceExtractor to extractDataSources from the given Statement.</p> <p><code>sanitize</code> creates a RewriterPlugin, an ExpressionRewriterPlugin and a <code>BiFunction</code> to create a <code>ExpressionTreeRewriter</code>.</p> <p>In the end, <code>sanitize</code> creates a <code>StatementRewriter</code> to <code>rewrite</code> the given <code>Statement</code>.</p> <p><code>sanitize</code> is used when:</p> <ul> <li><code>EngineContext</code> is requested to prepare a statement</li> </ul>"},{"location":"CommandFactories/","text":"<p><code>CommandFactories</code> is a DdlCommandFactory.</p>","title":"CommandFactories"},{"location":"CommandFactories/#creating-instance","text":"<p><code>CommandFactories</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> MetaStore  <p><code>CommandFactories</code> is created alongside EngineContext</p>","title":"Creating Instance"},{"location":"CommandFactories/#creating-ddlcommand","text":"","title":"Creating DdlCommand <p><code>create</code> is part of the DdlCommandFactory abstraction.</p> <p><code>create</code> creates a DdlCommand for a DdlStatement or a KsqlStructuredDataOutputNode.</p>"},{"location":"CommandFactories/#ddlstatement","text":"","title":"DdlStatement <pre><code>DdlCommand create(\n  String sqlExpression,\n  DdlStatement ddlStatement,\n  SessionConfig config)\n</code></pre> <p><code>create</code> looks up (the class of) the given DdlStatement (in FACTORIES) to handle it and produce a DdlCommand.</p> <p>Unless found, <code>create</code> throws a <code>KsqlException</code>:</p> <pre><code>Unable to find ddl command factory for statement: [class] valid statements:[FACTORIES]\n</code></pre>"},{"location":"CommandFactories/#ksqlstructureddataoutputnode","text":"","title":"KsqlStructuredDataOutputNode <pre><code>DdlCommand create(\n  KsqlStructuredDataOutputNode outputNode)\n</code></pre> <p>For a <code>KSTREAM</code> node output type (of the given <code>KsqlStructuredDataOutputNode</code>), <code>create</code> requests the CreateSourceFactory for a CreateStreamCommand.</p> <p>Otherwise, <code>create</code> requests the CreateSourceFactory for a CreateTableCommand.</p>"},{"location":"CommandFactories/#factories","text":"","title":"FACTORIES <p><code>CommandFactories</code> creates <code>FACTORIES</code> lookup table (of handlers) to create DdlCommands from DdlStatements.</p>    DdlStatement Handler DdlCommand     <code>AlterSource</code> <code>handleAlterSource</code> AlterSourceCommand   CreateStream handleCreateStream CreateStreamCommand   CreateTable handleCreateTable CreateTableCommand   <code>DropStream</code> <code>handleDropStream</code>    <code>DropTable</code> <code>handleDropTable</code>    <code>DropType</code> <code>handleDropType</code> DropTypeCommand   <code>RegisterType</code> <code>handleRegisterType</code> RegisterTypeCommand"},{"location":"CommandFactories/#handlecreatestream","text":"","title":"handleCreateStream <pre><code>CreateStreamCommand handleCreateStream(\n  CallInfo callInfo,\n  CreateStream statement)\n</code></pre> <p><code>handleCreateStream</code> requests the CreateSourceFactory for a CreateStreamCommand (for the given CreateStream statement).</p>"},{"location":"CommandFactories/#handlecreatetable","text":"","title":"handleCreateTable <pre><code>CreateTableCommand handleCreateTable(\n  CallInfo callInfo,\n  CreateTable statement)\n</code></pre> <p><code>handleCreateTable</code> requests the CreateSourceFactory for a CreateTableCommand (for the given CreateTable statement).</p>"},{"location":"ConfiguredKsqlPlan/","text":"<p><code>ConfiguredKsqlPlan</code> is a KsqlPlan with a SessionConfig.</p>","title":"ConfiguredKsqlPlan"},{"location":"ConfiguredKsqlPlan/#creating-instance","text":"<p><code>ConfiguredKsqlPlan</code> takes the following to be created:</p> <ul> <li> KsqlPlan <li> SessionConfig  <p><code>ConfiguredKsqlPlan</code> is created using of utility.</p>","title":"Creating Instance"},{"location":"ConfiguredKsqlPlan/#of","text":"","title":"of <pre><code>ConfiguredKsqlPlan of(\n  KsqlPlan plan,\n  SessionConfig config\n)\n</code></pre> <p><code>of</code> creates a ConfiguredKsqlPlan.</p>  <p><code>of</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a statement</li> <li><code>SandboxedExecutionContext</code> is requested to execute a statement</li> <li><code>InteractiveStatementExecutor</code> is requested to execute a KsqlPlan</li> <li><code>ValidatedCommandFactory</code> is requested to createForPlannedQuery</li> </ul>"},{"location":"CreateSourceCommand/","text":"<p><code>CreateSourceCommand</code> is an extension of the DdlCommand abstraction for DDL commands to create sources (streams and tables).</p>","title":"CreateSourceCommand"},{"location":"CreateSourceCommand/#implementations","text":"<ul> <li>CreateStreamCommand</li> <li>CreateTableCommand</li> </ul>","title":"Implementations"},{"location":"CreateSourceCommand/#creating-instance","text":"<p><code>CreateSourceCommand</code> takes the following to be created:</p> <ul> <li> <code>SourceName</code> <li> <code>LogicalSchema</code> <li> <code>TimestampColumn</code> <li> Topic Name <li> <code>Formats</code> <li> <code>WindowInfo</code> <li> <code>orReplace</code> flag <li> <code>isSource</code> flag   <p>Abstract Class</p> <p><code>CreateSourceCommand</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete CreateSourceCommands.</p>","title":"Creating Instance"},{"location":"CreateSourceFactory/","text":"","title":"CreateSourceFactory"},{"location":"CreateSourceFactory/#creating-instance","text":"<p><code>CreateSourceFactory</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> MetaStore  <p><code>CreateSourceFactory</code> is created alongside a CommandFactories.</p>","title":"Creating Instance"},{"location":"CreateSourceFactory/#creating-createstreamcommand","text":"","title":"Creating CreateStreamCommand <p><code>createStreamCommand</code> can create a CreateStreamCommand for a CreateStream statement or a KsqlStructuredDataOutputNode.</p>"},{"location":"CreateSourceFactory/#createstream","text":"","title":"CreateStream <pre><code>CreateStreamCommand createStreamCommand(\n  CreateStream statement,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>createStreamCommand</code> ensureTopicExists, buildSchema and buildTimestampColumn.</p> <p><code>createStreamCommand</code> requests the MetaStore for the DataSource for the given CreateStream.</p> <p><code>createStreamCommand</code> throwIfCreateOrReplaceOnSourceStreamOrTable.</p> <p>In the end, <code>createStreamCommand</code> creates a CreateStreamCommand.</p>  <p><code>createStreamCommand</code> is used when:</p> <ul> <li><code>CommandFactories</code> is requested to handle a CreateStream DDL statement</li> </ul>"},{"location":"CreateSourceFactory/#ksqlstructureddataoutputnode","text":"","title":"KsqlStructuredDataOutputNode <pre><code>CreateStreamCommand createStreamCommand(\n  KsqlStructuredDataOutputNode outputNode)\n</code></pre> <p><code>createStreamCommand</code> creates a CreateStreamCommand for the given KsqlStructuredDataOutputNode (with the isSource flag disabled).</p> <p><code>createStreamCommand</code> is used when:</p> <ul> <li><code>CommandFactories</code> is requested to create</li> </ul>"},{"location":"CreateSourceFactory/#creating-createtablecommand","text":"","title":"Creating CreateTableCommand <pre><code>CreateTableCommand createTableCommand(\n  CreateTable statement,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>createTableCommand</code>...FIXME</p> <p><code>createTableCommand</code> is used when:</p> <ul> <li><code>CommandFactories</code> is requested to handle a CreateTable DDL statement</li> </ul>"},{"location":"CreateSourceFactory/#throwifcreateorreplaceonsourcestreamortable","text":"","title":"throwIfCreateOrReplaceOnSourceStreamOrTable <pre><code>void throwIfCreateOrReplaceOnSourceStreamOrTable(\n  CreateSource createSource,\n  DataSource existingSource)\n</code></pre> <p><code>throwIfCreateOrReplaceOnSourceStreamOrTable</code> throws a <code>KsqlException</code> when the given CreateSource is as follows:</p> <ol> <li>CREATE OR REPLACE</li> <li>SOURCE or the given DataSource is a source</li> </ol> <pre><code>Cannot add [stream|table] '[source-name]':\nCREATE OR REPLACE is not supported on source [stream|table]s.\n</code></pre> <p><code>throwIfCreateOrReplaceOnSourceStreamOrTable</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested for CreateStreamCommand and CreateTableCommand DDL commands</li> </ul>"},{"location":"CreateSourceFactory/#buildformats","text":"","title":"buildFormats <pre><code>Formats buildFormats(\n  SourceName name,\n  LogicalSchema schema,\n  CreateSourceProperties props,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>buildFormats</code>...FIXME</p> <p><code>buildFormats</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested for a CreateStreamCommand and CreateTableCommand</li> </ul>"},{"location":"CreateStreamCommand/","text":"<p><code>CreateStreamCommand</code> is a CreateSourceCommand.</p>","title":"CreateStreamCommand"},{"location":"CreateStreamCommand/#creating-instance","text":"<p><code>CreateStreamCommand</code> takes the following to be created:</p> <ul> <li> Source Name <li> <code>LogicalSchema</code> <li> <code>TimestampColumn</code> <li> Topic Name <li> <code>Formats</code> <li> <code>WindowInfo</code> <li> <code>orReplace</code> flag <li> <code>isSource</code> flag  <p><code>CreateStreamCommand</code> is created when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to create a CreateStreamCommand</li> </ul>","title":"Creating Instance"},{"location":"CreateStreamCommand/#executing-command","text":"","title":"Executing Command <pre><code>DdlCommandResult execute(\n  Executor executor)\n</code></pre> <p><code>execute</code> is part of the DdlCommand abstraction.</p>  <p><code>execute</code> requests the given Executor to execute this CreateStreamCommand.</p>"},{"location":"CreateTableCommand/","text":"<p><code>CreateTableCommand</code> is...FIXME</p>","title":"CreateTableCommand"},{"location":"DataSource/","text":"<p><code>DataSource</code> is...FIXME</p>","title":"DataSource"},{"location":"DataSourceExtractor/","text":"<p><code>DataSourceExtractor</code> is...FIXME</p>","title":"DataSourceExtractor"},{"location":"DdlCommand/","text":"<p><code>DdlCommand</code> is an abstraction of DDL commands that can be executed (by Executor).</p>","title":"DdlCommand"},{"location":"DdlCommand/#contract","text":"","title":"Contract"},{"location":"DdlCommand/#executing-ddl-command","text":"","title":"Executing DDL Command <pre><code>DdlCommandResult execute(\n  Executor executor)\n</code></pre> <p>Used when:</p> <ul> <li><code>Executor</code> is reuqested to execute a DDL command</li> </ul>"},{"location":"DdlCommand/#implementations","text":"<ul> <li>AlterSourceCommand</li> <li>CreateSourceCommand</li> <li>DropSourceCommand</li> <li>DropTypeCommand</li> <li>RegisterTypeCommand</li> </ul>","title":"Implementations"},{"location":"DdlCommandExec/","text":"","title":"DdlCommandExec"},{"location":"DdlCommandExec/#creating-instance","text":"<p><code>DdlCommandExec</code> takes the following to be created:</p> <ul> <li> MutableMetaStore  <p><code>DdlCommandExec</code> is created along with EngineContext.</p>","title":"Creating Instance"},{"location":"DdlCommandExec/#executing-ddl-command","text":"","title":"Executing DDL Command <pre><code>DdlCommandResult execute(\n  String sql,\n  DdlCommand ddlCommand,\n  boolean withQuery,\n  Set&lt;SourceName&gt; withQuerySources) // (1)!\nDdlCommandResult execute(\n  String sql,\n  DdlCommand ddlCommand,\n  boolean withQuery,\n  Set&lt;SourceName&gt; withQuerySources,\n  boolean restoreInProgress)\n</code></pre> <ol> <li>Turns <code>restoreInProgress</code> off (<code>false</code>)</li> </ol> <p><code>execute</code> creates an Executor to execute the given DdlCommand.</p>  <p><code>execute</code> is used when:</p> <ul> <li><code>EngineContext</code> is requested to execute a DDL command</li> </ul>"},{"location":"DdlCommandFactory/","text":"<p><code>DdlCommandFactory</code> is an abstraction of DdlCommand factories that can create DdlCommands (for EngineContext).</p>","title":"DdlCommandFactory"},{"location":"DdlCommandFactory/#contract","text":"","title":"Contract"},{"location":"DdlCommandFactory/#creating-ddlcommand","text":"","title":"Creating DdlCommand <pre><code>DdlCommand create(\n  KsqlStructuredDataOutputNode outputNode)\nDdlCommand create(\n  String sqlExpression,\n  DdlStatement ddlStatement,\n  SessionConfig config)\n</code></pre> <p>Creates a DdlCommand for a KsqlStructuredDataOutputNode or a ExecutableDdlStatement</p> <p>Used when:</p> <ul> <li><code>EngineContext</code> is requested to create a DdlCommand</li> </ul>"},{"location":"DdlCommandFactory/#implementations","text":"<ul> <li>CommandFactories</li> </ul>","title":"Implementations"},{"location":"DropSourceCommand/","text":"<p><code>DropSourceCommand</code> is...FIXME</p>","title":"DropSourceCommand"},{"location":"DropTypeCommand/","text":"<p><code>DropTypeCommand</code> is...FIXME</p>","title":"DropTypeCommand"},{"location":"EngineContext/","text":"","title":"EngineContext"},{"location":"EngineContext/#creating-instance","text":"<p><code>EngineContext</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> <code>ProcessingLogContext</code> <li> <code>MutableMetaStore</code> <li> <code>QueryIdGenerator</code> <li> KsqlParser <li> <code>QueryCleanupService</code> <li> KsqlConfig <li>QueryRegistry</li> <li> <code>RuntimeAssignor</code>  <p><code>EngineContext</code> is created using create and createSandbox factories.</p>","title":"Creating Instance"},{"location":"EngineContext/#ddlcommandexec","text":"","title":"DdlCommandExec <p><code>EngineContext</code> creates a DdlCommandExec when created.</p> <p>The <code>DdlCommandExec</code> is used to execute DDL commands.</p>"},{"location":"EngineContext/#queryregistry","text":"","title":"QueryRegistry <p><code>EngineContext</code> is given a QueryRegistry when created.</p> <p>The <code>QueryRegistry</code> is used when:</p> <ul> <li>createSandbox</li> <li>maybeTerminateCreateAsQuery</li> <li>throwIfInsertQueriesExist</li> </ul>"},{"location":"EngineContext/#getqueryregistry","text":"","title":"getQueryRegistry <pre><code>QueryRegistry getQueryRegistry()\n</code></pre> <p><code>getQueryRegistry</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTransientQuery, executeStreamPullQuery, sourceTablePlan, plan a statement, planQuery, executePersistentQuery</li> <li><code>KsqlEngine</code> is requested to...FIXME</li> <li><code>PullQueryExecutionUtil</code> is requested to <code>findMaterializingQuery</code></li> <li><code>QueryIdUtil</code> is requested to <code>buildId</code></li> <li><code>SandboxedExecutionContext</code> is requested to...FIXME</li> <li><code>ScalablePushQueryExecutionUtil</code> is requested to...FIXME</li> </ul>"},{"location":"EngineContext/#creating-queryengine","text":"","title":"Creating QueryEngine <pre><code>QueryEngine createQueryEngine(\n  ServiceContext serviceContext)\n</code></pre> <p><code>createQueryEngine</code> creates a QueryEngine (with the given ServiceContext and the ProcessingLogContext).</p>  <p><code>createQueryEngine</code> is simply a convenient factory method that does nothing but <code>new QueryEngine</code> and that little programming trick makes for a more readable fluent client code.</p> <pre><code>EngineContext\n  .createQueryEngine(...)\n  .buildPhysicalPlan(...)\n</code></pre>  <p><code>createQueryEngine</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a Query for execution</li> </ul>"},{"location":"EngineContext/#commandfactories","text":"","title":"CommandFactories <p><code>EngineContext</code> creates a CommandFactories when created.</p> <p>The <code>CommandFactories</code> is used to create a DdlCommand.</p>"},{"location":"EngineContext/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> requests the KsqlParser to parse the given SQL statements.</p> <p><code>parse</code> is used when:</p> <ul> <li><code>EngineContext</code> is requested to substituteVariables</li> <li><code>KsqlEngine</code> is requested to parse a SQL text</li> <li><code>SandboxedExecutionContext</code> is requested to <code>parse</code></li> </ul>"},{"location":"EngineContext/#preparing-statement-for-execution","text":"","title":"Preparing Statement for Execution <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>prepare</code> substitutes variables (in the given <code>ParsedStatement</code> with the <code>variablesMap</code>) and then requests the KsqlParser to prepare the ParsedStatement (with the variables resolved).</p> <p><code>prepare</code> sanitizes the statement based on the following configuration properties (in the KsqlConfig):</p> <ul> <li>ksql.lambdas.enabled</li> <li>ksql.rowpartition.rowoffset.enabled</li> </ul> <p>In the end, <code>prepare</code> creates a new <code>PreparedStatement</code>.</p>  <p><code>prepare</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to prepare a statement for execution</li> <li><code>SandboxedExecutionContext</code> is requested to prepare a statement for execution</li> </ul>"},{"location":"EngineContext/#variable-substitution","text":"","title":"Variable Substitution <pre><code>ParsedStatement substituteVariables(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>substituteVariables</code> substitutes variables (in the given <code>ParsedStatement</code> with the <code>variablesMap</code>) and then parses the SQL text.</p>"},{"location":"EngineContext/#creating-enginecontext","text":"","title":"Creating EngineContext <pre><code>EngineContext create(\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MutableMetaStore metaStore,\n  QueryIdGenerator queryIdGenerator,\n  QueryCleanupService cleanupService,\n  KsqlConfig ksqlConfig,\n  Collection&lt;QueryEventListener&gt; registrationListeners)\n</code></pre> <p><code>create</code> creates a EngineContext (with a new DefaultKsqlParser, a new QueryRegistryImpl and the others).</p> <p><code>create</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is created</li> </ul>"},{"location":"EngineContext/#creating-sandboxed-enginecontext","text":"","title":"Creating Sandboxed EngineContext <pre><code>EngineContext createSandbox(\n  ServiceContext serviceContext)\n</code></pre> <p><code>createSandbox</code> creates an EngineContext.</p> <p><code>createSandbox</code> is used when:</p> <ul> <li><code>SandboxedExecutionContext</code> is created</li> </ul>"},{"location":"EngineContext/#creating-ddlcommand","text":"","title":"Creating DdlCommand <pre><code>DdlCommand createDdlCommand(\n  KsqlStructuredDataOutputNode outputNode)\nDdlCommand createDdlCommand(\n  String sqlExpression,\n  ExecutableDdlStatement statement,\n  SessionConfig config)\n</code></pre> <p><code>createDdlCommand</code> requests the CommandFactories to create a DdlCommand.</p>  <p><code>createDdlCommand</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan an ExecutableDdlStatement and maybeCreateSinkDdl</li> </ul>"},{"location":"EngineContext/#executing-ddl-command","text":"","title":"Executing DDL Command <pre><code>String executeDdl(\n  String sqlExpression,\n  DdlCommand command,\n  boolean withQuery,\n  Set&lt;SourceName&gt; withQuerySources,\n  boolean restoreInProgress)\n</code></pre> <p><code>executeDdl</code> requests the DdlCommandExec to execute the DDL command.</p>  <p>DropSourceCommand</p> <p><code>executeDdl</code> cares about <code>DropSourceCommand</code> more.</p>   <p><code>executeDdl</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a DDL Command</li> </ul>"},{"location":"EngineExecutor/","text":"","title":"EngineExecutor"},{"location":"EngineExecutor/#creating-instance","text":"<p><code>EngineExecutor</code> takes the following to be created:</p> <ul> <li> EngineContext <li> ServiceContext <li> SessionConfig  <p><code>EngineExecutor</code> is created using create factory.</p>","title":"Creating Instance"},{"location":"EngineExecutor/#creating-engineexecutor","text":"","title":"Creating EngineExecutor <pre><code>EngineExecutor create(\n  EngineContext engineContext,\n  ServiceContext serviceContext,\n  SessionConfig config)\n</code></pre> <p><code>create</code> creates an EngineExecutor.</p>  <p><code>create</code> is simply a convenient static factory method that does nothing but <code>new EngineExecutor</code> and that little programming trick makes for a more readable fluent client code.</p> <pre><code>EngineExecutor\n  .create(...)\n  .plan(statement)\n</code></pre>  <p><code>create</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to plan, execute, executeTransientQuery, createStreamPullQuery, executeScalablePushQuery, executeTablePullQuery</li> <li><code>SandboxedExecutionContext</code> is requested to plan, execute, executeTransientQuery, executeTablePullQueryQuery, executeScalablePushQuery</li> </ul>"},{"location":"EngineExecutor/#planning-query-for-execution-planquery","text":"","title":"Planning Query for Execution (planQuery) <pre><code>ExecutorPlans planQuery(\n  ConfiguredStatement&lt;?&gt; statement,\n  Query query,\n  Optional&lt;Sink&gt; sink,\n  Optional&lt;String&gt; withQueryId,\n  MetaStore metaStore)\n</code></pre> <p><code>planQuery</code> takes a Query and creates an ExecutorPlans.</p> <p>The optional <code>Sink</code> and query ID are only given when <code>EngineExecutor</code> is requested to plan a QueryContainer. Otherwise, they are both undefined.</p>  <p><code>planQuery</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute transient and stream pull queries, and to plan a statement (and sourceTablePlan)</li> </ul>"},{"location":"EngineExecutor/#step-1-creating-queryengine","text":"","title":"Step 1. Creating QueryEngine <p><code>planQuery</code> requests the EngineContext to create a QueryEngine (for the ServiceContext).</p>  <p>Note</p> <p><code>planQuery</code> creates a QueryEngine every time it is executed.</p>"},{"location":"EngineExecutor/#step-2-building-logical-plan","text":"","title":"Step 2. Building Logical Plan <p><code>planQuery</code> builds a logical query plan (an OutputNode).</p> <p><code>planQuery</code> creates a <code>LogicalPlanNode</code> (for the query statement text and the <code>OutputNode</code>), a <code>QueryId</code> and looks up a <code>PersistentQueryMetadata</code> (in QueryRegistry) for the <code>QueryId</code> (if one exists).</p>"},{"location":"EngineExecutor/#step-3-building-physical-plan","text":"","title":"Step 3. Building Physical Plan <p><code>planQuery</code> builds a physical query plan (a PhysicalPlan).</p>"},{"location":"EngineExecutor/#step-4-creating-executorplans","text":"","title":"Step 4. Creating ExecutorPlans <p>In the end, <code>planQuery</code> creates an <code>ExecutorPlans</code> (with the <code>LogicalPlanNode</code> and the <code>PhysicalPlan</code>).</p>"},{"location":"EngineExecutor/#statement-planning","text":"","title":"Statement Planning <pre><code>KsqlPlan plan(\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> makes sure that the Statement (of the given <code>ConfiguredStatement</code>) is executable and throws a KsqlStatementException if not.</p> <p><code>plan</code> branches off based on the type of the statement:</p> <ul> <li>ExecutableDdlStatement</li> <li>QueryContainer</li> </ul>  <p><code>plan</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to plan a statement</li> <li><code>SandboxedExecutionContext</code> is requested to plan a statement</li> </ul>"},{"location":"EngineExecutor/#executableddlstatement","text":"","title":"ExecutableDdlStatement <p>For an ExecutableDdlStatement, <code>plan</code> determines whether it is a CreateStream or a CreateTable (possibly SOURCEs).</p> <p>For a source <code>CreateTable</code>, <code>plan</code> sourceTablePlan.</p> <p>Otherwise, <code>plan</code> requests the EngineContext to create a DdlCommand and then plans it.</p>"},{"location":"EngineExecutor/#querycontainer","text":"","title":"QueryContainer <p>Otherwise, <code>plan</code> assumes that the <code>Statement</code> is a QueryContainer and plans the query (with the <code>Sink</code> among the others that gives a <code>PhysicalPlan</code>).</p> <p><code>plan</code> maybeCreateSinkDdl.</p> <p><code>plan</code> creates a QueryPlan.</p> <p>In the end, <code>plan</code> creates a KsqlPlanV1.</p>"},{"location":"EngineExecutor/#exceptions","text":"","title":"Exceptions <p><code>plan</code> throws a KsqlStatementException for a non-executable statement.</p> <p><code>plan</code> throws a <code>KsqlStatementException</code> for a CreateStream or a <code>CreateTable</code> that are source the ksql.source.table.materialization.enabled configuration property is disabled:</p> <pre><code>Cannot execute command because source table materialization is disabled.\n</code></pre>"},{"location":"EngineExecutor/#maybecreatesinkddl","text":"","title":"maybeCreateSinkDdl <pre><code>Optional&lt;DdlCommand&gt; maybeCreateSinkDdl(\n  ConfiguredStatement&lt;?&gt; cfgStatement,\n  KsqlStructuredDataOutputNode outputNode)\n</code></pre> <p><code>maybeCreateSinkDdl</code> returns an empty value for a KsqlStructuredDataOutputNode with no createInto. <code>maybeCreateSinkDdl</code> validateExistingSink.</p> <p>Otherwise, <code>maybeCreateSinkDdl</code> requests the EngineContext to createDdlCommand for the given KsqlStructuredDataOutputNode.</p>"},{"location":"EngineExecutor/#sourcetableplan","text":"","title":"sourceTablePlan <pre><code>KsqlPlan sourceTablePlan(\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>sourceTablePlan</code> assumes that the given <code>ConfiguredStatement</code> is for a CreateTable.</p> <p><code>sourceTablePlan</code>...FIXME</p>"},{"location":"EngineExecutor/#executing-ksqlplan","text":"","title":"Executing KsqlPlan <pre><code>ExecuteResult execute(\n  KsqlPlan plan)\n</code></pre> <p><code>execute</code> is made up of different \"execution paths\" to handle different variants of KsqlPlans, but mainly whether a DdlCommand is available or not</p> <p><code>execute</code> throws an <code>IllegalStateException</code> when the given KsqlPlan has neither physical query plan nor DDL command:</p> <pre><code>DdlResult should be present if there is no physical plan.\n</code></pre>  <p><code>execute</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a query</li> <li><code>SandboxedExecutionContext</code> is requested to execute a query</li> </ul>"},{"location":"EngineExecutor/#ddl-command","text":"","title":"DDL Command <p>With a KsqlPlan with no physical query plan, <code>execute</code> executes the DDL command (of the KsqlPlan with the <code>withQuery</code> flag off) and returns an <code>ExecuteResult</code>.</p>"},{"location":"EngineExecutor/#queryplan","text":"","title":"QueryPlan  <p>Physical Plan with optional DdlCommand</p> <p>The given KsqlPlan may have a physical plan with or without a DdlCommand.</p>  <p>For a KsqlPlan with a physical query plan, <code>execute</code> executes a DDL command (if available) and then the persistent query.</p>"},{"location":"EngineExecutor/#executing-persistent-query","text":"","title":"Executing Persistent Query <pre><code>PersistentQueryMetadata executePersistentQuery(\n  QueryPlan queryPlan,\n  String statementText,\n  KsqlConstants.PersistentQueryType persistentQueryType)\n</code></pre> <p><code>executePersistentQuery</code> requests the EngineContext for the QueryRegistry to create or replace a persistent query (for the given QueryPlan and <code>PersistentQueryType</code>).</p>"},{"location":"EngineExecutor/#executing-scalable-push-query","text":"","title":"Executing Scalable Push Query <pre><code>ScalablePushQueryMetadata executeScalablePushQuery(\n  ImmutableAnalysis analysis,\n  ConfiguredStatement&lt;Query&gt; statement,\n  PushRouting pushRouting,\n  PushRoutingOptions pushRoutingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Context context,\n  Optional&lt;ScalablePushQueryMetrics&gt; scalablePushQueryMetrics)\n</code></pre> <p><code>executeScalablePushQuery</code> buildAndValidateLogicalPlan (with <code>isScalablePush</code> flag enabled).</p> <p>In the end, <code>executeScalablePushQuery</code> creates a <code>ScalablePushQueryMetadata</code> (with a new <code>TransientQueryQueue</code>).</p> <p><code>executeScalablePushQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a scalable push query</li> <li><code>SandboxedExecutionContext</code> is requested to execute a scalable push query</li> </ul>"},{"location":"EngineExecutor/#executing-stream-pull-query","text":"","title":"Executing Stream Pull Query <pre><code>TransientQueryMetadata executeStreamPullQuery(\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones,\n  ImmutableMap&lt;TopicPartition, Long&gt; endOffsets)\n</code></pre> <p><code>executeStreamPullQuery</code> plans the query (with an empty sink and query ID).</p> <p><code>executeStreamPullQuery</code> requests the EngineContext to create a QueryValidator to validateQuery (with the SessionConfig and the <code>ExecutionPlan</code> with ExecutionSteps).</p> <p><code>executeStreamPullQuery</code> requests the EngineContext for the QueryRegistry to create a stream pull query.</p>  <p><code>executeStreamPullQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to create a stream pull query</li> </ul>"},{"location":"EngineExecutor/#executing-transient-query","text":"","title":"Executing Transient Query <pre><code>TransientQueryMetadata executeTransientQuery(\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones)\n</code></pre> <p><code>executeTransientQuery</code>...FIXME</p> <p>In the end, <code>executeTransientQuery</code> requests the EngineContext for the QueryRegistry to create a transient query.</p> <p><code>executeTransientQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a transient query</li> <li><code>SandboxedExecutionContext</code> is requested to execute a transient query</li> </ul>"},{"location":"EngineExecutor/#executing-table-pull-query","text":"","title":"Executing Table Pull Query <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>executeTablePullQuery</code> buildAndValidateLogicalPlan followed by buildPullPhysicalPlan.</p> <p><code>executeTablePullQuery</code> creates a <code>PullQueryQueue</code> and a <code>PullQueryQueuePopulator</code> (to requests the given <code>HARouting</code> to <code>handlePullQuery</code>).</p> <p><code>executeTablePullQuery</code> creates a <code>PullQueryResult</code> (and starts it when the given <code>startImmediately</code> flag is enabled).</p> <p><code>executeTablePullQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a table pull query</li> <li><code>SandboxedExecutionContext</code> is requested to execute a table pull query</li> </ul>"},{"location":"EngineExecutor/#building-logical-plan-of-query-buildandvalidatelogicalplan","text":"","title":"Building Logical Plan of Query (buildAndValidateLogicalPlan) <pre><code>LogicalPlanNode buildAndValidateLogicalPlan(\n  ConfiguredStatement&lt;?&gt; statement,\n  ImmutableAnalysis analysis,\n  KsqlConfig config,\n  QueryPlannerOptions queryPlannerOptions,\n  boolean isScalablePush)\n</code></pre> <p><code>buildAndValidateLogicalPlan</code> is given a statement (along with the analysis) and the <code>isScalablePush</code> flag as follows:</p> <ul> <li><code>true</code> when executing a scalable push query</li> <li><code>false</code> when executing a table pull query</li> </ul>  <p>Naming</p> <p>Since <code>buildAndValidateLogicalPlan</code> is to execute buildQueryLogicalPlan it'd make sense to call it alike, wouldn't it?</p> <p>After all, <code>buildAndValidateLogicalPlan</code> is a facade to LogicalPlanner.</p>   <p><code>buildAndValidateLogicalPlan</code> creates a LogicalPlanner to build a logical plan of a query (that gives an OutputNode).</p> <p>In the end, <code>buildAndValidateLogicalPlan</code> creates a <code>LogicalPlanNode</code> (with the statement text of the given <code>ConfiguredStatement</code> and the OutputNode).</p>  <p><code>buildAndValidateLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute table pull or scalable push queries</li> </ul>"},{"location":"EngineExecutor/#executing-ddl-command","text":"","title":"Executing DDL Command <pre><code>String executeDdl(\n  DdlCommand ddlCommand,\n  String statementText,\n  boolean withQuery,\n  Set&lt;SourceName&gt; withQuerySources,\n  boolean restoreInProgress)\n</code></pre> <p><code>executeDdl</code> requests the EngineContext to executeDdl.</p>"},{"location":"ExecutionStep/","text":"<p><code>ExecutionStep&lt;S&gt;</code> is an abstraction of execution steps (physical plans) to build S.</p> <p><code>S</code> can be one of the following:</p> <ul> <li><code>KStreamHolder</code></li> <li><code>KTableHolder</code></li> <li><code>KGroupedStreamHolder</code></li> <li><code>KGroupedTableHolder</code></li> </ul>","title":"ExecutionStep"},{"location":"ExecutionStep/#contract","text":"","title":"Contract"},{"location":"ExecutionStep/#building-s","text":"","title":"Building S <pre><code>S build(\n  PlanBuilder planBuilder) // (1)!\nS build(\n  PlanBuilder planBuilder,\n  PlanInfo planInfo)\n</code></pre> <ol> <li>Uses a PlanInfoExtractor to extract a PlanInfo</li> </ol> <p>Used when:</p> <ul> <li><code>QueryBuilder</code> is requested for a query implementation</li> </ul>"},{"location":"ExecutionStep/#extracting-planinfo","text":"","title":"Extracting PlanInfo <pre><code>PlanInfo extractPlanInfo(\n  PlanInfoExtractor planInfoExtractor)\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to planQuery</li> <li><code>ExecutionStep</code> is requested to build</li> <li><code>PlanInfoExtractor</code> is requested to visitRepartitionStep, visitJoinStep and visitSingleSourceStep</li> </ul>"},{"location":"ExecutionStep/#implementations","text":"<ul> <li>SourceStep</li> <li>StreamSelect</li> <li>others</li> </ul>","title":"Implementations"},{"location":"ExecutionStepFactory/","text":"","title":"ExecutionStepFactory"},{"location":"ExecutionStepFactory/#creating-streamsource","text":"","title":"Creating StreamSource <pre><code>StreamSource streamSource(\n  QueryContext.Stacker stacker,\n  LogicalSchema sourceSchema,\n  String topicName,\n  Formats formats,\n  Optional&lt;TimestampColumn&gt; timestampColumn,\n  int pseudoColumnVersion)\n</code></pre> <p><code>streamSource</code> creates a StreamSource.</p> <p><code>streamSource</code> is used when:</p> <ul> <li><code>SchemaKSourceFactory</code> is requested to buildStream</li> </ul>"},{"location":"Executor/","text":"<p><code>Executor</code> is an abstraction of executors that can execute DDL commands.</p>","title":"Executor"},{"location":"Executor/#contract","text":"","title":"Contract"},{"location":"Executor/#executealtersource","text":"","title":"executeAlterSource <pre><code>DdlCommandResult executeAlterSource(\n  AlterSourceCommand alterSource)\n</code></pre> <p>Used when:</p> <ul> <li><code>AlterSourceCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#executecreatestream","text":"","title":"executeCreateStream <pre><code>DdlCommandResult executeCreateStream(\n  CreateStreamCommand createStreamCommand)\n</code></pre> <p>Used when:</p> <ul> <li><code>CreateStreamCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#executecreatetable","text":"","title":"executeCreateTable <pre><code>DdlCommandResult executeCreateTable(\n  CreateTableCommand createTableCommand);\n</code></pre> <p>Used when:</p> <ul> <li><code>CreateTableCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#executedropsource","text":"","title":"executeDropSource <pre><code>DdlCommandResult executeDropSource(\n  DropSourceCommand dropSource)\n</code></pre> <p>Used when:</p> <ul> <li><code>DropSourceCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#executedroptype","text":"","title":"executeDropType <pre><code>DdlCommandResult executeDropType(\n  DropTypeCommand dropType)\n</code></pre> <p>Used when:</p> <ul> <li><code>DropTypeCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#executeregistertype","text":"","title":"executeRegisterType <pre><code>DdlCommandResult executeRegisterType(\n  RegisterTypeCommand registerType)\n</code></pre> <p>Used when:</p> <ul> <li><code>RegisterTypeCommand</code> is requested to execute</li> </ul>"},{"location":"Executor/#implementations","text":"<ul> <li>DdlCommandExec.Executor</li> </ul>","title":"Implementations"},{"location":"Executor/#executing-ddl-command","text":"","title":"Executing DDL Command <pre><code>DdlCommandResult execute(\n  DdlCommand command)\n</code></pre> <p><code>execute</code> requests the given DdlCommand to execute (with this <code>Executor</code>).</p>  <p><code>execute</code> is used when:</p> <ul> <li><code>DdlCommandExec</code> is requested to execute a DDL command</li> </ul>"},{"location":"ExpressionRewriterPlugin/","text":"<p><code>ExpressionRewriterPlugin</code> is...FIXME</p>","title":"ExpressionRewriterPlugin"},{"location":"Format/","text":"<p><code>Format</code> is an abstraction of value and key formats.</p>","title":"Format"},{"location":"FormatFactory/","text":"<p><code>FormatFactory</code> contains built-in serialization Formats.</p>","title":"FormatFactory"},{"location":"FormatFactory/#avro","text":"","title":"AVRO <p><code>AvroFormat</code></p>"},{"location":"FormatFactory/#json","text":"","title":"JSON <p><code>JsonFormat</code></p>"},{"location":"FormatFactory/#json_sr","text":"","title":"JSON_SR <p><code>JsonSchemaFormat</code></p>"},{"location":"FormatFactory/#protobuf","text":"","title":"PROTOBUF <p><code>ProtobufFormat</code></p>"},{"location":"FormatFactory/#kafka","text":"","title":"KAFKA <p><code>KafkaFormat</code></p>"},{"location":"FormatFactory/#delimited","text":"","title":"DELIMITED <p><code>DelimitedFormat</code></p>"},{"location":"FormatFactory/#none","text":"","title":"NONE <p><code>NoneFormat</code></p>"},{"location":"FunctionRegistry/","text":"<p><code>FunctionRegistry</code> is...FIXME</p>","title":"FunctionRegistry"},{"location":"HARouting/","text":"","title":"HARouting"},{"location":"HARouting/#creating-instance","text":"<p><code>HARouting</code> takes the following to be created:</p> <ul> <li> <code>RoutingFilterFactory</code> <li> <code>PullQueryExecutorMetrics</code> <li> KsqlConfig <li> RouteQuery (default: HARouting::executeOrRouteQuery)  <p><code>HARouting</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to buildApplication (and create a QueryExecutor)</li> </ul>","title":"Creating Instance"},{"location":"ImmutableAnalysis/","text":"<p><code>ImmutableAnalysis</code> is an abstraction of the query analysis results.</p> <p>This <code>Immutable</code> prefix in the name of <code>ImmutableAnalysis</code> is to denote that it is an immutable view over the AST tree of a SQL statement (as parsed using Analyzer.Visitor).</p>","title":"ImmutableAnalysis"},{"location":"ImmutableAnalysis/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"ImmutableAnalysis/#gettablefunctions","text":"","title":"getTableFunctions <pre><code>List&lt;FunctionCall&gt; getTableFunctions()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>QueryAnalyzer</code> is requested to analyze a Query</li> <li><code>LogicalPlanner</code> is requested to buildPersistentLogicalPlan</li> <li><code>FlatMapNode</code> is created and buildSchema</li> </ul>"},{"location":"ImmutableAnalysis/#getinto","text":"","title":"getInto <pre><code>Optional&lt;Into&gt; getInto()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>PullQueryValidator</code> is requested to validate</li> <li><code>PushQueryValidator</code> is requested to <code>validate</code></li> <li><code>LogicalPlanner</code> is requested to buildOutputNode, getTargetSchema, buildAggregateNode, buildUserProjectNode and buildAggregateSchema</li> </ul>"},{"location":"ImmutableAnalysis/#getjoin","text":"","title":"getJoin <pre><code>List&lt;JoinInfo&gt; getJoin()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build a source node</li> </ul>"},{"location":"ImmutableAnalysis/#getselectitems","text":"","title":"getSelectItems <pre><code>List&lt;SelectItem&gt; getSelectItems()\n</code></pre> <p>See Analysis</p>"},{"location":"ImmutableAnalysis/#isjoin","text":"","title":"isJoin <pre><code>boolean isJoin()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>PullQueryValidator</code> is created</li> <li><code>LogicalPlanner</code> is requested to build a source node</li> </ul>"},{"location":"ImmutableAnalysis/#implementations","text":"<ul> <li>Analysis</li> </ul>","title":"Implementations"},{"location":"Injector/","text":"<p><code>Injector</code> is...FIXME</p>","title":"Injector"},{"location":"KSPlanBuilder/","text":"<p><code>KSPlanBuilder</code> is a PlanBuilder that builds a Kafka Streams application (from an execution plan).</p>","title":"KSPlanBuilder"},{"location":"KSPlanBuilder/#creating-instance","text":"<p><code>KSPlanBuilder</code> takes the following to be created:</p> <ul> <li> RuntimeBuildContext <li> <code>SqlPredicateFactory</code> <li> <code>AggregateParamsFactory</code> <li> <code>StreamsFactories</code>  <p><code>KSPlanBuilder</code> is created when:</p> <ul> <li><code>QueryBuilder</code> is requested to build a query implementation</li> </ul>","title":"Creating Instance"},{"location":"KSPlanBuilder/#visitstreamselect","text":"","title":"visitStreamSelect <pre><code>KStreamHolder&lt;K&gt; visitStreamSelect(\n  StreamSelect&lt;K&gt; streamSelect,\n  PlanInfo planInfo)\n</code></pre> <p><code>visitStreamSelect</code> is part of the PlanBuilder abstraction.</p>  <p><code>visitStreamSelect</code> requests the given StreamSelect for the ExecutionStep of the source to build.</p> <p>In the end, <code>visitStreamSelect</code> builds a KStreamHolder.</p>"},{"location":"KSPlanBuilder/#visitstreamsource","text":"","title":"visitStreamSource <pre><code>KStreamHolder&lt;GenericKey&gt; visitStreamSource(\n  StreamSource streamSource,\n  PlanInfo planInfo) // (1)!\n</code></pre> <p><code>visitStreamSource</code> is part of the PlanBuilder abstraction.</p>  <ol> <li>The given <code>PlanInfo</code> is not used.</li> </ol> <p><code>visitStreamSource</code> uses the SourceBuilderV1 to build a KStream (for the RuntimeBuildContext, the given StreamSource and the <code>ConsumedFactory</code> from the StreamsFactories).</p>"},{"location":"KSPlanBuilder/#visittablesource","text":"","title":"visitTableSource <pre><code>KTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSource tableSource,\n  PlanInfo planInfo)\nKTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSourceV1 tableSourceV1,\n  PlanInfo planInfo)\n</code></pre> <p><code>visitTableSource</code> is part of the PlanBuilder abstraction.</p>  <p><code>visitTableSource</code> requests the SourceBuilder or SourceBuilderV1 to buildTable.</p>"},{"location":"KafkaStreamsBuilder/","text":"<p><code>KafkaStreamsBuilder</code> is an abstraction of KafkaStreams builders.</p>","title":"KafkaStreamsBuilder"},{"location":"KafkaStreamsBuilder/#contract","text":"","title":"Contract"},{"location":"KafkaStreamsBuilder/#building-kafkastreams-client","text":"","title":"Building KafkaStreams Client <pre><code>KafkaStreams build(\n  Topology topology,\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p>KafkaStreamsBuilderImpl</p> <p>Used when:</p> <ul> <li><code>QueryMetadataImpl</code> is requested to initialize</li> </ul>"},{"location":"KafkaStreamsBuilder/#buildnamedtopologywrapper","text":"","title":"buildNamedTopologyWrapper <pre><code>KafkaStreamsNamedTopologyWrapper buildNamedTopologyWrapper(\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p>KafkaStreamsBuilderImpl</p> <p>Used when:</p> <ul> <li><code>SharedKafkaStreamsRuntime</code> is created</li> <li><code>SharedKafkaStreamsRuntimeImpl</code> is requested to restartStreamsRuntime</li> </ul>"},{"location":"KafkaStreamsBuilder/#implementations","text":"<ul> <li>KafkaStreamsBuilderImpl</li> </ul>","title":"Implementations"},{"location":"KafkaStreamsBuilderImpl/","text":"<p><code>KafkaStreamsBuilderImpl</code> is a KafkaStreamsBuilder.</p> <p><code>KafkaStreamsBuilderImpl</code> acts as a bridge between ksqlDB and Kafka Streams library.</p>","title":"KafkaStreamsBuilderImpl"},{"location":"KafkaStreamsBuilderImpl/#creating-instance","text":"<p><code>KafkaStreamsBuilderImpl</code> takes the following to be created:</p> <ul> <li>KafkaClientSupplier</li> </ul> <p><code>KafkaStreamsBuilderImpl</code> is created along with a QueryBuilder.</p>","title":"Creating Instance"},{"location":"KafkaStreamsBuilderImpl/#kafkaclientsupplier","text":"","title":"KafkaClientSupplier <p><code>KafkaStreamsBuilderImpl</code> is given a <code>KafkaClientSupplier</code> (Kafka Streams) when created.</p>"},{"location":"KafkaStreamsBuilderImpl/#building-kafkastreams-client","text":"","title":"Building KafkaStreams Client <pre><code>KafkaStreams build(\n  Topology topology, \n  Map&lt;String, Object&gt; conf)\n</code></pre> <p><code>build</code> creates a <code>KafkaStreams</code> (Kafka Streams) with the given <code>Topology</code> (Kafka Streams) (with the given <code>conf</code> properties and the KafkaClientSupplier).</p> <p><code>build</code> is part of the KafkaStreamsBuilder abstraction.</p>"},{"location":"KafkaStreamsBuilderImpl/#buildnamedtopologywrapper","text":"","title":"buildNamedTopologyWrapper <pre><code>KafkaStreamsNamedTopologyWrapper buildNamedTopologyWrapper(\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p><code>buildNamedTopologyWrapper</code> creates a <code>KafkaStreamsNamedTopologyWrapper</code> with the given <code>conf</code> properties and the KafkaClientSupplier.</p> <p><code>buildNamedTopologyWrapper</code> is part of the KafkaStreamsBuilder abstraction.</p>"},{"location":"KafkaTopicClientImpl/","text":"<p><code>KafkaTopicClientImpl</code> is a <code>KafkaTopicClient</code>.</p>","title":"KafkaTopicClientImpl"},{"location":"KafkaTopicClientImpl/#creating-instance","text":"<p><code>KafkaTopicClientImpl</code> takes the following to be created:</p> <ul> <li> <code>Supplier&lt;Admin&gt;</code>  <p><code>KafkaTopicClientImpl</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to buildApplication (and create a CommandStore)</li> <li><code>PreconditionChecker</code> is created</li> <li><code>KsqlRestoreCommandTopic</code> is created and requested to <code>maybeCleanUpQuery</code></li> </ul>","title":"Creating Instance"},{"location":"KsqlConfig/","text":"","title":"KsqlConfig"},{"location":"KsqlConfig/#ksqllambdasenabled","text":"","title":"ksql.lambdas.enabled"},{"location":"KsqlConfig/#ksqloutputtopicnameprefix","text":"","title":"ksql.output.topic.name.prefix"},{"location":"KsqlConfig/#ksqlpersistencedefaultformatvalue","text":"","title":"ksql.persistence.default.format.value"},{"location":"KsqlConfig/#ksqlpullqueriesenable","text":"","title":"ksql.pull.queries.enable"},{"location":"KsqlConfig/#ksqlquerypullconsistencytokenenabled","text":"","title":"ksql.query.pull.consistency.token.enabled"},{"location":"KsqlConfig/#ksqlquerypulllimitclauseenabled","text":"","title":"ksql.query.pull.limit.clause.enabled"},{"location":"KsqlConfig/#ksqlquerypullstreamenabled","text":"","title":"ksql.query.pull.stream.enabled <p>Enables pull queries on streams</p> <p>Default: <code>true</code></p> <p>Used when:</p> <ul> <li><code>KsqlEngine</code> is requested to create a stream pull query</li> </ul>"},{"location":"KsqlConfig/#ksqlrowpartitionrowoffsetenabled","text":"","title":"ksql.rowpartition.rowoffset.enabled"},{"location":"KsqlConfig/#ksqlschemaregistryurl","text":"","title":"ksql.schema.registry.url <p>The URL of a schema registry (e.g. Confluent Schema Registry, Apicurio Schema Registry)</p> <p>Default: (empty)</p> <p>Used when:</p> <ul> <li><code>SchemaRegisterInjector</code> is requested to <code>canRegister</code></li> <li><code>DefaultSchemaRegistryClient</code> is requested for <code>SCHEMA_REGISTRY_CONFIG_NOT_SET</code></li> <li><code>KsqlSchemaRegistryClientFactory</code> is created</li> <li><code>KsqlAvroSerdeFactory</code> is requested to <code>getAvroConverter</code></li> <li><code>KsqlJsonSerdeFactory</code> is requested to <code>getSchemaConverter</code></li> <li><code>ProtobufSerdeFactory</code> is requested to <code>getConverter</code></li> <li><code>SourceBuilderUtils</code> is requested to <code>getRegisterCallback</code></li> </ul>"},{"location":"KsqlConfig/#ksqlserviceid","text":"","title":"ksql.service.id <p>The ID of the ksql service.</p> <p>It is used as prefix for all implicitly named resources created by this instance in Kafka. By convention, the id should end in a separator character of some form (e.g. a dash or underscore) as this makes identifiers easier to read.</p> <p>Default: <code>default_</code></p> <p>Used when:</p> <ul> <li><code>MetricCollectors</code> is requested to <code>addConfigurableReporter</code></li> <li><code>DenyListPropertyValidator</code> is created</li> <li><code>QueryApplicationId</code> is requested to buildInternalTopicPrefix</li> <li><code>ReservedInternalTopics</code> is requested to processingLogTopic and toKsqlInternalTopic</li> <li><code>ServiceInfo</code> is created</li> <li><code>CleanupListener</code> is requested to <code>onClose</code></li> <li><code>OrphanedTransientQueryCleaner</code> is requested to <code>cleanupOrphanedInternalTopics</code></li> <li><code>QueryLogger</code> is requested to configure</li> <li><code>QueryBuilder</code> is requested to buildStreamsProperties</li> <li><code>KsqlRestApplication</code> is requested to buildApplication, setUpHttpMetrics</li> <li><code>StandaloneExecutorFactory</code> is created</li> <li>others</li> </ul>"},{"location":"KsqlConfig/#ksqlsourcetablematerializationenabled","text":"","title":"ksql.source.table.materialization.enabled"},{"location":"KsqlConfig/#ksqlvariablesubstitutionenable","text":"","title":"ksql.variable.substitution.enable <p>Enables variable substitution in SQL statements</p> <p>Default: <code>true</code></p> <p>Used when:</p> <ul> <li><code>Cli</code> is requested to isVariableSubstitutionEnabled</li> <li><code>RequestHandler</code> is requested to isVariableSubstitutionEnabled</li> <li><code>RequestValidator</code> is requested to isVariableSubstitutionEnabled</li> </ul>"},{"location":"KsqlEngine/","text":"<p><code>KsqlEngine</code> is a facade of EngineContext.</p>","title":"KsqlEngine"},{"location":"KsqlEngine/#demo-creating-ksqlengine","text":"<pre><code>import io.confluent.ksql.util.KsqlConfig\nval ksqlConfig = KsqlConfig.empty\n\nimport io.confluent.ksql.services._\nval serviceContext = ServiceContextFactory.create(ksqlConfig, () =&gt; DisabledKsqlClient.instance)\n\nimport io.confluent.ksql.logging.processing.ProcessingLogContext\nval processingLogContext = ProcessingLogContext.create()\n\nimport io.confluent.ksql.function.InternalFunctionRegistry\nval functionRegistry = new InternalFunctionRegistry()\n\nimport io.confluent.ksql.ServiceInfo\nval serviceInfo = ServiceInfo.create(ksqlConfig)\n\nimport io.confluent.ksql.query.id.SequentialQueryIdGenerator\nval queryIdGenerator = new SequentialQueryIdGenerator()\n\nimport io.confluent.ksql.engine.QueryEventListener\nimport scala.jdk.CollectionConverters._\nval queryEventListeners = Seq.empty[QueryEventListener].asJava\n\nimport io.confluent.ksql.metrics.MetricCollectors\nval metricCollectors = new MetricCollectors()\n</code></pre> <pre><code>import io.confluent.ksql.engine.KsqlEngine\nval ksqlEngine = new KsqlEngine(\n  serviceContext,\n  processingLogContext,\n  functionRegistry,\n  serviceInfo,\n  queryIdGenerator,\n  ksqlConfig,\n  queryEventListeners,\n  metricCollectors)\n</code></pre>","title":"Demo: Creating KsqlEngine"},{"location":"KsqlEngine/#creating-instance","text":"<p><code>KsqlEngine</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> ProcessingLogContext <li>Service ID</li> <li>MutableMetaStore</li> <li> <code>Function&lt;KsqlEngine, KsqlEngineMetrics&gt;</code> <li> QueryIdGenerator <li> KsqlConfig <li> <code>QueryEventListener</code>s  <p><code>KsqlEngine</code> is created when:</p> <ul> <li><code>KsqlContext</code> is requested to create</li> <li><code>KsqlRestApplication</code> is requested to buildApplication</li> <li><code>StandaloneExecutorFactory</code> is requested to create</li> </ul>","title":"Creating Instance"},{"location":"KsqlEngine/#service-id","text":"","title":"Service ID <p><code>KsqlEngine</code> can be given a Service ID when created. Unless defined, the Service ID is from ServiceInfo based on ksql.service.id configuration property.</p>"},{"location":"KsqlEngine/#mutablemetastore","text":"","title":"MutableMetaStore <p><code>KsqlEngine</code> can be given a MutableMetaStore when created.</p> <p>The <code>MutableMetaStore</code> is used to create the EngineContext.</p>"},{"location":"KsqlEngine/#enginecontext","text":"","title":"EngineContext <p><code>KsqlEngine</code> creates an EngineContext when created.</p> <p><code>KsqlEngine</code> delegates most of its processing to the <code>EngineContext</code> (directly or indirectly usingEngineExecutor) and is (pretty much) their facade.</p>"},{"location":"KsqlEngine/#executing-statement","text":"","title":"Executing Statement <pre><code>ExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement) // (1)!\nExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredKsqlPlan plan)\n</code></pre> <p><code>execute</code> is part of the KsqlExecutionContext abstraction.</p>  <ol> <li>Plans the statement and creates a <code>ConfiguredKsqlPlan</code> for the other <code>execute</code></li> </ol> <p><code>execute</code> creates an EngineExecutor to execute the KsqlPlan (of the given <code>ConfiguredKsqlPlan</code>).</p>"},{"location":"KsqlEngine/#statement-planning-plan","text":"","title":"Statement Planning (plan) <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> is part of the KsqlExecutionContext abstraction.</p>  <p><code>plan</code> creates an EngineExecutor to plan the given <code>ConfiguredStatement</code>.</p>"},{"location":"KsqlEngine/#getalllivequeries","text":"","title":"getAllLiveQueries <pre><code>List&lt;QueryMetadata&gt; getAllLiveQueries()\n</code></pre> <p><code>getAllLiveQueries</code> is part of the KsqlExecutionContext abstraction.</p>  <p><code>getAllLiveQueries</code> requests the EngineContext for the QueryRegistry that is then requested for all live queries.</p>"},{"location":"KsqlEngine/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> is part of the KsqlExecutionContext abstraction.</p>  <p><code>parse</code> requests the EngineContext to parse the given SQL statements (into a collection of <code>ParsedStatement</code>s).</p>"},{"location":"KsqlEngine/#preparing-statement-for-execution","text":"","title":"Preparing Statement for Execution <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>prepare</code> is part of the KsqlExecutionContext abstraction.</p>  <p><code>prepare</code> requests the EngineContext to prepare the given ParsedStatement.</p>"},{"location":"KsqlEngine/#executing-scalable-push-query","text":"","title":"Executing Scalable Push Query <pre><code>ScalablePushQueryMetadata executeScalablePushQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  PushRouting pushRouting,\n  PushRoutingOptions pushRoutingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Context context,\n  Optional&lt;ScalablePushQueryMetrics&gt; scalablePushQueryMetrics)\n</code></pre> <p><code>executeScalablePushQuery</code> creates an EngineExecutor to execute a scalable push query.</p> <p><code>executeScalablePushQuery</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#executing-table-pull-query","text":"","title":"Executing Table Pull Query <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions plannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>executeTablePullQuery</code>...FIXME</p> <p><code>executeTablePullQuery</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#isexecutablestatement","text":"","title":"isExecutableStatement <pre><code>boolean isExecutableStatement(\n  Statement statement)\n</code></pre> <p><code>isExecutableStatement</code> is positive (<code>true</code>) when the given Statement is one of the following:</p> <ul> <li>ExecutableDdlStatement</li> <li>QueryContainer</li> <li>Query</li> </ul>  <p><code>isExecutableStatement</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a statement (and throwOnNonExecutableStatement)</li> <li><code>RequestValidator</code> is requested to validate a statement</li> </ul>"},{"location":"KsqlEngine/#analyzequerywithnooutputtopic","text":"","title":"analyzeQueryWithNoOutputTopic <pre><code>ImmutableAnalysis analyzeQueryWithNoOutputTopic(\n  Query query,\n  String queryText,\n  Map&lt;String, Object&gt; configOverrides)\n</code></pre> <p><code>analyzeQueryWithNoOutputTopic</code>...FIXME</p> <p><code>analyzeQueryWithNoOutputTopic</code> is used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handle pull or push queries</li> </ul>"},{"location":"KsqlEngine/#executing-transient-query","text":"","title":"Executing Transient Query <pre><code>TransientQueryMetadata executeTransientQuery(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones)\n</code></pre> <p><code>executeTransientQuery</code> creates an EngineExecutor to executeTransientQuery.</p> <p><code>executeTransientQuery</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#creating-stream-pull-query","text":"","title":"Creating Stream Pull Query <pre><code>StreamPullQueryMetadata createStreamPullQuery(\n  ServiceContext serviceContext,\n  ImmutableAnalysis analysis,\n  ConfiguredStatement&lt;Query&gt; statementOrig,\n  boolean excludeTombstones)\n</code></pre> <p><code>createStreamPullQuery</code> uses ksql.query.pull.stream.enabled to ensure that pull queries on streams are enabled. If not, <code>createStreamPullQuery</code> throws a <code>KsqlStatementException</code>:</p> <pre><code>Pull queries on streams are disabled.\nTo create a push query on the stream, add EMIT CHANGES to the end.\nTo enable pull queries on streams, set the ksql.query.pull.stream.enabled config to 'true'.\n</code></pre> <p><code>createStreamPullQuery</code>...FIXME</p> <p><code>createStreamPullQuery</code> creates an EngineExecutor to execute the stream pull query.</p> <p><code>createStreamPullQuery</code>...FIXME</p> <p>In the end, <code>createStreamPullQuery</code> returns a <code>StreamPullQueryMetadata</code> with the <code>TransientQueryMetadata</code> and the <code>endOffsets</code>.</p>  <p><code>createStreamPullQuery</code> is used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handle a stream pull query</li> </ul>"},{"location":"KsqlExecutionContext/","text":"<p><code>KsqlExecutionContext</code> is an abstraction of execution contexts.</p>","title":"KsqlExecutionContext"},{"location":"KsqlExecutionContext/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"KsqlExecutionContext/#creating-stream-pull-query","text":"","title":"Creating Stream Pull Query <pre><code>StreamPullQueryMetadata createStreamPullQuery(\n  ServiceContext serviceContext,\n  ImmutableAnalysis analysis,\n  ConfiguredStatement&lt;Query&gt; statementOrig,\n  boolean excludeTombstones)\n</code></pre> <p>See KsqlEngine</p> <p>Used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handleStreamPullQuery</li> </ul>"},{"location":"KsqlExecutionContext/#creating-sandboxed-execution-context-createsandbox","text":"","title":"Creating Sandboxed Execution Context (createSandbox) <pre><code>KsqlExecutionContext createSandbox(\n  ServiceContext serviceContext)\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to execute a SQL text</li> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateAsStatement</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateAs</code></li> <li><code>StandaloneExecutor</code> is requested to validateStatements</li> <li><code>DistributingExecutor</code> is requested to execute</li> <li><code>ExplainExecutor</code> is requested to <code>explainStatement</code></li> <li><code>KsqlResource</code> is requested to configure</li> </ul>"},{"location":"KsqlExecutionContext/#statement-execution-execute","text":"","title":"Statement Execution (execute) <pre><code>ExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredKsqlPlan plan)\nExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p>Executes a KsqlPlan or a Statement</p> <p>Used when:</p> <ul> <li><code>InteractiveStatementExecutor</code> is requested to execute a KsqlPlan</li> <li><code>KsqlContext</code> is requested to execute a statement</li> <li><code>StandaloneExecutor.StatementExecutor</code> is requested to handleExecutableDdl and handlePersistentQuery</li> <li><code>ExplainExecutor</code> is requested to explain a Statement</li> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>ValidatedCommandFactory</code> is requested to createForPlannedQuery</li> </ul>"},{"location":"KsqlExecutionContext/#executing-scalable-push-query","text":"","title":"Executing Scalable Push Query <pre><code>ScalablePushQueryMetadata executeScalablePushQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  PushRouting pushRouting,\n  PushRoutingOptions pushRoutingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Context context,\n  Optional&lt;ScalablePushQueryMetrics&gt; scalablePushQueryMetrics)\n</code></pre> <p>Used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handle a scalable push query</li> </ul>"},{"location":"KsqlExecutionContext/#executing-table-pull-query","text":"","title":"Executing Table Pull Query <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p>Used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handleTablePullQuery</li> </ul>"},{"location":"KsqlExecutionContext/#executing-transient-query","text":"","title":"Executing Transient Query <pre><code>TransientQueryMetadata executeTransientQuery(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones)\n</code></pre> <p>Used when:</p> <ul> <li><code>CustomExecutors</code> is requested to handle a QUERY statement</li> <li><code>ExplainExecutor</code> is requested to explain a QUERY statement</li> <li><code>QueryExecutor</code> is requested to handlePushQuery</li> </ul>"},{"location":"KsqlExecutionContext/#getalllivequeries","text":"","title":"getAllLiveQueries <pre><code>List&lt;QueryMetadata&gt; getAllLiveQueries()\n</code></pre> <p>Used when:</p> <ul> <li><code>ListQueriesExecutor</code> is requested to <code>getLocalSimple</code>, <code>getLocalExtended</code></li> <li><code>QueryCapacityUtil</code> utility is used to <code>getNumLivePushQueries</code></li> </ul>"},{"location":"KsqlExecutionContext/#getpersistentqueries","text":"","title":"getPersistentQueries <pre><code>List&lt;PersistentQueryMetadata&gt; getPersistentQueries()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to getPersistentQueries</li> <li><code>KsqlEngineMetrics</code> is requested to <code>configureNumPersistentQueries</code> and <code>configureGaugeForState</code></li> <li><code>PersistentQuerySaturationMetrics</code> is requested to <code>run</code></li> <li><code>DiscoverClusterService</code> is requested to <code>runOneIteration</code></li> <li><code>SendLagService</code> is requested to <code>runOneIteration</code></li> <li><code>StandaloneExecutor</code> is requested to processesQueryFile</li> <li><code>CommandRunner</code> is requested to processPriorCommands</li> <li>others</li> </ul>"},{"location":"KsqlExecutionContext/#parsing-sql-text","text":"","title":"Parsing SQL Text <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to sql</li> <li><code>SqlFormatInjector</code> is requested to <code>inject</code></li> <li><code>QueryEndpoint</code> is requested to createStatement</li> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>StandaloneExecutor</code> is requested to processesQueryFile</li> <li><code>StatementParser</code> is requested to <code>parseSingleStatement</code></li> <li><code>KsqlResource</code> is requested to handleKsqlStatements</li> </ul>"},{"location":"KsqlExecutionContext/#statement-planning-plan","text":"","title":"Statement Planning (plan) <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p>Plans a given DDL/DML statement (in the ServiceContext) and creates a KsqlPlan</p> <p>See KsqlEngine or SandboxedExecutionContext</p> <p>Used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a statement</li> <li><code>SandboxedExecutionContext</code> is requested to execute a statement</li> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateAsStatement</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateAs</code></li> <li><code>ValidatedCommandFactory</code> is requested to createForPlannedQuery</li> </ul>"},{"location":"KsqlExecutionContext/#preparing-statement-for-execution","text":"","title":"Preparing Statement for Execution <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\nPreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt) // (1)!\n</code></pre> <ol> <li>Uses an empty <code>Map</code></li> </ol> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to execute</li> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>QueryEndpoint</code> is requested to <code>createStatement</code></li> <li><code>RequestHandler</code> is requested to execute</li> <li><code>RequestValidator</code> is requested to validate</li> <li><code>SqlFormatInjector</code> is requested to <code>inject</code></li> <li><code>StandaloneExecutor.StatementExecutor</code> is requested to prepare a statement</li> <li><code>StatementParser</code> is requested to <code>parseSingleStatement</code></li> </ul>"},{"location":"KsqlExecutionContext/#implementations","text":"<ul> <li>KsqlEngine</li> <li>SandboxedExecutionContext</li> </ul>","title":"Implementations"},{"location":"KsqlInternalTopicUtils/","text":"","title":"KsqlInternalTopicUtils"},{"location":"KsqlInternalTopicUtils/#ensuretopic","text":"","title":"ensureTopic <pre><code>void ensureTopic(\n  String name,\n  KsqlConfig ksqlConfig,\n  KafkaTopicClient topicClient)\n</code></pre> <p><code>ensureTopic</code>...FIXME</p>  <p><code>ensureTopic</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>StandaloneExecutorFactory</code> is requested to create a StandaloneExecutor</li> <li><code>KsqlRestoreCommandTopic</code> is requested to <code>restore</code></li> </ul>"},{"location":"KsqlPlan/","text":"<p><code>KsqlPlan</code> is an abstraction of query plans.</p>","title":"KsqlPlan"},{"location":"KsqlPlan/#contract","text":"","title":"Contract"},{"location":"KsqlPlan/#getddlcommand","text":"","title":"getDdlCommand <pre><code>Optional&lt;DdlCommand&gt; getDdlCommand()\n</code></pre> <p>DdlCommand</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateAsStatement</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateAs</code></li> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> <li><code>RestoreCommandsCompactor.CompactedNode</code> is requested to <code>maybeAppend</code></li> </ul>"},{"location":"KsqlPlan/#getpersistentquerytype","text":"","title":"getPersistentQueryType <pre><code>Optional&lt;KsqlConstants.PersistentQueryType&gt; getPersistentQueryType()\n</code></pre> <p><code>PersistentQueryType</code> that can be one of the following:</p> <ul> <li><code>CREATE_SOURCE</code></li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> </ul>"},{"location":"KsqlPlan/#getqueryplan","text":"","title":"getQueryPlan <pre><code>Optional&lt;QueryPlan&gt; getQueryPlan()\n</code></pre> <p>QueryPlan</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>RestoreCommandsCompactor.CompactedNode</code> is requested to <code>maybeAppend</code></li> </ul>"},{"location":"KsqlPlan/#getstatementtext","text":"","title":"getStatementText <pre><code>String getStatementText()\n</code></pre> <p>Statement (in text format)</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>KsqlEngine</code> is requested to execute a statement</li> <li><code>Command</code> utility is used to create a Command</li> </ul>"},{"location":"KsqlPlan/#withoutquery","text":"","title":"withoutQuery <pre><code>KsqlPlan withoutQuery()\n</code></pre> <p>Used when:</p> <ul> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> </ul>"},{"location":"KsqlPlan/#implementations","text":"<ul> <li>KsqlPlanV1</li> </ul>","title":"Implementations"},{"location":"KsqlPlan/#creating-ksqlplan-for-ddlcommand-ddlplancurrent","text":"","title":"Creating KsqlPlan for DdlCommand (ddlPlanCurrent) <pre><code>KsqlPlan ddlPlanCurrent(\n  String statementText,\n  DdlCommand ddlCommand)\n</code></pre> <p><code>ddlPlanCurrent</code> creates a KsqlPlanV1 with the given <code>statementText</code> and the DdlCommand.</p> <p><code>ddlPlanCurrent</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan an ExecutableDdlStatement (for a non-source table)</li> </ul>"},{"location":"KsqlPlan/#creating-ksqlplan-for-queryplan-queryplancurrent","text":"","title":"Creating KsqlPlan for QueryPlan (queryPlanCurrent) <pre><code>KsqlPlan queryPlanCurrent(\n  String statementText,\n  Optional&lt;DdlCommand&gt; ddlCommand,\n  QueryPlan queryPlan)\n</code></pre> <p><code>queryPlanCurrent</code> creates a KsqlPlanV1.</p> <p><code>queryPlanCurrent</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan an ExecutableDdlStatement (with a source table) and plan a QueryContainer</li> </ul>"},{"location":"KsqlPlanV1/","text":"<p><code>KsqlPlanV1</code> is a KsqlPlan that <code>EngineExecutor</code> uses to hold the result of planning statements (as a container for a DdlCommand, a QueryPlan or both):</p> <ol> <li>ExecutableDdlStatement with a non-source table (gives a DdlCommand only)</li> <li>ExecutableDdlStatement with a source table (gives a DdlCommand and a QueryPlan for changes)</li> <li>QueryContainer (gives a QueryPlan and perhaps a DdlCommand to create a sink)</li> </ol>","title":"KsqlPlanV1"},{"location":"KsqlPlanV1/#creating-instance","text":"<p><code>KsqlPlanV1</code> takes the following to be created:</p> <ul> <li> Statement Text <li> (optional) DdlCommand <li> (optional) QueryPlan  <p>When created, <code>KsqlPlanV1</code> makes sure that either a DdlCommand or a QueryPlan is given.</p> <p><code>KsqlPlanV1</code> is created when:</p> <ul> <li><code>KsqlPlan</code> utility is used to create a <code>KsqlPlan</code> for a DdlCommand or a QueryPlan</li> <li><code>KsqlPlanV1</code> is requested for a copy of the current KsqlPlanV1 without a query plan</li> </ul>","title":"Creating Instance"},{"location":"KsqlPlanV1/#current-ksqlplanv1-without-queryplan-withoutquery","text":"","title":"Current KsqlPlanV1 Without QueryPlan (withoutQuery) <pre><code>KsqlPlan withoutQuery()\n</code></pre> <p><code>withoutQuery</code> creates a new KsqlPlanV1 (with the statementText and the ddlCommand but with no QueryPlan).</p> <p><code>withoutQuery</code> is part of the KsqlPlan abstraction.</p>"},{"location":"KsqlQueryType/","text":"<p><code>KsqlQueryType</code> is a collection (enum) of query types in ksqlDB:</p> <ul> <li><code>PERSISTENT</code></li> <li>PULL</li> <li>PUSH</li> </ul>","title":"KsqlQueryType"},{"location":"KsqlQueryType/#pull","text":"","title":"PULL <p><code>KsqlQueryType.PULL</code> is used to request the SlidingWindowRateLimiter to allow the following:</p> <ul> <li>handleStreamPullQuery</li> <li>handleTablePullQuery</li> </ul>"},{"location":"KsqlQueryType/#push","text":"","title":"PUSH <p><code>KsqlQueryType.PULL</code> is used to request the SlidingWindowRateLimiter to allow the following:</p> <ul> <li>handleScalablePushQuery</li> </ul> <p><code>KsqlQueryType.PUSH</code> is the query type of TransientQueryMetadata.</p>"},{"location":"KsqlSchemaRegistryClientFactory/","text":"","title":"KsqlSchemaRegistryClientFactory"},{"location":"KsqlSchemaRegistryClientFactory/#creating-instance","text":"<p><code>KsqlSchemaRegistryClientFactory</code> takes the following to be created:</p> <ul> <li> KsqlConfig <li> <code>RestService</code> factory <li> <code>SSLContext</code> <li> <code>SchemaRegistryClientFactory</code> <li> HTTP Headers (<code>Map&lt;String, String&gt;</code>)  <p><code>KsqlSchemaRegistryClientFactory</code> is created when:</p> <ul> <li><code>ServiceContextFactory</code> is requested for a ServiceContext</li> <li><code>KsqlRestApplication</code> is requested to build a KsqlRestApplication</li> <li><code>PreconditionChecker</code> is requested to <code>buildServiceContext</code></li> </ul>","title":"Creating Instance"},{"location":"KsqlSchemaRegistryClientFactory/#ksqlschemaregistryurl","text":"","title":"ksql.schema.registry.url <p><code>KsqlSchemaRegistryClientFactory</code> uses ksql.schema.registry.url.</p>"},{"location":"MetaStore/","text":"<p><code>MetaStore</code> is...FIXME</p>","title":"MetaStore"},{"location":"MetaStoreImpl/","text":"<p><code>MetaStoreImpl</code> is a MutableMetaStore.</p>","title":"MetaStoreImpl"},{"location":"MetaStoreImpl/#creating-instance","text":"<p><code>MetaStoreImpl</code> takes the following to be created:</p> <ul> <li> Data Sources (<code>Map&lt;SourceName, SourceInfo&gt;</code>) <li> FunctionRegistry <li> TypeRegistry <li> Drop constraints (<code>Map&lt;SourceName, Set&lt;SourceName&gt;&gt;</code>)  <p><code>MetaStoreImpl</code> is created when:</p> <ul> <li><code>EngineExecutor</code> is requested to sourceTablePlan</li> <li><code>KsqlEngine</code> is created</li> </ul>","title":"Creating Instance"},{"location":"MetaStoreImpl/#registering-datasource","text":"","title":"Registering DataSource <pre><code>void putSource(\n  DataSource dataSource,\n  boolean allowReplace)\n</code></pre> <p><code>putSource</code> is part of the MutableMetaStore abstraction.</p>  <p><code>putSource</code> adds the given DataSource to the dataSources registry.</p> <p><code>putSource</code> prints out the following INFO message to the logs:</p> <pre><code>Source [name] created on the metastore\n</code></pre> <p><code>putSource</code> re-builds DROP constraints (if there are any).</p>"},{"location":"MetaStoreImpl/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.metastore.MetaStoreImpl</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.metastore.MetaStoreImpl=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"MutableMetaStore/","text":"<p><code>MutableMetaStore</code> is an extension of the MetaStore abstraction for mutable metastores.</p>","title":"MutableMetaStore"},{"location":"MutableMetaStore/#contract","text":"","title":"Contract"},{"location":"MutableMetaStore/#addsourcereferences","text":"","title":"addSourceReferences <pre><code>void addSourceReferences(\n  SourceName sourceName,\n  Set&lt;SourceName&gt; sourceReferences)\n</code></pre>"},{"location":"MutableMetaStore/#copy","text":"","title":"copy <pre><code>MutableMetaStore copy()\n</code></pre> <p>Makes a copy of this <code>MutableMetaStore</code></p> <p>Used when:</p> <ul> <li><code>EngineContext</code> is requested to createSandbox</li> </ul>"},{"location":"MutableMetaStore/#deletesource","text":"","title":"deleteSource <pre><code>void deleteSource(\n  SourceName sourceName) // (1)!\nvoid deleteSource(\n  SourceName sourceName,\n  boolean restoreInProgress)\n</code></pre> <ol> <li>Turns <code>restoreInProgress</code> off (<code>false</code>)</li> </ol>"},{"location":"MutableMetaStore/#registering-datasource","text":"","title":"Registering DataSource <pre><code>void putSource(\n  DataSource dataSource,\n  boolean allowReplace)\n</code></pre> <p>See MetaStoreImpl</p> <p>Used when:</p> <ul> <li><code>DdlCommandExec.Executor</code> is requested to execute a CreateStreamCommand, executeCreateTable, executeAlterSource</li> <li><code>EngineExecutor</code> is requested to sourceTablePlan</li> </ul>"},{"location":"MutableMetaStore/#implementations","text":"<ul> <li>MetaStoreImpl</li> </ul>","title":"Implementations"},{"location":"PersistentQueryMetadata/","text":"<p><code>PersistentQueryMetadata</code> is an extension of the QueryMetadata abstraction for metadata of persistent queries.</p>","title":"PersistentQueryMetadata"},{"location":"PersistentQueryMetadata/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"PersistentQueryMetadata/#getpersistentquerytype","text":"","title":"getPersistentQueryType <pre><code>KsqlConstants.PersistentQueryType getPersistentQueryType()\n</code></pre> <p>One of the following:</p> <ul> <li><code>CREATE_SOURCE</code></li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>Used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to registerPersistentQuery and unregisterQuery</li> <li><code>PersistentQueryMetadataImpl</code> is created</li> <li><code>ValidatedCommandFactory</code> is requested to createForTerminateQuery</li> </ul>"},{"location":"PersistentQueryMetadata/#implementations","text":"<ul> <li><code>BinPackedPersistentQueryMetadataImpl</code></li> <li>PersistentQueryMetadataImpl</li> </ul>","title":"Implementations"},{"location":"PersistentQueryMetadataImpl/","text":"<p><code>PersistentQueryMetadataImpl</code> is a QueryMetadataImpl and a PersistentQueryMetadata.</p>","title":"PersistentQueryMetadataImpl"},{"location":"PersistentQueryMetadataImpl/#creating-instance","text":"<p><code>PersistentQueryMetadataImpl</code> takes the following to be created:</p> <ul> <li> <code>PersistentQueryType</code> <li> Statement Text <li> <code>PhysicalSchema</code> <li> Source Names <li> Sink DataSource <li> Execution Plan <li> <code>QueryId</code> <li> <code>MaterializationProviderBuilder</code> <li> Query Application ID <li> <code>Topology</code> (Kafka Streams) <li> KafkaStreamsBuilder <li> <code>QuerySchemas</code> <li> Streams Properties (<code>Map&lt;String, Object&gt;</code>) <li> Overrideen Properties (<code>Map&lt;String, Object&gt;</code>) <li> Close Timeout <li> <code>QueryErrorClassifier</code> <li> ExecutionStep <li> <code>maxQueryErrorsQueueSize</code> <li> <code>ProcessingLogger</code> <li> <code>retryBackoffInitialMs</code> <li> <code>retryBackoffMaxMs</code> <li> <code>QueryMetadata.Listener</code> <li> <code>ScalablePushRegistry</code>  <p><code>PersistentQueryMetadataImpl</code> is created when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildPersistentQueryInDedicatedRuntime</li> </ul>","title":"Creating Instance"},{"location":"PhysicalPlan/","text":"","title":"PhysicalPlan"},{"location":"PhysicalPlan/#creating-instance","text":"<p><code>PhysicalPlan</code> takes the following to be created:</p> <ul> <li> <code>QueryId</code> <li> ExecutionStep  <p><code>PhysicalPlan</code> is created when:</p> <ul> <li><code>PhysicalPlanBuilder</code> is requested to buildPhysicalPlan</li> </ul>","title":"Creating Instance"},{"location":"PhysicalPlanBuilder/","text":"","title":"PhysicalPlanBuilder"},{"location":"PhysicalPlanBuilder/#creating-instance","text":"<p><code>PhysicalPlanBuilder</code> takes the following to be created:</p> <ul> <li> <code>StreamsBuilder</code> (Kafka Streams) <li> KsqlConfig <li> ServiceContext <li> <code>ProcessingLogContext</code> <li> <code>FunctionRegistry</code>  <p><code>PhysicalPlanBuilder</code> is created when:</p> <ul> <li><code>QueryEngine</code> is requested to build a physical plan</li> </ul>","title":"Creating Instance"},{"location":"PhysicalPlanBuilder/#building-physical-plan","text":"","title":"Building Physical Plan <pre><code>PhysicalPlan buildPhysicalPlan(\n  LogicalPlanNode logicalPlanNode,\n  QueryId queryId,\n  Optional&lt;PlanInfo&gt; oldPlanInfo)\n</code></pre> <p><code>buildPhysicalPlan</code>...FIXME</p> <p><code>buildPhysicalPlan</code> is used when:</p> <ul> <li><code>QueryEngine</code> is requested to build a physical plan</li> </ul>"},{"location":"PlanBuilder/","text":"<p><code>PlanBuilder</code> is an abstraction of query plan builders (for <code>QueryBuilder</code> to build a query implementation from an execution plan).</p>","title":"PlanBuilder"},{"location":"PlanBuilder/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"PlanBuilder/#visiting-streamselect","text":"","title":"Visiting StreamSelect <pre><code>KStreamHolder&lt;K&gt; visitStreamSelect(\n  StreamSelect&lt;K&gt; streamSelect,\n  PlanInfo planInfo)\n</code></pre> <p>Visits a StreamSelect</p> <p>See KSPlanBuilder</p> <p>Used when:</p> <ul> <li><code>StreamSelect</code> is requested to build a KStreamHolder</li> </ul>"},{"location":"PlanBuilder/#visiting-streamsource","text":"","title":"Visiting StreamSource <pre><code>KStreamHolder&lt;GenericKey&gt; visitStreamSource(\n  StreamSource streamSource,\n  PlanInfo planInfo)\n</code></pre> <p>Visits a StreamSource</p> <p>See KSPlanBuilder</p> <p>Used when:</p> <ul> <li><code>StreamSource</code> is requested to build a KStreamHolder</li> </ul>"},{"location":"PlanBuilder/#visiting-tablesource","text":"","title":"Visiting TableSource <pre><code>KTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSourceV1 tableSourceV1,\n  PlanInfo planInfo)\nKTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSource tableSource,\n  PlanInfo planInfo)\n</code></pre> <p>See KSPlanBuilder</p> <p>Used when:</p> <ul> <li><code>TableSourceV1</code> is requested to <code>build</code> a <code>KTableHolder</code></li> <li><code>TableSource</code> is requested to <code>build</code> a <code>KTableHolder</code></li> </ul>"},{"location":"PlanBuilder/#implementations","text":"<ul> <li>KSPlanBuilder</li> </ul>","title":"Implementations"},{"location":"PlanInfoExtractor/","text":"<p><code>PlanInfoExtractor</code> is...FIXME</p>","title":"PlanInfoExtractor"},{"location":"PullQueryValidator/","text":"<p><code>PullQueryValidator</code> is...FIXME</p>","title":"PullQueryValidator"},{"location":"PushQueryMetadata/","text":"<p><code>PushQueryMetadata</code> is...FIXME</p>","title":"PushQueryMetadata"},{"location":"QueryAnalyzer/","text":"","title":"QueryAnalyzer"},{"location":"QueryAnalyzer/#creating-instance","text":"<p><code>QueryAnalyzer</code> takes the following to be created:</p> <ul> <li> MetaStore <li> Output Topic Prefix <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> <code>pullLimitClauseEnabled</code> flag  <p><code>QueryAnalyzer</code> is created when:</p> <ul> <li><code>KsqlEngine</code> is requested to analyzeQueryWithNoOutputTopic</li> <li><code>QueryEngine</code> utility is used to buildQueryLogicalPlan</li> </ul>","title":"Creating Instance"},{"location":"QueryAnalyzer/#analyzer","text":"","title":"Analyzer <p>Unless given, <code>QueryAnalyzer</code> creates an Analyzer when created.</p> <p>The <code>Analyzer</code> is used to analyze a query.</p>"},{"location":"QueryAnalyzer/#query-analysis","text":"","title":"Query Analysis <pre><code>Analysis analyze(\n  Query query,\n  Optional&lt;Sink&gt; sink)\n</code></pre> <p></p> <p><code>analyze</code> requests the Analyzer to analyze the query.</p> <p><code>analyze</code> requests the pull or push query validator to validate the analysis based on whether it is a pull query or not, respectively.</p>  <p>The optional <code>Sink</code> can only be defined when <code>QueryEngine</code> is requested to buildQueryLogicalPlan.</p>  <p><code>analyze</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to analyzeQueryWithNoOutputTopic</li> <li><code>QueryEngine</code> is requested to buildQueryLogicalPlan</li> </ul>"},{"location":"QueryApplicationId/","text":"","title":"QueryApplicationId"},{"location":"QueryApplicationId/#build","text":"","title":"build <pre><code>String build(\n  KsqlConfig config,\n  boolean persistent,\n  QueryId queryId)\n</code></pre> <p><code>build</code>...FIXME</p> <p><code>build</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested to <code>buildTransientQuery</code> and <code>buildPersistentQueryInDedicatedRuntime</code></li> <li><code>ListSourceExecutor</code> is requested to <code>queryOffsetSummaries</code></li> <li><code>KsqlRestoreCommandTopic</code> is requested to <code>maybeCleanUpQuery</code></li> </ul>"},{"location":"QueryBuilder/","text":"","title":"QueryBuilder"},{"location":"QueryBuilder/#creating-instance","text":"<p><code>QueryBuilder</code> takes the following to be created:</p> <ul> <li> <code>SessionConfig</code> <li> <code>ProcessingLogContext</code> <li> ServiceContext <li> <code>FunctionRegistry</code> <li>KafkaStreamsBuilder</li> <li> <code>MaterializationProviderBuilderFactory</code> <li> SharedKafkaStreamsRuntimes <li> <code>real</code> flag  <p><code>QueryBuilder</code> is created when:</p> <ul> <li><code>QueryRegistryImpl</code> is created</li> </ul>","title":"Creating Instance"},{"location":"QueryBuilder/#kafkastreamsbuilder","text":"","title":"KafkaStreamsBuilder <p><code>QueryBuilder</code> can be given a KafkaStreamsBuilder when created. Unless given, <code>QueryBuilder</code> creates a KafkaStreamsBuilderImpl with the KafkaClientSupplier from the given ServiceContext.</p> <p>The <code>KafkaStreamsBuilder</code> is used when:</p> <ul> <li>buildTransientQuery</li> <li>buildPersistentQueryInDedicatedRuntime</li> <li>getKafkaStreamsInstance</li> </ul>"},{"location":"QueryBuilder/#building-transient-query","text":"","title":"Building Transient Query <pre><code>TransientQueryMetadata buildTransientQuery(\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones,\n  QueryMetadata.Listener listener,\n  StreamsBuilder streamsBuilder,\n  Optional&lt;ImmutableMap&lt;TopicPartition, Long&gt;&gt; endOffsets)\n</code></pre> <p><code>buildTransientQuery</code> requests the SessionConfig for the KsqlConfig (with overrides applied).</p> <p><code>buildTransientQuery</code> builds the following:</p> <ul> <li>Application ID (with <code>persistent</code> flag disabled)</li> <li>RuntimeBuildContext</li> <li>Configuration properties</li> <li>QueryImplementation</li> <li>TransientQueryQueue</li> </ul> <p><code>buildTransientQuery</code> requests the given <code>StreamsBuilder</code> (Kafka Streams) to build a <code>Topology</code> (Kafka Streams).</p> <p><code>buildTransientQuery</code> determines a <code>ResultType</code> (based on the <code>QueryImplementation</code> and the optional <code>windowInfo</code>):</p> <ul> <li><code>WINDOWED_TABLE</code> for a <code>KTableHolder</code> with the <code>windowInfo</code> specified</li> <li><code>TABLE</code> for a <code>KTableHolder</code> with no <code>windowInfo</code> specified</li> <li><code>STREAM</code> for all other cases</li> </ul> <p>In the end, <code>buildTransientQuery</code> creates a TransientQueryMetadata.</p> <p><code>buildTransientQuery</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to createTransientQuery and createStreamPullQuery</li> </ul>"},{"location":"QueryBuilder/#building-runtimebuildcontext","text":"","title":"Building RuntimeBuildContext <pre><code>RuntimeBuildContext buildContext(\n  String applicationId,\n  QueryId queryId,\n  StreamsBuilder streamsBuilder)\n</code></pre> <p><code>buildContext</code> creates a RuntimeBuildContext.</p> <p><code>buildContext</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildTransientQuery, buildPersistentQueryInDedicatedRuntime, buildPersistentQueryInSharedRuntime and getNamedTopology</li> </ul>"},{"location":"QueryBuilder/#building-query-implementation","text":"","title":"Building Query Implementation <pre><code>Object buildQueryImplementation(\n  ExecutionStep&lt;?&gt; physicalPlan,\n  RuntimeBuildContext runtimeBuildContext)\n</code></pre>  <p>Kafka Streams</p> <p>This is the moment in a ksqlDB query's life cycle when the physical plan is converted into a Kafka Streams application.</p>  <p><code>buildQueryImplementation</code> creates a KSPlanBuilder with the given RuntimeBuildContext.</p> <p>In the end, <code>buildQueryImplementation</code> requests the given physical plan to build a Kafka Streams application (with the <code>KSPlanBuilder</code>).</p> <p><code>buildQueryImplementation</code> is used when <code>QueryBuilder</code> is requested to build the following:</p> <ul> <li>Transient query</li> <li>Persistent query in a dedicated or shared runtime</li> <li>getNamedTopology</li> </ul>"},{"location":"QueryBuilder/#building-persistent-query-shared-runtime","text":"","title":"Building Persistent Query (Shared Runtime) <pre><code>PersistentQueryMetadata buildPersistentQueryInSharedRuntime(\n  KsqlConfig ksqlConfig,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  QueryMetadata.Listener listener,\n  Supplier&lt;List&lt;PersistentQueryMetadata&gt;&gt; allPersistentQueries,\n  String applicationId,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildPersistentQueryInSharedRuntime</code> looks up the (shared) KafkaStreams instance for the given <code>applicationId</code>.</p> <p><code>buildPersistentQueryInSharedRuntime</code> requests the (shared) KafkaStreams instance for the <code>KafkaStreams</code> instance to create a <code>NamedTopologyBuilder</code> (Kafka Streams) for the given <code>queryId</code>.</p> <p><code>buildPersistentQueryInSharedRuntime</code> builds a query implementation for the given physical plan.</p> <p><code>buildPersistentQueryInSharedRuntime</code> requests the <code>NamedTopologyBuilder</code> to build a <code>NamedTopology</code> (Kafka Streams).</p> <p><code>buildPersistentQueryInSharedRuntime</code>...FIXME</p> <p><code>buildPersistentQueryInSharedRuntime</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to createOrReplacePersistentQuery</li> </ul>"},{"location":"QueryBuilder/#finding-namedtopology","text":"","title":"Finding NamedTopology <pre><code>NamedTopology getNamedTopology(\n  SharedKafkaStreamsRuntime sharedRuntime,\n  QueryId queryId,\n  String applicationId,\n  Map&lt;String, Object&gt;  queryOverrides,\n  ExecutionStep&lt;?&gt; physicalPlan)\n</code></pre> <p><code>getNamedTopology</code>...FIXME</p>"},{"location":"QueryBuilder/#getkafkastreamsinstance","text":"","title":"getKafkaStreamsInstance <pre><code>SharedKafkaStreamsRuntime getKafkaStreamsInstance(\n  Set&lt;SourceName&gt; sources,\n  QueryId queryID,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>getKafkaStreamsInstance</code>...FIXME</p>"},{"location":"QueryBuilder/#building-persistent-query-dedicated-runtime","text":"","title":"Building Persistent Query (Dedicated Runtime) <pre><code>PersistentQueryMetadata buildPersistentQueryInDedicatedRuntime(\n  KsqlConfig ksqlConfig,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  QueryMetadata.Listener listener,\n  Supplier&lt;List&lt;PersistentQueryMetadata&gt;&gt; allPersistentQueries,\n  StreamsBuilder streamsBuilder,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildPersistentQueryInDedicatedRuntime</code> builds an application ID (with the <code>persistent</code> flag enabled).</p> <p><code>buildPersistentQueryInDedicatedRuntime</code> buildStreamsProperties.</p> <p><code>buildPersistentQueryInDedicatedRuntime</code>...FIXME</p> <p><code>buildPersistentQueryInDedicatedRuntime</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to createOrReplacePersistentQuery (with a shared runtime ID)</li> </ul>"},{"location":"QueryBuilderFactory/","text":"<p><code>QueryBuilderFactory</code> is...FIXME</p>","title":"QueryBuilderFactory"},{"location":"QueryEngine/","text":"","title":"QueryEngine"},{"location":"QueryEngine/#creating-instance","text":"<p><code>QueryEngine</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> <code>ProcessingLogContext</code>  <p><code>QueryEngine</code> is created when:</p> <ul> <li><code>EngineContext</code> is requested to create one (when <code>EngineExecutor</code> is requested to plan a Query for execution)</li> </ul>","title":"Creating Instance"},{"location":"QueryEngine/#building-logical-plan-of-query-buildquerylogicalplan","text":"","title":"Building Logical Plan of Query (buildQueryLogicalPlan) <pre><code>OutputNode buildQueryLogicalPlan(\n  Query query,\n  Optional&lt;Sink&gt; sink,\n  MetaStore metaStore,\n  KsqlConfig config,\n  boolean rowpartitionRowoffsetEnabled)\n</code></pre> <p><code>buildQueryLogicalPlan</code> takes a Query statement and returns an OutputNode.</p>  <p>The optional <code>Sink</code> can only be defined when <code>EngineExecutor</code> is requested to plan a statement (which is a QueryContainer).</p>  <p><code>buildQueryLogicalPlan</code> creates a QueryAnalyzer with the MetaStore and the values of the following configuration properties (from the given KsqlConfig):</p> <ul> <li>KSQL_OUTPUT_TOPIC_NAME_PREFIX_CONFIG</li> <li>KSQL_QUERY_PULL_LIMIT_CLAUSE_ENABLED</li> </ul> <p><code>buildQueryLogicalPlan</code> requests the <code>QueryAnalyzer</code> to analyze the given query.</p> <p>In the end, <code>buildQueryLogicalPlan</code> creates a LogicalPlanner to buildPersistentLogicalPlan.</p>  <p><code>buildQueryLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a query</li> </ul>"},{"location":"QueryEngine/#building-physical-query-plan-buildphysicalplan","text":"","title":"Building Physical Query Plan (buildPhysicalPlan) <pre><code>PhysicalPlan buildPhysicalPlan(\n  LogicalPlanNode logicalPlanNode,\n  SessionConfig config,\n  MetaStore metaStore,\n  QueryId queryId,\n  Optional&lt;PlanInfo&gt; oldPlanInfo)\n</code></pre> <p><code>buildPhysicalPlan</code> creates a <code>StreamsBuilder</code> (Kafka Streams).</p> <p><code>buildPhysicalPlan</code> creates a PhysicalPlanBuilder (with the <code>StreamsBuilder</code>).</p> <p>In the end, <code>buildPhysicalPlan</code> requests the <code>PhysicalPlanBuilder</code> to build a physical plan for the given <code>LogicalPlanNode</code> (and the given <code>QueryId</code> and the current <code>PlanInfo</code> of the query to be \"replaced\").</p>  <p><code>buildPhysicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a query</li> </ul>"},{"location":"QueryEventListener/","text":"<p><code>QueryEventListener</code> is...FIXME</p>","title":"QueryEventListener"},{"location":"QueryLogger/","text":"<p><code>QueryLogger</code> is...FIXME</p>","title":"QueryLogger"},{"location":"QueryMetadata/","text":"<p><code>QueryMetadata</code> is an abstraction of query metadatas.</p>","title":"QueryMetadata"},{"location":"QueryMetadata/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"QueryMetadata/#getkafkastreams","text":"","title":"getKafkaStreams <pre><code>KafkaStreams getKafkaStreams()\n</code></pre> <p><code>KafkaStreams</code> (Kafka Streams) to execute this query</p> <p>Used when:</p> <ul> <li><code>SandboxedExecutionContext</code> is requested to execute</li> <li><code>PersistentQueryMetadataImpl</code> is requested to initialize</li> <li><code>TransientQueryMetadata</code> is requested to isRunning</li> <li><code>PersistentQuerySaturationMetrics</code> is requested to <code>measure</code></li> <li><code>QueryMetricsUtil</code> is requested to <code>initializePullStreamMetricsCallback</code></li> </ul>"},{"location":"QueryMetadata/#getquerytype","text":"","title":"getQueryType <pre><code>KsqlConstants.KsqlQueryType getQueryType()\n</code></pre> <p>KsqlQueryType of this query</p> <p>Used when:</p> <ul> <li><code>QueryDescriptionFactory</code> is requested to <code>create</code> a <code>QueryDescription</code></li> <li><code>ListQueriesExecutor</code> is requested to <code>getLocalSimple</code> (for <code>LIST QUERIES</code> command)</li> </ul>"},{"location":"QueryMetadata/#gettopology","text":"","title":"getTopology <pre><code>Topology getTopology()\n</code></pre> <p><code>Topology</code> (Kafka Streams) of this query</p> <p>Used when:</p> <ul> <li><code>PersistentQueryMetadataImpl</code> is requested to initialize</li> <li><code>SandboxedSharedKafkaStreamsRuntimeImpl</code> is created</li> <li><code>SharedKafkaStreamsRuntimeImpl</code> is requested to start a query and restartStreamsRuntime</li> </ul>"},{"location":"QueryMetadata/#start","text":"","title":"start <pre><code>void start()\n</code></pre> <p>Starts this query</p> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to sql</li> <li><code>StandaloneExecutor</code> is requested to processesQueryFile</li> <li><code>CommandRunner</code> is requested to processPriorCommands</li> <li><code>InteractiveStatementExecutor</code> is requested to executePlan</li> </ul>"},{"location":"QueryMetadata/#implementations","text":"<ul> <li>PersistentQueryMetadata</li> <li>QueryMetadataImpl</li> </ul>","title":"Implementations"},{"location":"QueryMetadataImpl/","text":"<p><code>QueryMetadataImpl</code> is a QueryMetadata.</p> <p><code>QueryMetadataImpl</code> is a thin wrapper around KafkaStreams.</p>","title":"QueryMetadataImpl"},{"location":"QueryMetadataImpl/#creating-instance","text":"<p><code>QueryMetadataImpl</code> takes the following to be created:</p> <ul> <li> Statement Text <li> <code>LogicalSchema</code> <li> Names of the Sources <li> Execution Plan <li> queryApplicationId <li>Topology</li> <li>KafkaStreamsBuilder</li> <li> Streams Properties <li> overriddenProperties <li> <code>closeTimeout</code> <li> <code>QueryId</code> <li> <code>QueryErrorClassifier</code> <li> <code>maxQueryErrorsQueueSize</code> <li> <code>baseWaitingTimeMs</code> <li> <code>retryBackoffMaxMs</code> <li> <code>Listener</code>","title":"Creating Instance"},{"location":"QueryMetadataImpl/#topology","text":"","title":"Topology <p><code>QueryMetadataImpl</code> is given a <code>Topology</code> (Kafka Streams) when created.</p> <p>The <code>Topology</code> is used when:</p> <ul> <li>initialize</li> <li>getTopologyDescription</li> </ul>"},{"location":"QueryMetadataImpl/#gettopology","text":"","title":"getTopology <pre><code>Topology getTopology()\n</code></pre> <p><code>getTopology</code> is part of the QueryMetadata abstraction.</p>  <p><code>getTopology</code> returns the Topology instance.</p>"},{"location":"QueryMetadataImpl/#kafkastreams","text":"","title":"KafkaStreams <p><code>QueryMetadataImpl</code> is given a <code>KafkaStreams</code> (Kafka Streams) when created and requested to resetKafkaStreams.</p> <p>The <code>KafkaStreams</code> is started at start and closed at close.</p> <p>The <code>KafkaStreams</code> is used when:</p> <ul> <li>getTaskMetadata</li> <li>setUncaughtExceptionHandler</li> <li>getState</li> <li>getAllLocalStorePartitionLags</li> <li>getAllStreamsHostMetadata</li> <li>doClose</li> </ul>"},{"location":"QueryMetadataImpl/#getkafkastreams","text":"","title":"getKafkaStreams <pre><code>KafkaStreams getKafkaStreams()\n</code></pre> <p><code>getKafkaStreams</code> is part of the QueryMetadata abstraction.</p>  <p><code>getKafkaStreams</code> returns the KafkaStreams instance.</p>"},{"location":"QueryMetadataImpl/#kafkastreamsbuilder","text":"","title":"KafkaStreamsBuilder <p><code>QueryMetadataImpl</code> is given a KafkaStreamsBuilder when created.</p>"},{"location":"QueryMetadataImpl/#initialize","text":"","title":"initialize <pre><code>void initialize()\n</code></pre> <p><code>initialize</code> requests the KafkaStreamsBuilder to build a KafkaStreams instance (with the Topology and the streamsProperties).</p> <p><code>initialize</code> resets the KafkaStreams instance and turns the initialized flag on.</p> <p><code>initialize</code> is part of the QueryMetadata abstraction.</p>"},{"location":"QueryMetadataImpl/#query-type","text":"","title":"Query Type <pre><code>KsqlQueryType getQueryType()\n</code></pre> <p><code>getQueryType</code> is part of the QueryMetadata abstraction.</p>  <p><code>getQueryType</code> is KsqlQueryType.PERSISTENT.</p>"},{"location":"QueryMetadataImpl/#closing-query","text":"","title":"Closing Query <pre><code>void close()\n</code></pre> <p><code>close</code> is part of the QueryMetadata abstraction.</p>  <p><code>close</code> requests the loggerFactory for...FIXME</p> <p><code>close</code> doClose (with <code>cleanUp</code> enabled).</p> <p>In the end, <code>close</code> requests the Listener to <code>onClose</code>.</p>"},{"location":"QueryMetadataImpl/#doclose","text":"","title":"doClose <pre><code>void doClose(\n  boolean cleanUp)\n</code></pre> <p><code>doClose</code> closeKafkaStreams and then requests the KafkaStreams to <code>cleanUp</code>.</p> <p><code>doClose</code> prints out the following WARN message to the logs when closeKafkaStreams did not succeed:</p> <pre><code>Query has not successfully closed, skipping cleanup\n</code></pre>  <p><code>doClose</code> is used when:</p> <ul> <li><code>PersistentQueryMetadataImpl</code> is requested to stop (with <code>cleanUp</code> disabled)</li> <li><code>QueryMetadataImpl</code> is requested to close (with <code>cleanUp</code> enabled)</li> </ul>"},{"location":"QueryMetadataImpl/#closekafkastreams","text":"","title":"closeKafkaStreams <pre><code>boolean closeKafkaStreams()\n</code></pre> <p><code>closeKafkaStreams</code>...FIXME</p>"},{"location":"QueryPlan/","text":"<p><code>QueryPlan</code> is...FIXME</p>","title":"QueryPlan"},{"location":"QueryRegistry/","text":"<p><code>QueryRegistry</code> is an abstraction of query registries for building and managing queries.</p>","title":"QueryRegistry"},{"location":"QueryRegistry/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"QueryRegistry/#createorreplacepersistentquery","text":"","title":"createOrReplacePersistentQuery <pre><code>PersistentQueryMetadata createOrReplacePersistentQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  Optional&lt;String&gt; sharedRuntimeId)\n</code></pre> <p>See QueryRegistryImpl.createOrReplacePersistentQuery</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a persistent query</li> </ul>"},{"location":"QueryRegistry/#creating-stream-pull-query","text":"","title":"Creating Stream Pull Query <pre><code>TransientQueryMetadata createStreamPullQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones,\n  ImmutableMap&lt;TopicPartition, Long&gt; endOffsets)\n</code></pre> <p>QueryRegistryImpl.createStreamPullQuery</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeStreamPullQuery</li> </ul>"},{"location":"QueryRegistry/#createtransientquery","text":"","title":"createTransientQuery <pre><code>TransientQueryMetadata createTransientQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones)\n</code></pre> <p>QueryRegistryImpl.createTransientQuery</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTransientQuery</li> </ul>"},{"location":"QueryRegistry/#getalllivequeries","text":"","title":"getAllLiveQueries <pre><code>List&lt;QueryMetadata&gt; getAllLiveQueries()\n</code></pre> <p>All active queries (QueryMetadata)</p> <p>QueryRegistryImpl.getAllLiveQueries</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTransientQuery, executeStreamPullQuery, sourceTablePlan, plan a statement</li> <li><code>KsqlEngine</code> is requested to getAllLiveQueries</li> <li><code>SandboxedExecutionContext</code> is requested to getAllLiveQueries</li> <li><code>TransientQueryCleanupService</code> is requested to <code>isCorrespondingQueryTerminated</code></li> <li><code>QueryRegistryImpl</code> is requested to close live queries</li> </ul>"},{"location":"QueryRegistry/#implementations","text":"<ul> <li>QueryRegistryImpl</li> </ul>","title":"Implementations"},{"location":"QueryRegistryImpl/","text":"","title":"QueryRegistryImpl"},{"location":"QueryRegistryImpl/#creating-instance","text":"<p><code>QueryRegistryImpl</code> takes the following to be created:</p> <ul> <li> QueryEventListeners <li>QueryBuilderFactory</li> <li> <code>MetricCollectors</code>  <p><code>QueryRegistryImpl</code> is created when:</p> <ul> <li><code>EngineContext</code> utility is used to create an EngineContext</li> </ul>","title":"Creating Instance"},{"location":"QueryRegistryImpl/#querybuilderfactory","text":"","title":"QueryBuilderFactory <p><code>QueryRegistryImpl</code> is given a QueryBuilderFactory or defines a function to create a QueryBuilder when created.</p>"},{"location":"QueryRegistryImpl/#creating-stream-pull-query","text":"","title":"Creating Stream Pull Query <pre><code>TransientQueryMetadata createStreamPullQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones,\n  ImmutableMap&lt;TopicPartition, Long&gt; endOffsets)\n</code></pre> <p><code>createStreamPullQuery</code> is part of the QueryRegistry abstraction.</p>  <p><code>createStreamPullQuery</code> requests the QueryBuilderFactory for a QueryBuilder to buildTransientQuery (with a new Kafka Streams' <code>StreamsBuilder</code>).</p> <p><code>createStreamPullQuery</code> requests the TransientQueryMetadata to initialize.</p> <p><code>createStreamPullQuery</code> notifies the QueryEventListeners.</p>"},{"location":"QueryRegistryImpl/#creating-transient-query","text":"","title":"Creating Transient Query <pre><code>TransientQueryMetadata createTransientQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones)\n</code></pre> <p><code>createTransientQuery</code> is part of the QueryRegistry abstraction.</p>  <p><code>createTransientQuery</code> requests the QueryBuilderFactory for a QueryBuilder.</p> <p><code>createTransientQuery</code> requests the <code>QueryBuilder</code> to build a transient query (with a new <code>StreamsBuilder</code> (Kafka Streams) that gives a TransientQueryMetadata).</p> <p><code>createTransientQuery</code> requests the <code>TransientQueryMetadata</code> to initialize.</p> <p><code>createTransientQuery</code> registerTransientQuery and returns the <code>TransientQueryMetadata</code>.</p>"},{"location":"QueryRegistryImpl/#creating-or-replacing-persistent-query","text":"","title":"Creating or Replacing Persistent Query <pre><code>PersistentQueryMetadata createOrReplacePersistentQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  Optional&lt;String&gt; sharedRuntimeId)\n</code></pre> <p><code>createOrReplacePersistentQuery</code> requests the QueryBuilderFactory for a QueryBuilder to build a persistent query in shared or dedicated runtime based on the given <code>sharedRuntimeId</code> (available or not, respectively).</p> <p>In the end, <code>createOrReplacePersistentQuery</code> registers the persistent query.</p>  <p><code>createOrReplacePersistentQuery</code> is part of the QueryRegistry abstraction.</p>"},{"location":"QueryRegistryImpl/#registerpersistentquery","text":"","title":"registerPersistentQuery <pre><code>void registerPersistentQuery(\n  ServiceContext serviceContext,\n  MetaStore metaStore,\n  PersistentQueryMetadata persistentQuery)\n</code></pre> <p><code>registerPersistentQuery</code> takes the <code>QueryId</code> from the given <code>PersistentQueryMetadata</code>.</p> <p><code>registerPersistentQuery</code> requests the given <code>PersistentQueryMetadata</code> to initialize when this is a new query (a new <code>QueryId</code>) or the old query is not sandboxed.</p> <p><code>registerPersistentQuery</code> adds the <code>QueryId</code> with the <code>PersistentQueryMetadata</code> to the persistentQueries registry.</p> <p><code>registerPersistentQuery</code> registers the persistent query based on the type:</p> <ul> <li> <p>For <code>CREATE_SOURCE</code>, the single source name with the query ID in the createAsQueries registry</p> </li> <li> <p>For <code>CREATE_AS</code>, the sink name with the query ID in the createAsQueries registry</p> </li> <li> <p>For <code>INSERT</code>, all the sink and source names with the query ID in the insertQueries registry</p> </li> </ul> <p><code>registerPersistentQuery</code> adds the <code>QueryId</code> with the <code>PersistentQueryMetadata</code> to the allLiveQueries registry.</p> <p>In the end, <code>registerPersistentQuery</code> notifies event listeners.</p>"},{"location":"QueryRegistryImpl/#notifying-queryeventlisteners-about-create-queries","text":"","title":"Notifying QueryEventListeners about Create Queries <pre><code>void notifyCreate(\n  ServiceContext serviceContext,\n  MetaStore metaStore,\n  QueryMetadata queryMetadata)\n</code></pre> <p><code>notifyCreate</code> requests the QueryEventListeners to onCreate</p> <p><code>notifyCreate</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to create a StreamPullQuery and register persistent or transient queries</li> </ul>"},{"location":"QueryValidator/","text":"<p><code>QueryValidator</code> is...FIXME</p>","title":"QueryValidator"},{"location":"RegisterTypeCommand/","text":"<p><code>RegisterTypeCommand</code> is...FIXME</p>","title":"RegisterTypeCommand"},{"location":"RewriterPlugin/","text":"<p><code>RewriterPlugin</code> is...FIXME</p>","title":"RewriterPlugin"},{"location":"RewrittenAnalysis/","text":"<p><code>RewrittenAnalysis</code> is an ImmutableAnalysis.</p>","title":"RewrittenAnalysis"},{"location":"RouteQuery/","text":"<p><code>RouteQuery</code> is an abstraction of query routers.</p>","title":"RouteQuery"},{"location":"RouteQuery/#contract","text":"","title":"Contract"},{"location":"RouteQuery/#routequery_1","text":"","title":"routeQuery <pre><code>PartitionFetchResult routeQuery(\n  KsqlNode node,\n  KsqlPartitionLocation location,\n  ConfiguredStatement&lt;Query&gt; statement,\n  ServiceContext serviceContext,\n  RoutingOptions routingOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  PullPhysicalPlan pullPhysicalPlan,\n  LogicalSchema outputSchema,\n  QueryId queryId,\n  PullQueryQueue pullQueryQueue,\n  CompletableFuture&lt;Void&gt; shouldCancelRequests,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p>Used when:</p> <ul> <li><code>HARouting</code> is requested to executeRounds</li> </ul>"},{"location":"RouteQuery/#implementations","text":"<ul> <li>HARouting::executeOrRouteQuery</li> </ul>","title":"Implementations"},{"location":"RuntimeBuildContext/","text":"","title":"RuntimeBuildContext"},{"location":"RuntimeBuildContext/#creating-instance","text":"<p><code>RuntimeBuildContext</code> takes the following to be created:</p> <ul> <li>StreamsBuilder</li> <li> KsqlConfig <li> ServiceContext <li> <code>ProcessingLogContext</code> <li> <code>FunctionRegistry</code> <li> Application ID <li> <code>QueryId</code> <li> <code>KeySerdeFactory</code> <li> <code>ValueSerdeFactory</code>  <p><code>RuntimeBuildContext</code> is created using of factory.</p>","title":"Creating Instance"},{"location":"RuntimeBuildContext/#streamsbuilder","text":"","title":"StreamsBuilder <p><code>RuntimeBuildContext</code> is given a <code>StreamsBuilder</code> (Kafka Streams) when created.</p> <p>The <code>StreamsBuilder</code> is used when:</p> <ul> <li><code>SourceBuilder</code> is requested to buildKTable</li> <li><code>SourceBuilderV1</code> is requested to buildKTable and buildKStream</li> </ul>"},{"location":"RuntimeBuildContext/#creating-runtimebuildcontext","text":"","title":"Creating RuntimeBuildContext <pre><code>RuntimeBuildContext of(\n  final StreamsBuilder streamsBuilder,\n  final KsqlConfig ksqlConfig,\n  final ServiceContext serviceContext,\n  final ProcessingLogContext processingLogContext,\n  final FunctionRegistry functionRegistry,\n  final String applicationId,\n  final QueryId queryId)\n</code></pre> <p><code>of</code> creates a RuntimeBuildContext (with a <code>GenericKeySerDe</code> and <code>GenericRowSerDe</code>).</p> <p><code>of</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested for a RuntimeBuildContext</li> </ul>"},{"location":"SandboxedExecutionContext/","text":"<p><code>SandboxedExecutionContext</code> is a KsqlExecutionContext for executing SQL statements without affecting the state of the system (i.e. no changes to the core engine's state nor the state of external services).</p>","title":"SandboxedExecutionContext"},{"location":"SandboxedExecutionContext/#creating-instance","text":"<p><code>SandboxedExecutionContext</code> takes the following to be created:</p> <ul> <li> EngineContext <li> ServiceContext <li> <code>MetricCollectors</code>  <p><code>SandboxedExecutionContext</code> is created when:</p> <ul> <li><code>KsqlEngine</code> is requested to create a sandboxed execution context</li> <li><code>SandboxedExecutionContext</code> is requested to create a sandboxed execution context</li> </ul>  <p><code>SandboxedExecutionContext</code> is a <code>KsqlExecutionContext</code> and part of the abstraction is to create a SandboxedExecutionContext. This is exactly <code>SandboxedExecutionContext</code> itself by default.</p> <p>That's why instances of <code>SandboxedExecutionContext</code>s are created indirectly via KsqlExecutionContext.</p>","title":"Creating Instance"},{"location":"SandboxedExecutionContext/#enginecontext","text":"","title":"EngineContext <p>While being created, <code>SandboxedExecutionContext</code> requests the given source EngineContext to create a sandboxed EngineContext.</p>"},{"location":"SandboxedExecutionContext/#statement-planning-plan","text":"","title":"Statement Planning (plan) <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> is part of the KsqlExecutionContext abstraction.</p>  <p><code>plan</code> creates an EngineExecutor to plan the given <code>ConfiguredStatement</code>.</p>"},{"location":"SandboxedExecutionContext/#executing-statement","text":"","title":"Executing Statement <pre><code>ExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement) // (1)\nExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredKsqlPlan plan)\n</code></pre> <ol> <li>Plans the statement and creates a <code>ConfiguredKsqlPlan</code> for the other <code>execute</code></li> </ol> <p><code>execute</code> creates an EngineExecutor to execute the KsqlPlan (of the <code>ConfiguredKsqlPlan</code>) and produce an <code>ExecuteResult</code>.</p> <p><code>execute</code> requests the <code>ExecuteResult</code> for the QueryMetadata and get the KafkaStreams client that is closed right after.</p> <p>In the end, <code>execute</code> returns the <code>ExecuteResult</code>.</p> <p><code>execute</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"SandboxedExecutionContext/#executing-transient-query","text":"","title":"Executing Transient Query <pre><code>TransientQueryMetadata executeTransientQuery(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones)\n</code></pre> <p><code>executeTransientQuery</code> creates an EngineExecutor to executeTransientQuery.</p> <p><code>executeTransientQuery</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"SchemaKSourceFactory/","text":"","title":"SchemaKSourceFactory"},{"location":"SchemaKSourceFactory/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildSource(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  QueryContext.Stacker contextStacker)\n</code></pre> <p><code>buildSource</code> requests the given DataSource whether it is windowed or not and the type.</p> <p>For <code>KSTREAM</code> type, <code>buildSource</code> builds a windowed or regular stream based on whether it is windowed or not, respectively.</p> <p>For <code>KTABLE</code> type, <code>buildSource</code> builds a windowed or regular table based on whether it is windowed or not, respectively.</p> <p><code>buildSource</code> is used when:</p> <ul> <li><code>DataSourceNode</code> is created</li> </ul>"},{"location":"SchemaKSourceFactory/#buildstream","text":"","title":"buildStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  Stacker contextStacker)\n</code></pre> <p><code>buildStream</code> creates a new SchemaKStream with a StreamSource.</p>"},{"location":"SchemaKSourceFactory/#buildwindowedstream","text":"","title":"buildWindowedStream <pre><code>SchemaKStream&lt;?&gt; buildWindowedStream(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  Stacker contextStacker)\n</code></pre> <p><code>buildWindowedStream</code>...FIXME</p>"},{"location":"SchemaKSourceFactory/#schemakstream","text":"","title":"schemaKStream <pre><code>SchemaKStream&lt;K&gt; schemaKStream(\n  PlanBuildContext buildContext,\n  LogicalSchema schema,\n  KeyFormat keyFormat,\n  SourceStep&lt;KStreamHolder&lt;K&gt;&gt; streamSource)\n</code></pre> <p><code>schemaKStream</code> creates a SchemaKStream.</p>"},{"location":"SchemaKStream/","text":"","title":"SchemaKStream"},{"location":"SchemaKStream/#creating-instance","text":"<p><code>SchemaKStream</code> takes the following to be created:</p> <ul> <li> ExecutionStep of <code>KStreamHolder&lt;K&gt;</code> <li> <code>LogicalSchema</code> <li> <code>KeyFormat</code> <li> KsqlConfig <li> <code>FunctionRegistry</code>  <p><code>SchemaKStream</code> is created when:</p> <ul> <li><code>SchemaKSourceFactory</code> is requested to schemaKStream</li> <li><code>SchemaKStream</code> is requested to into, filter, flatMap and others</li> </ul>","title":"Creating Instance"},{"location":"ServiceContext/","text":"<p><code>ServiceContext</code> is...FIXME</p>","title":"ServiceContext"},{"location":"ServiceContextFactory/","text":"","title":"ServiceContextFactory"},{"location":"ServiceContextFactory/#creating-servicecontext","text":"","title":"Creating ServiceContext <pre><code>ServiceContext create(\n  KsqlConfig ksqlConfig,\n  Supplier&lt;SimpleKsqlClient&gt; ksqlClientSupplier)\nServiceContext create(\n  KsqlConfig ksqlConfig,\n  KafkaClientSupplier kafkaClientSupplier,\n  Supplier&lt;SchemaRegistryClient&gt; srClientFactory,\n  Supplier&lt;ConnectClient&gt; connectClientSupplier,\n  Supplier&lt;SimpleKsqlClient&gt; ksqlClientSupplier)\n</code></pre> <p><code>create</code> creates a <code>DefaultServiceContext</code> with the following:</p> <ul> <li><code>DefaultKafkaClientSupplier</code></li> <li>KsqlSchemaRegistryClientFactory</li> </ul>  <p><code>create</code> is used when:</p> <ul> <li><code>KsqlContext</code> utility is requested for a KsqlContext</li> <li><code>RestServiceContextFactory</code> is requested to create a ServiceContext</li> <li><code>StandaloneExecutorFactory</code> utility is requested for a StandaloneExecutor</li> </ul>"},{"location":"ServiceInfo/","text":"","title":"ServiceInfo"},{"location":"ServiceInfo/#creating-instance","text":"<p><code>ServiceInfo</code> takes the following to be created:</p> <ul> <li> ksql.service.id <li> Custom Metrics Tags (<code>Map&lt;String, String&gt;</code>) <li> <code>KsqlMetricsExtension</code> <li> Metrics Prefix  <p><code>ServiceInfo</code> is created using create factory.</p>","title":"Creating Instance"},{"location":"ServiceInfo/#creating-serviceinfo","text":"","title":"Creating ServiceInfo <pre><code>ServiceInfo create(\n  KsqlConfig ksqlConfig)\nServiceInfo create(\n  KsqlConfig ksqlConfig,\n  String metricsPrefix)\n</code></pre> <p><code>create</code>...FIXME</p>  <p><code>create</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to build a KsqlRestApplication</li> <li><code>KsqlContext</code> is created</li> <li><code>StandaloneExecutorFactory</code> is created</li> </ul>"},{"location":"SessionConfig/","text":"<p><code>SessionConfig</code> is...FIXME</p>","title":"SessionConfig"},{"location":"SharedKafkaStreamsRuntime/","text":"<p><code>SharedKafkaStreamsRuntime</code> is...FIXME</p>","title":"SharedKafkaStreamsRuntime"},{"location":"SharedKafkaStreamsRuntimeImpl/","text":"<p><code>SharedKafkaStreamsRuntimeImpl</code> is...FIXME</p>","title":"SharedKafkaStreamsRuntimeImpl"},{"location":"SlidingWindowRateLimiter/","text":"<p><code>SlidingWindowRateLimiter</code> is...FIXME</p>","title":"SlidingWindowRateLimiter"},{"location":"SourceBuilder/","text":"<p><code>SourceBuilder</code> is a SourceBuilderBase.</p>","title":"SourceBuilder"},{"location":"SourceBuilder/#sourcebuilder-instance","text":"","title":"SourceBuilder Instance <p><code>SourceBuilder</code> defines <code>instance</code> static value with an instance of <code>SourceBuilder</code>.</p> <p>The <code>instance</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitTableSource</li> </ul>"},{"location":"SourceBuilder/#building-ktable","text":"","title":"Building KTable <pre><code>KTable&lt;K, GenericRow&gt; buildKTable(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator,\n  Materialized&lt;K, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt; materialized,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName,\n  PlanInfo planInfo)\n</code></pre> <p><code>buildKTable</code>...FIXME</p> <p><code>buildKTable</code> is part of the SourceBuilderBase abstraction.</p>"},{"location":"SourceBuilderBase/","text":"<p><code>SourceBuilderBase</code> is an abstraction of source builders (that <code>KSPlanBuilder</code> uses when visitTableSource).</p>","title":"SourceBuilderBase"},{"location":"SourceBuilderBase/#contract","text":"","title":"Contract"},{"location":"SourceBuilderBase/#building-ktable","text":"","title":"Building KTable <pre><code>KTable&lt;K, GenericRow&gt; buildKTable(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator,\n  Materialized&lt;K, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt; materialized,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName,\n  PlanInfo planInfo)\n</code></pre> <p>Builds a <code>KTable</code> (Kafka Streams)</p> <p>Used when:</p> <ul> <li><code>SourceBuilderBase</code> is requested to buildTable</li> <li><code>SourceBuilderV1</code> is requested to buildWindowedTable</li> </ul>"},{"location":"SourceBuilderBase/#building-table-materialized","text":"","title":"Building Table Materialized <pre><code>Materialized&lt;GenericKey, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt;\nbuildTableMaterialized(\n  SourceStep&lt;KTableHolder&lt;GenericKey&gt;&gt; source,\n  RuntimeBuildContext buildContext,\n  MaterializedFactory materializedFactory,\n  Serde&lt;GenericKey&gt; keySerde,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName)\n</code></pre> <p>Builds a <code>Materialized</code> (Kafka Streams)</p> <p>Used when:</p> <ul> <li><code>SourceBuilderBase</code> is requested to buildTable</li> </ul>"},{"location":"SourceBuilderBase/#implementations","text":"<ul> <li>SourceBuilder</li> <li>SourceBuilderV1</li> </ul>","title":"Implementations"},{"location":"SourceBuilderBase/#buildtable","text":"","title":"buildTable <pre><code>KTableHolder&lt;GenericKey&gt; buildTable(\n  RuntimeBuildContext buildContext,\n  SourceStep&lt;KTableHolder&lt;GenericKey&gt;&gt; source,\n  ConsumedFactory consumedFactory,\n  MaterializedFactory materializedFactory,\n  PlanInfo planInfo)\n</code></pre> <p><code>buildTable</code> gets a PhysicalSchema, a ValueSerde and a KeySerde (<code>Serde&lt;GenericKey&gt;</code>s).</p> <p><code>buildTable</code> buildSourceConsumed (with <code>AutoOffsetReset.EARLIEST</code> offset reset).</p> <p><code>buildTable</code> buildTableMaterialized and buildKTable (a <code>KTable&lt;GenericKey, GenericRow&gt;</code>).</p> <p>In the end, <code>buildTable</code> creates a <code>KTableHolder</code> (with the <code>KTable</code>).</p> <p><code>buildTable</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitTableSource</li> </ul>"},{"location":"SourceBuilderV1/","text":"<p><code>SourceBuilderV1</code> is a SourceBuilderBase.</p>","title":"SourceBuilderV1"},{"location":"SourceBuilderV1/#creating-instance","text":"<p><code>SourceBuilderV1</code> takes no arguments to be created.</p> <p><code>SourceBuilderV1</code> is created when the Java class is first loaded by JVM (and available using instance public static value).</p>","title":"Creating Instance"},{"location":"SourceBuilderV1/#sourcebuilderv1-instance","text":"","title":"SourceBuilderV1 Instance <p><code>SourceBuilderV1</code> uses an <code>instance</code> internal registry of the only application-wide <code>SourceBuilderV1</code> (that is created right when the class is loaded by JVM).</p>  <p>Note</p> <p><code>instance</code> is a <code>private static final</code> value.</p>  <p><code>instance</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitStreamSource, visitWindowedStreamSource, visitTableSource and visitWindowedTableSource</li> </ul>"},{"location":"SourceBuilderV1/#buildstream","text":"","title":"buildStream <pre><code>KStreamHolder&lt;GenericKey&gt; buildStream(\n  RuntimeBuildContext buildContext,\n  StreamSource source,\n  ConsumedFactory consumedFactory)\n</code></pre> <p><code>buildStream</code> gets a PhysicalSchema for the given StreamSource.</p> <p><code>buildStream</code> getValueSerde, getKeySerde and builds a Consumed.</p> <p><code>buildStream</code> builds a KStream (with the given StreamSource, the <code>Consumed</code> and a non-windowed <code>KeyGenerator</code>).</p> <p>In the end, <code>buildStream</code> creates a <code>KStreamHolder</code> for the <code>KStream</code>.</p> <p><code>buildStream</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitStreamSource</li> </ul>"},{"location":"SourceBuilderV1/#buildkstream","text":"","title":"buildKStream <pre><code>KStream&lt;K, GenericRow&gt; buildKStream(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator)\n</code></pre> <p><code>buildKStream</code>...FIXME</p> <p><code>buildKStream</code> is used when:</p> <ul> <li><code>SourceBuilderV1</code> is requested to buildStream and buildWindowedStream</li> </ul>"},{"location":"SourceStep/","text":"<p><code>SourceStep&lt;K&gt;</code> is an extension of the ExecutionStep abstraction for source execution steps.</p>","title":"SourceStep"},{"location":"SourceStep/#implementations","text":"<ul> <li>StreamSource</li> <li><code>TableSource</code></li> <li><code>TableSourceV1</code></li> <li><code>WindowedStreamSource</code></li> <li><code>WindowedTableSource</code></li> </ul>","title":"Implementations"},{"location":"SourceStep/#creating-instance","text":"<p><code>SourceStep</code> takes the following to be created:</p> <ul> <li> <code>ExecutionStepPropertiesV1</code> <li> Topic Name <li> <code>Formats</code> <li> <code>TimestampColumn</code> <li> <code>LogicalSchema</code> <li> Pseudo Column Version   <p>Abstract Class</p> <p><code>SourceStep</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete SourceSteps.</p>","title":"Creating Instance"},{"location":"SqlTypeParser/","text":"","title":"SqlTypeParser"},{"location":"SqlTypeParser/#demo","text":"<pre><code>import io.confluent.ksql.schema.ksql.SqlTypeParser\nval typeParser = SqlTypeParser.create(TypeRegistry.EMPTY)\n</code></pre>","title":"Demo"},{"location":"SqlTypeParser/#creating-instance","text":"<p><code>SqlTypeParser</code> takes the following to be created:</p> <ul> <li> TypeRegistry  <p><code>SqlTypeParser</code> is created using create factory.</p>","title":"Creating Instance"},{"location":"SqlTypeParser/#creating-sqltypeparser","text":"","title":"Creating SqlTypeParser <pre><code>SqlTypeParser create(\n  TypeRegistry typeRegistry)\n</code></pre> <p><code>create</code> creates a SqlTypeParser with the given <code>TypeRegistry</code>.</p>  <p><code>create</code> is used when:</p> <ul> <li><code>UserFunctionLoader</code> is created</li> <li><code>AstBuilder.Visitor</code> is created</li> <li><code>SchemaParser</code> is requested to <code>parse</code> a schema</li> <li><code>SqlTypeDeserializer</code> is requested to <code>deserialize</code></li> <li><code>KsqlTargetUtil</code> is requested to <code>createSchema</code></li> </ul>"},{"location":"SqlTypeParser/#gettype","text":"","title":"getType <pre><code>Type getType(\n  SqlBaseParser.TypeContext type)\n</code></pre> <p><code>getType</code> getSqlType and creates a <code>Type</code>.</p>  <p><code>getType</code> is used when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to visitAlterOption, visitCast, visitTableElement, visitRegisterType</li> <li><code>SchemaParser</code> is requested to parse a schema</li> <li><code>SqlTypeParser</code> is requested to parse a schema</li> </ul>"},{"location":"SqlTypeParser/#getsqltype","text":"","title":"getSqlType <pre><code>SqlType getSqlType(\n  SqlBaseParser.TypeContext type)\n</code></pre> <p><code>getSqlType</code>...FIXME</p>"},{"location":"StreamSelect/","text":"<p><code>StreamSelect&lt;K&gt;</code> is an ExecutionStep (of <code>KStreamHolder</code>).</p>","title":"StreamSelect"},{"location":"StreamSelect/#creating-instance","text":"<p><code>StreamSelect</code> takes the following to be created:</p> <ul> <li> <code>ExecutionStepPropertiesV1</code> <li> Source ExecutionStep <li> Key column names (<code>List&lt;ColumnName&gt;</code>) <li> Select keys (<code>Optional&lt;List&lt;ColumnName&gt;&gt;</code>) <li> Select Expressions (<code>List&lt;SelectExpression&gt;</code>)  <p><code>StreamSelect</code> is created when:</p> <ul> <li><code>ExecutionStepFactory</code> is requested to streamSelect</li> </ul>","title":"Creating Instance"},{"location":"StreamSelect/#building-kstreamholder","text":"","title":"Building KStreamHolder <pre><code>KStreamHolder&lt;K&gt; build(\n  PlanBuilder builder,\n  PlanInfo info)\n</code></pre> <p><code>build</code> is part of the ExecutionStep abstraction.</p>  <p><code>build</code> requests the given PlanBuilder to visit a StreamSelect.</p>"},{"location":"StreamSelectBuilder/","text":"","title":"StreamSelectBuilder"},{"location":"StreamSelectBuilder/#building-kstreamholder","text":"","title":"Building KStreamHolder <pre><code>KStreamHolder&lt;K&gt; build(\n  KStreamHolder&lt;K&gt; stream,\n  StreamSelect&lt;K&gt; step,\n  RuntimeBuildContext buildContext)\n</code></pre> <p><code>build</code>...FIXME</p>  <p><code>build</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visit a StreamSelect</li> </ul>"},{"location":"StreamSource/","text":"<p><code>StreamSource</code> is a SourceStep that builds a <code>KStream</code> (Kafka Streams).</p>","title":"StreamSource"},{"location":"StreamSource/#creating-instance","text":"<p><code>StreamSource</code> takes the following to be created:</p> <ul> <li> <code>ExecutionStepPropertiesV1</code> <li> Topic Name <li> <code>Formats</code> <li> <code>TimestampColumn</code> <li> <code>LogicalSchema</code> <li> Pseudo Column Version  <p><code>StreamSource</code> is created when:</p> <ul> <li><code>ExecutionStepFactory</code> is requested for a StreamSource</li> </ul>","title":"Creating Instance"},{"location":"StreamSource/#building-kstreamholder","text":"","title":"Building KStreamHolder <pre><code>KStreamHolder&lt;GenericKey&gt; build(\n  PlanBuilder builder,\n  PlanInfo info)\n</code></pre> <p><code>build</code> requests the given PlanBuilder to visitStreamSource (with this <code>StreamSource</code> and the given <code>PlanInfo</code>).</p> <p><code>build</code> is part of the ExecutionStep abstraction.</p>"},{"location":"TransientQueryMetadata/","text":"<p><code>TransientQueryMetadata</code> is a QueryMetadataImpl and a PushQueryMetadata.</p>","title":"TransientQueryMetadata"},{"location":"TransientQueryMetadata/#creating-instance","text":"<p><code>TransientQueryMetadata</code> takes the following to be created:</p> <ul> <li> Statement text <li> <code>LogicalSchema</code> <li> Source Names <li> Execution plan <li> <code>BlockingRowQueue</code> <li> <code>QueryId</code> <li> Query Application ID <li> <code>Topology</code> (Kafka Streams) <li> KafkaStreamsBuilder <li> Streams Properties <li> Overridden Properties <li> Close timeout <li> <code>maxQueryErrorsQueueSize</code> <li> <code>ResultType</code> <li> <code>retryBackoffInitialMs</code> <li> <code>retryBackoffMaxMs</code> <li> <code>Listener</code> <li> <code>ProcessingLoggerFactory</code>  <p><code>TransientQueryMetadata</code> is created when:</p> <ul> <li><code>QueryBuilder</code> is requested to build a transient query</li> <li><code>SandboxedTransientQueryMetadata</code> is created</li> </ul>","title":"Creating Instance"},{"location":"TransientQueryMetadata/#query-type","text":"","title":"Query Type <pre><code>KsqlQueryType getQueryType()\n</code></pre> <p><code>getQueryType</code> is part of the QueryMetadata abstraction.</p>  <p><code>getQueryType</code> is KsqlQueryType.PUSH.</p>"},{"location":"TypeRegistry/","text":"<p><code>TypeRegistry</code> is...FIXME</p>","title":"TypeRegistry"},{"location":"UserFunctionLoader/","text":"<p><code>UserFunctionLoader</code> is...FIXME</p>","title":"UserFunctionLoader"},{"location":"VersionCheckerAgent/","text":"<p><code>VersionCheckerAgent</code> is...FIXME</p>","title":"VersionCheckerAgent"},{"location":"debugging/","text":"<p>Start KsqlServerMain (directly or indirectly using ksql-server-start shell script) with the following JPDA configuration as part of <code>KSQL_OPTS</code> environment variable.</p> <pre><code>export KSQL_OPTS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005\"\n</code></pre> <p><code>suspend=y</code> will suspend the JVM process until you attach to the <code>address=*:5005</code>.</p> <pre><code>$ ./bin/ksql-server-start config/ksql-server.properties\nListening for transport dt_socket at address: 5005\n</code></pre> <p>Attach to the process (e.g., in IntelliJ IDEA) and step through the code. Enjoy!</p>","title":"Debugging ksqlDB"},{"location":"logging/","text":"<p>ksqldb uses Apache Log4j 2 for logging and uses <code>etc/ksqldb/log4j.properties</code> by default.</p> <p>The default logging level is <code>INFO</code> with <code>stdout</code> appender.</p> <pre><code>log4j.rootLogger=INFO, stdout\n</code></pre> <p>There are various appenders for streams, clients and connect subsystems.</p>","title":"Logging"},{"location":"overview/","text":"<p>ksqlDB is \"the database purpose-built for stream processing applications.\"</p>","title":"ksqlDB"},{"location":"overview/#how-ksqldb-works","text":"<p>ksqlDB uses KsqlServerMain to handle SQL queries (from the command line or sent through a REST endpoint, e.g. using ksql).</p> <p>KsqlResource is used to...FIXME</p>","title":"How ksqlDB Works"},{"location":"overview/#executing-ddl-commands","text":"<p>DdlCommands (e.g. <code>CREATE STREAM</code>) are parsed by AstBuilder.Visitor to Statements.</p> <p>DDL commands are then planned for execution using EngineExecutor and executed by (per command-line options):</p> <ul> <li>DistributingExecutor</li> <li>StatementExecutor</li> </ul> <p><code>DistributingExecutor</code> uses a transactional Kafka producer to enqueue the command (to the CommandQueue) that is then fetched by CommandRunner.</p> <p>CommandRunner uses InteractiveStatementExecutor to execute commands.</p> <p>When requested to handle a statement (as part of an enqueued command), <code>InteractiveStatementExecutor</code> uses KsqlEngine to execute a ksql plan.</p> <p>For DdlCommands, EngineExecutor uses EngineContext to execute it (using DdlCommandExec).</p>","title":"Executing DDL Commands"},{"location":"overview/#run-it-yourself","text":"<p>Get standalone ksqlDB first</p> <p>The following assumes the standalone ksqlDB version installed per ksqlDB Quickstart.</p> <pre><code>curl http://ksqldb-packages.s3.amazonaws.com/archive/0.27/confluent-ksqldb-0.27.2.tar.gz \\\n    --output confluent-ksqldb-0.27.2.tar.gz\n</code></pre>  <pre><code>$ cd $KAFKA_HOME\n\n$ ./bin/zookeeper-server-start.sh config/zookeeper.properties\n\n$ ./bin/kafka-server-start.sh config/server.properties\n\n$ ./bin/ksql-server-start etc/ksqldb/ksql-server.properties\n\n                  ===========================================\n                  =       _              _ ____  ____       =\n                  =      | | _____  __ _| |  _ \\| __ )      =\n                  =      | |/ / __|/ _` | | | | |  _ \\      =\n                  =      |   &lt;\\__ \\ (_| | | |_| | |_) |     =\n                  =      |_|\\_\\___/\\__, |_|____/|____/      =\n                  =                   |_|                   =\n                  =        The Database purpose-built       =\n                  =        for stream processing apps       =\n                  ===========================================\n\nCopyright 2017-2022 Confluent Inc.\n\nServer 0.27.2 listening on http://0.0.0.0:8088\n\nTo access the KSQL CLI, run:\nksql http://0.0.0.0:8088\n</code></pre> <p>ksqlDB uses ksql as the command-line interactive environment.</p> <pre><code>$ ./bin/ksql\n                  ===========================================\n                  =       _              _ ____  ____       =\n                  =      | | _____  __ _| |  _ \\| __ )      =\n                  =      | |/ / __|/ _` | | | | |  _ \\      =\n                  =      |   &lt;\\__ \\ (_| | | |_| | |_) |     =\n                  =      |_|\\_\\___/\\__, |_|____/|____/      =\n                  =                   |_|                   =\n                  =        The Database purpose-built       =\n                  =        for stream processing apps       =\n                  ===========================================\n\nCopyright 2017-2022 Confluent Inc.\n\nCLI v0.27.2, Server v0.27.2 located at http://localhost:8088\nServer Status: RUNNING\n\nHaving trouble? Type 'help' (case-insensitive) for a rundown of how things work!\n\nksql&gt;\n</code></pre>","title":"Run It Yourself"},{"location":"overview/#learning-resources","text":"","title":"Learning Resources"},{"location":"overview/#articles","text":"<ol> <li>Deep Dive into ksqlDB Deployment Options</li> </ol>","title":"Articles"},{"location":"overview/#videos","text":"<ol> <li>KSQL 201: A Deep Dive into Query Processing</li> </ol>","title":"Videos"},{"location":"persistent-queries/","text":"<p>Persistent Queries (per <code>PersistentQueryType</code>) can be the following queries:</p> <ul> <li>CREATE_SOURCE</li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>When Analyzer is requested to analyze a query it creates a Visitor with a flag to indicate whether the sink is defined or not for persistent queries.</p>","title":"Persistent Queries"},{"location":"persistent-queries/#create_source","text":"","title":"CREATE_SOURCE <p><code>CREATE_SOURCE</code>s don't write to a topic (so <code>EngineExecutor</code> does not have to check for read-only topics the other query types could attempt to write to).</p> <p>It is forbidden to terminate <code>CREATE_SOURCE</code> queries when linked to a source table (and <code>ValidatedCommandFactory</code> throws a KsqlStatementException):</p> <pre><code>Cannot terminate query '[queryId]' because it is linked to a source table.\n</code></pre> <p><code>EngineExecutor</code> will not execute <code>CREATE_SOURCE</code> plans when ksql.source.table.materialization.enabled is disabled and prints out the following INFO message to the logs instead:</p> <pre><code>Source table query '[statementText]' won't be materialized because 'ksql.source.table.materialization.enabled' is disabled.\n</code></pre> <p><code>CREATE_SOURCE</code> is used when:</p> <ul> <li><code>KsqlPlanV1</code> is requested for the getPersistentQueryType (with the queryPlan and the ddlCommand specified as a source <code>CreateTableCommand</code>)</li> <li><code>QueryBuilder</code> is requested to buildPersistentQueryInDedicatedRuntime and buildPersistentQueryInSharedRuntime</li> <li><code>QueryRegistryImpl</code> is requested to registerPersistentQuery and unregisterQuery</li> </ul>"},{"location":"processing-log/","text":"<p>ksqlDB Documentation</p> <p>Learn more in the ksqlDB Documentation.</p>","title":"Processing Log"},{"location":"pull-queries/","text":"<p>Pull Queries are non-persistent (transient) <code>SELECT</code> queries with no <code>EMIT CHANGES</code> clause (that is part of push queries).</p> <p>Pull Queries retrieve the latest result from a source (a materialized view, a table, or a stream) instantly and as of \"now\".</p> <p>Pull queries are printed out only in the console.</p> <p>Pull queries follow a traditional request/response model. They retrieve a finite result from the ksqlDB server and terminate (like in traditional databases).</p> <p>Pull queries use an eventually consistent consistency model.</p>","title":"Pull Queries"},{"location":"pull-queries/#stream-pull-queries","text":"<p>Stream Pull Queries (pull queries over stream) are pull queries over streams and are executed using QueryExecutor.</p>","title":"Stream Pull Queries"},{"location":"pull-queries/#table-pull-queries","text":"<p>Table Pull Queries (pull queries over table) are pull queries over tables and are executed using QueryExecutor.</p>","title":"Table Pull Queries"},{"location":"pull-queries/#demo","text":"<p>Demo: Pull Queries</p>","title":"Demo"},{"location":"pull-queries/#learning-resources","text":"<ul> <li>Pull</li> <li>SELECT (Pull Query)</li> </ul>","title":"Learning Resources"},{"location":"push-queries/","text":"<p>Push Queries are non-persistent <code>SELECT</code> queries with <code>EMIT CHANGES</code> clause.</p> <p>Push queries are executed continuously and never end unless cancelled by a user or <code>LIMIT</code> is reached. They are a perfect fit for real-time updates from a source (a stream or a materialized view).</p>","title":"Push Queries"},{"location":"server-properties/","text":"","title":"Server Properties"},{"location":"server-properties/#ksqlloggingprocessingtopicautocreate","text":"","title":"ksql.logging.processing.topic.auto.create <p>Enables creating the processing log topic if not exists</p> <p>ProcessingLogConfig</p>"},{"location":"server-properties/#ksqlloggingprocessingstreamname","text":"","title":"ksql.logging.processing.stream.name"},{"location":"server-properties/#ksqlloggingprocessingtopicname","text":"","title":"ksql.logging.processing.topic.name"},{"location":"server-properties/#ksqlloggingprocessingtopicpartitions","text":"","title":"ksql.logging.processing.topic.partitions"},{"location":"server-properties/#ksqlloggingprocessingtopicreplicationfactor","text":"","title":"ksql.logging.processing.topic.replication.factor"},{"location":"server-properties/#ksqlloggingprocessingstreamautocreate","text":"","title":"ksql.logging.processing.stream.auto.create"},{"location":"server-properties/#ksqlloggingprocessingtopicautocreate_1","text":"","title":"ksql.logging.processing.topic.auto.create"},{"location":"server-properties/#ksqlloggingprocessingrowsinclude","text":"","title":"ksql.logging.processing.rows.include <p>ProcessingLogConfig</p>"},{"location":"api/Endpoints/","text":"<p><code>Endpoints</code> is an abstraction of API endpoints.</p>","title":"Endpoints"},{"location":"api/Endpoints/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"api/Endpoints/#executing-ksqlrequest","text":"","title":"Executing KsqlRequest <pre><code>CompletableFuture&lt;EndpointResponse&gt; executeKsqlRequest(\n  KsqlRequest request,\n  WorkerExecutor workerExecutor,\n  ApiSecurityContext apiSecurityContext)\n</code></pre> <p>See KsqlServerEndpoints</p> <p>Used when:</p> <ul> <li><code>ServerVerticle</code> is requested to handle a KsqlRequest</li> </ul>"},{"location":"api/Endpoints/#implementations","text":"<ul> <li>KsqlServerEndpoints</li> </ul>","title":"Implementations"},{"location":"api/Server/","text":"<p><code>Server</code> is a ksqlDB API server that deploys ServerVerticles (on the Vertx actor system).</p>","title":"Server"},{"location":"api/Server/#creating-instance","text":"<p><code>Server</code> takes the following to be created:</p> <ul> <li> <code>Vertx</code> (Vert.x) <li> KsqlRestConfig <li> Endpoints <li> <code>KsqlSecurityExtension</code> <li> <code>AuthenticationPlugin</code> <li> <code>ServerState</code> <li> <code>PullQueryExecutorMetrics</code>  <p><code>Server</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to startAsync</li> </ul>","title":"Creating Instance"},{"location":"api/Server/#starting-api-server","text":"","title":"Starting API Server <pre><code>void start()\n</code></pre> <p><code>start</code>...FIXME</p> <p><code>start</code> takes ksql.verticle.instances configuration property (from the KsqlRestConfig).</p> <p><code>start</code> prints out the following DEBUG message to the logs:</p> <pre><code>Deploying [instances] instances of server verticle\n</code></pre> <p><code>start</code> creates and deploys a ServerVerticle for every listener URI and ksql.verticle.instances configured.</p>  <p><code>start</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to startAsync</li> <li><code>Server</code> is requested to restart</li> </ul>"},{"location":"api/Server/#restarting-api-server","text":"","title":"Restarting API Server <pre><code>void restart()\n</code></pre> <p><code>restart</code> prints out the following INFO message to the logs:</p> <pre><code>Restarting server\n</code></pre> <p>In the end, <code>restart</code> stops and immediately starts the API server.</p> <p><code>restart</code> is used when:</p> <ul> <li><code>Server</code> is requested to configureTlsCertReload</li> </ul>"},{"location":"api/Server/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.api.server.Server</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.api.server.Server=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"api/ServerVerticle/","text":"<p><code>ServerVerticle</code> is a <code>Verticle</code> (Vert.x).</p>  <p>A verticle is a piece of code that can be deployed by Vert.x (...) to provide an actor-like deployment and concurrency model, out of the box.</p>","title":"ServerVerticle"},{"location":"api/ServerVerticle/#creating-instance","text":"<p><code>ServerVerticle</code> takes the following to be created:</p> <ul> <li> Endpoints <li> <code>HttpServerOptions</code> (Vert.x) <li> Server <li> <code>isInternalListener</code> flag <li> <code>PullQueryExecutorMetrics</code> <li> <code>LoggingRateLimiter</code>  <p><code>ServerVerticle</code> is created when:</p> <ul> <li><code>Server</code> is requested to start</li> </ul>","title":"Creating Instance"},{"location":"api/ServerVerticle/#starting-verticle","text":"","title":"Starting Verticle <pre><code>void start(\n  Promise&lt;Void&gt; startPromise)\n</code></pre> <p><code>start</code> is part of the <code>Verticle</code> (Vert.x) abstraction.</p>  <p><code>start</code> creates a ConnectionQueryManager.</p> <p><code>start</code> creates an <code>HttpServer</code> (Vert.x) (with the HttpServerOptions) and registers the request handlers.</p>"},{"location":"api/ServerVerticle/#uris","text":"","title":"URIs <pre><code>Router setupRouter()\n</code></pre> <p><code>setupRouter</code> registers the query handlers.</p>    URI HTTP Method Handler     <code>/</code> <code>GET</code> <code>ServerVerticle::handleInfoRedirect</code>   <code>/close-query</code> <code>POST</code> <code>CloseQueryHandler</code>   <code>/clusterStatus</code> <code>GET</code> <code>this::handleClusterStatusRequest</code>   <code>/healthcheck</code> <code>GET</code> <code>this::handleHealthcheckRequest</code>   <code>/heartbeat</code> <code>POST</code> <code>this::handleHeartbeatRequest</code>   <code>/info</code> <code>GET</code> handleInfoRequest   <code>/inserts-stream</code> <code>POST</code> <code>InsertsStreamHandler</code>   <code>/is_valid_property/:property</code> <code>GET</code> <code>this::handleIsValidPropertyRequest</code>   <code>/ksql</code> <code>POST</code> handleKsqlRequest   <code>/ksql/terminate</code> <code>POST</code> <code>this::handleTerminateRequest</code>   <code>/lag</code> <code>POST</code> <code>this::handleLagReportRequest</code>   <code>/query</code> <code>POST</code> <code>this::handleQueryRequest</code>   <code>/query-stream</code> <code>POST</code> <code>QueryStreamHandler</code>   <code>/status/:type/:entity/:action</code> <code>GET</code> <code>this::handleStatusRequest</code>   <code>/status</code> <code>GET</code> handleAllStatusesRequest   <code>/v1/metadata</code> <code>GET</code> <code>this::handleServerMetadataRequest</code>   <code>/v1/metadata/id</code> <code>GET</code> <code>this::handleServerMetadataClusterIdRequest</code>   <code>/ws/query</code> <code>GET</code> <code>this::handleWebsocket</code>"},{"location":"api/ServerVerticle/#handleallstatusesrequest","text":"","title":"handleAllStatusesRequest <pre><code>void handleAllStatusesRequest(\n  RoutingContext routingContext)\n</code></pre> <p><code>handleAllStatusesRequest</code> requests the Endpoints to executeAllStatuses.</p> <pre><code>$ http http://localhost:8088/status\nHTTP/1.1 200 OK\ncontent-length: 69\ncontent-type: application/json\n\n{\n    \"commandStatuses\": {\n        \"stream/`KSQL_PROCESSING_LOG`/create\": \"SUCCESS\"\n    }\n}\n</code></pre>"},{"location":"api/ServerVerticle/#handleinforequest","text":"","title":"handleInfoRequest <pre><code>void handleInfoRequest(\n  RoutingContext routingContext)\n</code></pre> <p><code>handleInfoRequest</code> requests the Endpoints to executeInfo.</p> <pre><code>$ http http://localhost:8088/info\nHTTP/1.1 200 OK\ncontent-length: 133\ncontent-type: application/json\n\n{\n    \"KsqlServerInfo\": {\n        \"kafkaClusterId\": \"kI5f7xZWQaynAgoptiVXJw\",\n        \"ksqlServiceId\": \"default_\",\n        \"serverStatus\": \"RUNNING\",\n        \"version\": \"0.27.2\"\n    }\n}\n</code></pre>"},{"location":"api/ServerVerticle/#handleksqlrequest","text":"","title":"handleKsqlRequest <pre><code>void handleKsqlRequest(\n  RoutingContext routingContext)\n</code></pre> <p><code>handleKsqlRequest</code> requests the Endpoints to execute the KsqlRequest.</p> <pre><code>$ http http://localhost:8088/ksql ksql=\"LIST STREAMS;\"\nHTTP/1.1 200 OK\ncontent-length: 224\ncontent-type: application/json\n\n[\n    {\n        \"@type\": \"streams\",\n        \"statementText\": \"LIST STREAMS;\",\n        \"streams\": [\n            {\n                \"isWindowed\": false,\n                \"keyFormat\": \"KAFKA\",\n                \"name\": \"KSQL_PROCESSING_LOG\",\n                \"topic\": \"default_ksql_processing_log\",\n                \"type\": \"STREAM\",\n                \"valueFormat\": \"JSON\"\n            }\n        ],\n        \"warnings\": []\n    }\n]\n</code></pre>"},{"location":"cli/","text":"<p><code>ksql</code> uses Ksql to post ksql statements (over HTTP 2.0) to a ksqlDB API server cluster for execution (on KsqlEngine).</p> <p><code>ksql</code> is a REST client that communicates with the REST URIs.</p> <pre><code>$ ./bin/ksql --help\nNAME\n        ksql - KSQL CLI\n\nSYNOPSIS\n        ksql [ --config-file &lt;configFile&gt; ]\n                [ --confluent-api-key &lt;ccloudApiKey&gt; ]\n                [ --confluent-api-secret &lt;ccloudApiSecret&gt; ]\n                [ {--define | -d} &lt;definedVars&gt;... ]\n                [ {--execute | -e} &lt;execute&gt; ] [ {--file | -f} &lt;scriptFile&gt; ]\n                [ {-h | --help} ] [ --output &lt;outputFormat&gt; ]\n                [ {--password | -p} &lt;password&gt; ]\n                [ --query-row-limit &lt;streamedQueryRowLimit&gt; ]\n                [ --query-timeout &lt;streamedQueryTimeoutMs&gt; ]\n                [ {--user | -u} &lt;userName&gt; ] [--] [ &lt;server&gt; ]\n...\n</code></pre> <p><code>ksql</code> supports executing ksql statements using <code>execute</code> and <code>file</code> options or interactively.</p> <pre><code>        --execute &lt;execute&gt;, -e &lt;execute&gt;\n            Execute one or more SQL statements and quit.\n\n        --file &lt;scriptFile&gt;, -f &lt;scriptFile&gt;\n            Execute commands from a file and exit.\n</code></pre> <p><code>ksql</code> accepts the address of the ksqldb server to connect to or assumes <code>http://localhost:8088</code>.</p> <pre><code>$ ./bin/ksql\n\n                  ===========================================\n                  =       _              _ ____  ____       =\n                  =      | | _____  __ _| |  _ \\| __ )      =\n                  =      | |/ / __|/ _` | | | | |  _ \\      =\n                  =      |   &lt;\\__ \\ (_| | | |_| | |_) |     =\n                  =      |_|\\_\\___/\\__, |_|____/|____/      =\n                  =                   |_|                   =\n                  =        The Database purpose-built       =\n                  =        for stream processing apps       =\n                  ===========================================\n\nCopyright 2017-2022 Confluent Inc.\n\nCLI v0.27.2, Server v0.27.2 located at http://localhost:8088\nServer Status: RUNNING\n\nHaving trouble? Type 'help' (case-insensitive) for a rundown of how things work!\n\nksql&gt;\n</code></pre> <pre><code>ksql&gt; help\n\nDescription:\n    The KSQL CLI provides a terminal-based interactive shell for running queries. Each command should be on a separate line. For KSQL command syntax, see the documentation at https://docs.ksqldb.io/en/latest/developer-guide/syntax-reference/\n...\n\nksql&gt; version\nVersion: 0.27.2\n\nksql&gt; server\nhttp://localhost:8088\n\nksql&gt; output\nCurrent output format: TABULAR\n\nksql&gt; exit\nExiting ksqlDB.\n</code></pre>","title":"ksql CLI"},{"location":"cli/Cli/","text":"","title":"Cli"},{"location":"cli/Cli/#creating-instance","text":"<p><code>Cli</code> takes the following to be created:</p> <ul> <li> streamedQueryRowLimit (based on <code>query-row-limit</code> option) <li> streamedQueryTimeoutMs (based on <code>query-timeout</code> option) <li> KsqlRestClient <li> <code>Console</code>  <p><code>Cli</code> is created using build utility.</p>","title":"Creating Instance"},{"location":"cli/Cli/#building-cli-instance","text":"","title":"Building Cli Instance <pre><code>Cli build(\n  Long streamedQueryRowLimit,\n  Long streamedQueryTimeoutMs,\n  OutputFormat outputFormat,\n  KsqlRestClient restClient\n)\n</code></pre> <p><code>build</code> builds a <code>Console</code> (for the <code>OutputFormat</code>) to create a Cli.</p>  <p><code>build</code> is used when:</p> <ul> <li><code>Ksql</code> is requested to run</li> </ul>"},{"location":"cli/Cli/#runcommand","text":"","title":"runCommand <pre><code>void runCommand(\n  String command)\n</code></pre> <p><code>runCommand</code> handleLine.</p> <p><code>runCommand</code> is used when:</p> <ul> <li><code>Ksql</code> is requested to run</li> </ul>"},{"location":"cli/Cli/#runinteractively","text":"","title":"runInteractively <pre><code>void runInteractively()\n</code></pre> <p><code>runInteractively</code> displayWelcomeMessage.</p> <p><code>runInteractively</code> validates the KsqlRestClient.</p> <p><code>runInteractively</code> handleLine until stopped (by a user).</p>  <p><code>runInteractively</code> is used when:</p> <ul> <li><code>Ksql</code> is requested to run</li> </ul>"},{"location":"cli/Cli/#handleline","text":"","title":"handleLine <pre><code>void handleLine(\n  String line)\n</code></pre> <p><code>handleLine</code> removes any leading and trailing spaces from the given <code>line</code> and handleStatements.</p> <p><code>handleLine</code> simply returns back when the given <code>line</code> is empty after trimming.</p>  <p><code>handleLine</code> is used when:</p> <ul> <li><code>Cli</code> is requested to runScript, runCommand, runInteractively</li> </ul>"},{"location":"cli/Cli/#handlestatements","text":"","title":"handleStatements <pre><code>void handleStatements(\n  String line)\n</code></pre> <p><code>handleStatements</code> requests the DefaultKsqlParser to parse the given line (into <code>ParsedStatement</code>s).</p>  <p>Note</p> <p>There could be one or more <code>ParsedStatement</code>s in the given <code>line</code>.</p>  <p>For every <code>ParsedStatement</code>, <code>handleStatements</code> substituteVariables and...FIXME</p> <p><code>handleStatements</code> validates the statements.</p> <p><code>handleStatements</code> executes the statements:</p> <ol> <li>substituteVariables (with <code>isSandbox</code> flag disabled)</li> <li>Looks up the handler (in the STATEMENT_HANDLERS) to handle the statement<ul> <li>makeKsqlRequest (if found) followed by requesting the handler to handle it</li> <li>makeKsqlRequest only, otherwise</li> </ul> </li> </ol>"},{"location":"cli/Cli/#substitutevariables","text":"","title":"substituteVariables <pre><code>ParsedStatement substituteVariables(\n  ParsedStatement statement)\n</code></pre> <p><code>substituteVariables</code>...FIXME</p>"},{"location":"cli/Cli/#isvariablesubstitutionenabled","text":"","title":"isVariableSubstitutionEnabled <pre><code>boolean isVariableSubstitutionEnabled()\n</code></pre> <p><code>isVariableSubstitutionEnabled</code>...FIXME</p>"},{"location":"cli/Cli/#makeksqlrequest","text":"","title":"makeKsqlRequest <pre><code>void makeKsqlRequest(\n  String statements)\n</code></pre> <p><code>makeKsqlRequest</code> is part of the <code>KsqlRequestExecutor</code> abstraction.</p>  <p><code>makeKsqlRequest</code> makes a ksql request with the statements (and the KsqlRestClient) and printKsqlResponse to the console.</p>"},{"location":"cli/Cli/#makeksqlrequest-private","text":"","title":"makeKsqlRequest (private) <pre><code>RestResponse&lt;R&gt; makeKsqlRequest(\n  final String ksql,\n  final BiFunction&lt;String, Long, RestResponse&lt;R&gt;&gt; requestIssuer)\n</code></pre> <p><code>makeKsqlRequest</code> executes the <code>requestIssuer</code> binary function (that uses the KsqlRestClient) with the given <code>ksql</code> (and <code>commandSequenceNumberToWaitFor</code> if configured).</p> <p><code>makeKsqlRequest</code> retires execution of failed statements 10 times.</p>  <p><code>makeKsqlRequest</code> is used when:</p> <ul> <li><code>Cli</code> is requested to makeKsqlRequest, handleConnectorRequest, handleQuery, handlePrintedTopic</li> </ul>"},{"location":"cli/Ksql/","text":"<p><code>Ksql</code> is a standalone command-line application (that is executed using ksql shell script).</p>","title":"Ksql"},{"location":"cli/Ksql/#launching-application","text":"","title":"Launching Application <p><code>main</code> parses command-line options.</p> <p>In the end, <code>main</code> creates a Ksql (with the options, the system properties, a KsqlRestClient and a Cli) and runs it.</p>"},{"location":"cli/Ksql/#creating-instance","text":"","title":"Creating Instance <p><code>Ksql</code> takes the following to be created:</p> <ul> <li> <code>Options</code> <li> System Properties <li> KsqlClientBuilder <li> Cli builder  <p><code>Ksql</code> is created when:</p> <ul> <li><code>Ksql</code> application is launched</li> </ul>"},{"location":"cli/Ksql/#executing-statements","text":"","title":"Executing Statements <pre><code>int run()\n</code></pre> <p><code>run</code> loads a config file (if defined).</p> <p><code>run</code> builds a KsqlRestClient.</p> <p><code>run</code> uses the following options to build a Cli (using the cliBuilder and the KsqlRestClient):</p> <ul> <li><code>streamedQueryRowLimit</code></li> <li><code>streamedQueryTimeoutMs</code></li> <li><code>outputFormat</code> (<code>JSON</code> or <code>TABULAR</code>)</li> </ul> <p><code>run</code> requests the <code>Cli</code> to add the session variables (based on <code>definedVars</code> option).</p> <p><code>run</code> branches off based on the options:</p> <ul> <li>With <code>execute</code>, <code>run</code> requests the <code>Cli</code> to run the command</li> <li>With <code>file</code>, <code>run</code> requests the <code>Cli</code> to run the script file</li> <li>Otherwise, <code>run</code> requests the <code>Cli</code> to run interactively</li> </ul>"},{"location":"cli/Ksql/#building-rest-client","text":"","title":"Building REST Client <pre><code>KsqlRestClient buildClient(\n  Map&lt;String, String&gt; configProps\n)\n</code></pre> <p><code>buildClient</code> uses the following options to build a KsqlRestClient (using the KsqlClientBuilder):</p> <ul> <li><code>server</code></li> <li><code>user</code> and <code>password</code> for authentication (if needed)</li> <li><code>confluent-api-key</code> and <code>confluent-api-secret</code> (for Confluent Cloud ksqlDB server if needed)</li> </ul>"},{"location":"cli/KsqlClient/","text":"<p><code>KsqlClient</code> is...FIXME</p>","title":"KsqlClient"},{"location":"cli/KsqlRestClient/","text":"<p><code>KsqlRestClient</code> uses Vert.x to talk HTTP 2.0 to the ksqlDB server.</p>","title":"KsqlRestClient"},{"location":"cli/KsqlRestClient/#creating-instance","text":"<p><code>KsqlRestClient</code> takes the following to be created:</p> <ul> <li> KsqlClient <li> Address of the ksqlDB server <li> Local properties <li> ccloudApiKey  <p><code>KsqlRestClient</code> is created using create utility.</p>","title":"Creating Instance"},{"location":"cli/KsqlRestClient/#create","text":"","title":"create <pre><code>KsqlRestClient create(\n  String serverAddress,\n  Map&lt;String, ?&gt; localProps,\n  Map&lt;String, String&gt; clientProps,\n  Optional&lt;BasicCredentials&gt; creds,\n  Optional&lt;BasicCredentials&gt; ccloudApiKey,\n  KsqlClientSupplier clientSupplier\n)\nKsqlRestClient create(\n  String serverAddress,\n  Map&lt;String, ?&gt; localProps,\n  Map&lt;String, String&gt; clientProps,\n  Optional&lt;BasicCredentials&gt; creds,\n  Optional&lt;BasicCredentials&gt; ccloudApiKey\n) // (1)!\n</code></pre> <ol> <li>Creates a new KsqlClient using <code>KsqlClientSupplier</code></li> </ol> <p><code>create</code> creates a KsqlClient (using the <code>KsqlClientSupplier</code>) to create a KsqlRestClient.</p>  <p><code>create</code> is used when:</p> <ul> <li><code>Ksql</code> application is launched</li> </ul>"},{"location":"cli/KsqlRestClient/#makeksqlrequest","text":"","title":"makeKsqlRequest <pre><code>RestResponse&lt;KsqlEntityList&gt; makeKsqlRequest(\n  String ksql) // (1)!\nRestResponse&lt;KsqlEntityList&gt; makeKsqlRequest(\n  String ksql, \n  Long commandSeqNum)\n</code></pre> <ol> <li>Uses no <code>commandSeqNum</code></li> </ol> <p><code>makeKsqlRequest</code> posts the ksql statement to the target.</p>  <p><code>makeKsqlRequest</code> is used when:</p> <ul> <li><code>Cli</code> is requested to makeKsqlRequest</li> </ul>"},{"location":"demo/pull-queries/","text":"<p>This demo shows a pull query in action.</p>","title":"Demo: Pull Queries"},{"location":"demo/pull-queries/#create-stream-riderlocations","text":"<p>Use ksql to execute the following CREATE STREAM DDL statement.</p> <pre><code>CREATE STREAM riderLocations (\n    profileId VARCHAR,\n    latitude DOUBLE,\n    longitude DOUBLE)\n  WITH (\n    kafka_topic='locations',\n    value_format='json',\n    partitions=1);\n</code></pre>","title":"CREATE STREAM riderLocations"},{"location":"demo/pull-queries/#produce-json-record","text":"<pre><code>echo '{\"profileId\":0, \"latitude\":10.5, \"longitude\": 20.1}' | kcat -P -b :9092 -t locations\n</code></pre>","title":"Produce JSON Record"},{"location":"demo/pull-queries/#execute-pull-query","text":"<p>Issue a pull query.</p> <pre><code>ksql&gt; SELECT * FROM riderLocations;\n+------------------------------------------------+------------------------------------------------+------------------------------------------------+\n|PROFILEID                                       |LATITUDE                                        |LONGITUDE                                       |\n+------------------------------------------------+------------------------------------------------+------------------------------------------------+\n|0                                               |10.5                                            |20.1                                            |\nQuery Completed\nQuery terminated\n</code></pre>","title":"Execute Pull Query"},{"location":"demo/pull-queries/#explain-query","text":"<pre><code>ksql&gt; EXPLAIN SELECT * FROM riderLocations;\n\nID                   : transient_RIDERLOCATIONS_5838976163364029274\nQuery Type           : PUSH\nSQL                  : SELECT * FROM riderLocations;\n\n Field     | Type\n-----------------------------\n PROFILEID | VARCHAR(STRING)\n LATITUDE  | DOUBLE\n LONGITUDE | DOUBLE\n-----------------------------\n\nSources that this query reads from:\n-----------------------------------\nRIDERLOCATIONS\n\nFor source description please run: DESCRIBE [EXTENDED] &lt;SourceId&gt;\n\nExecution plan\n--------------\n &gt; [ PROJECT ] | Schema: PROFILEID STRING, LATITUDE DOUBLE, LONGITUDE DOUBLE | Logger: transient_RIDERLOCATIONS_5838976163364029274.Project\n   &gt; [ SOURCE ] | Schema: PROFILEID STRING, LATITUDE DOUBLE, LONGITUDE DOUBLE, ROWTIME BIGINT, ROWPARTITION INTEGER, ROWOFFSET BIGINT | Logger: transient_RIDERLOCATIONS_5838976163364029274.KsqlTopic.Source\n\n\nProcessing topology\n-------------------\nTopologies:\n   Sub-topology: 0\n    Source: KSTREAM-SOURCE-0000000000 (topics: [locations])\n      --&gt; KSTREAM-TRANSFORMVALUES-0000000001\n    Processor: KSTREAM-TRANSFORMVALUES-0000000001 (stores: [])\n      --&gt; Project\n      &lt;-- KSTREAM-SOURCE-0000000000\n    Processor: Project (stores: [])\n      --&gt; KSTREAM-PROCESSOR-0000000003\n      &lt;-- KSTREAM-TRANSFORMVALUES-0000000001\n    Processor: KSTREAM-PROCESSOR-0000000003 (stores: [])\n      --&gt; none\n      &lt;-- Project\n</code></pre>","title":"Explain Query"},{"location":"demo/pull-queries/#describe-stream","text":"<pre><code>ksql&gt; DESCRIBE riderlocations;\n\nName                 : RIDERLOCATIONS\n Field     | Type\n-----------------------------\n PROFILEID | VARCHAR(STRING)\n LATITUDE  | DOUBLE\n LONGITUDE | DOUBLE\n-----------------------------\nFor runtime statistics and query details run: DESCRIBE &lt;Stream,Table&gt; EXTENDED;\n</code></pre> <pre><code>ksql&gt; DESCRIBE riderlocations EXTENDED;\n\nName                 : RIDERLOCATIONS\nType                 : STREAM\nTimestamp field      : Not set - using &lt;ROWTIME&gt;\nKey format           : KAFKA\nValue format         : JSON\nKafka topic          : locations (partitions: 1, replication: 1)\nStatement            : CREATE STREAM RIDERLOCATIONS (PROFILEID STRING, LATITUDE DOUBLE, LONGITUDE DOUBLE) WITH (KAFKA_TOPIC='locations', KEY_FORMAT='KAFKA', PARTITIONS=1, VALUE_FORMAT='JSON');\n\n Field     | Type\n-----------------------------\n PROFILEID | VARCHAR(STRING)\n LATITUDE  | DOUBLE\n LONGITUDE | DOUBLE\n-----------------------------\n\nLocal runtime statistics\n------------------------\n\n\n(Statistics of the local KSQL server interaction with the Kafka topic locations)\n</code></pre>","title":"Describe Stream"},{"location":"demo/pull-queries/#disable-stream-pull-queries","text":"<p>The above steps worked just fine because pull queries on streams are enabled by default (based on ksql.query.pull.stream.enabled).</p> <p>Let's turn it off and see the result. In the <code>ksql</code> CLI execute the following command:</p> <pre><code>SET 'ksql.query.pull.stream.enabled' = 'false';\n</code></pre> <p>This time executing the following query will inevitably lead to an exception.</p> KSQL   <pre><code>SELECT * FROM riderLocations;\n</code></pre>    <pre><code>Pull queries on streams are disabled. To create a push query on the stream, add EMIT CHANGES to the end. To enable pull queries on streams, set the ksql.query.pull.stream.enabled config to 'true'.\nStatement: SELECT * FROM riderLocations;: SELECT * FROM riderLocations;\n</code></pre>","title":"Disable Stream Pull Queries"},{"location":"demo/show-streams/","text":"<p><code>SHOW STREAMS</code> (<code>LIST STREAMS</code>) is a metadata query.</p> <p>This demo shows the way of <code>SHOW STREAMS</code> query from ksql CLI, through ksqlDB API server, executing it on KsqlEngine and returning a response back.</p> <pre><code>ksql&gt; SHOW STREAMS;\n\n Stream Name         | Kafka Topic                 | Key Format | Value Format | Windowed\n------------------------------------------------------------------------------------------\n KSQL_PROCESSING_LOG | default_ksql_processing_log | KAFKA      | JSON         | false\n------------------------------------------------------------------------------------------\n</code></pre> <p><code>SHOW STREAMS</code> is parsed using AstBuilder.Visitor into a ListStreams that is in turn executed using ListSourceExecutor.</p>","title":"Demo: SHOW STREAMS"},{"location":"demo/show-streams/#create-new-stream","text":"<pre><code>CREATE STREAM demo_list_streams\n(\n    id BIGINT,\n    name STRING\n)\nWITH\n(\n    kafka_topic='demo_list_streams',\n    value_format='JSON',\n    partitions=1\n);\n</code></pre> <pre><code>ksql&gt; SHOW STREAMS;\n\n Stream Name         | Kafka Topic                 | Key Format | Value Format | Windowed\n------------------------------------------------------------------------------------------\n DEMO_LIST_STREAMS   | demo_list_streams           | KAFKA      | JSON         | false\n KSQL_PROCESSING_LOG | default_ksql_processing_log | KAFKA      | JSON         | false\n------------------------------------------------------------------------------------------\n</code></pre> <pre><code>ksql&gt; SELECT * FROM demo_list_streams;\n+-------------------------------------------------------------------------+-------------------------------------------------------------------------+\n|ID                                                                       |NAME                                                                     |\n+-------------------------------------------------------------------------+-------------------------------------------------------------------------+\nQuery Completed\nQuery terminated\n</code></pre> <pre><code>echo '0:{\"id\":0, \"name\": \"Demo\"}' | kcat -P -b :9092 -t demo_list_streams -K :\n</code></pre> <pre><code>ksql&gt; SELECT * FROM demo_list_streams;\n+-------------------------------------------------------------------------+-------------------------------------------------------------------------+\n|ID                                                                       |NAME                                                                     |\n+-------------------------------------------------------------------------+-------------------------------------------------------------------------+\n|0                                                                        |Demo                                                                     |\nQuery Completed\nQuery terminated\n</code></pre> <pre><code>ksql&gt; EXPLAIN SELECT * FROM demo_list_streams;\n\nID                   : transient_DEMO_LIST_STREAMS_2530336553886215962\nQuery Type           : PUSH\nSQL                  : SELECT * FROM demo_list_streams;\n\n Field | Type\n-------------------------\n ID    | BIGINT\n NAME  | VARCHAR(STRING)\n-------------------------\n\nSources that this query reads from:\n-----------------------------------\nDEMO_LIST_STREAMS\n\nFor source description please run: DESCRIBE [EXTENDED] &lt;SourceId&gt;\n\nExecution plan\n--------------\n &gt; [ PROJECT ] | Schema: ID BIGINT, NAME STRING | Logger: transient_DEMO_LIST_STREAMS_2530336553886215962.Project\n   &gt; [ SOURCE ] | Schema: ID BIGINT, NAME STRING, ROWTIME BIGINT, ROWPARTITION INTEGER, ROWOFFSET BIGINT | Logger: transient_DEMO_LIST_STREAMS_2530336553886215962.KsqlTopic.Source\n\n\nProcessing topology\n-------------------\nTopologies:\n   Sub-topology: 0\n    Source: KSTREAM-SOURCE-0000000000 (topics: [demo_list_streams])\n      --&gt; KSTREAM-TRANSFORMVALUES-0000000001\n    Processor: KSTREAM-TRANSFORMVALUES-0000000001 (stores: [])\n      --&gt; Project\n      &lt;-- KSTREAM-SOURCE-0000000000\n    Processor: Project (stores: [])\n      --&gt; KSTREAM-PROCESSOR-0000000003\n      &lt;-- KSTREAM-TRANSFORMVALUES-0000000001\n    Processor: KSTREAM-PROCESSOR-0000000003 (stores: [])\n      --&gt; none\n      &lt;-- Project\n</code></pre>","title":"Create New Stream"},{"location":"demo/show-streams/#clean-up","text":"<pre><code>ksql&gt; DROP STREAM demo_list_streams DELETE TOPIC;\n\n Message\n--------------------------------------------------------------------\n Source `DEMO_LIST_STREAMS` (topic: demo_list_streams) was dropped.\n--------------------------------------------------------------------\n</code></pre>","title":"Clean Up"},{"location":"embedded/EmbeddedKsql/","text":"<p><code>EmbeddedKsql</code> is a standalone (command-line) application.</p>","title":"EmbeddedKsql"},{"location":"embedded/KsqlContext/","text":"","title":"KsqlContext"},{"location":"embedded/KsqlContext/#demo","text":"<pre><code>import io.confluent.ksql.util.KsqlConfig\nimport scala.jdk.CollectionConverters._\nval props = Map(\"bootstrap.servers\" -&gt; \":9092\").asJava\nval ksqlConfig = new KsqlConfig(props)\n\nimport io.confluent.ksql.logging.processing.ProcessingLogContext\nval processingLogContext = ProcessingLogContext.create()\n\nimport io.confluent.ksql.metrics.MetricCollectors\nval metricCollectors = new MetricCollectors()\n\nimport io.confluent.ksql.embedded.KsqlContext\nval ksqlContext = KsqlContext.create(\n  ksqlConfig,\n  processingLogContext,\n  metricCollectors)\n</code></pre>","title":"Demo"},{"location":"embedded/KsqlContext/#creating-instance","text":"<p><code>KsqlContext</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlConfig <li> KsqlEngine <li> Injector Factory (<code>BiFunction&lt;KsqlExecutionContext, ServiceContext, Injector&gt;</code>)  <p><code>KsqlContext</code> is created using create utility.</p>","title":"Creating Instance"},{"location":"embedded/KsqlContext/#creating-ksqlcontext","text":"","title":"Creating KsqlContext <pre><code>KsqlContext create(\n  KsqlConfig ksqlConfig,\n  ProcessingLogContext processingLogContext)\n</code></pre> <p><code>create</code>...FIXME</p>"},{"location":"embedded/KsqlContext/#executing-sql-text","text":"","title":"Executing SQL Text <pre><code>List&lt;QueryMetadata&gt; sql(\n  String sql)\nList&lt;QueryMetadata&gt; sql(\n  String sql,\n  Map&lt;String, ?&gt; overriddenProperties)\n</code></pre> <p><code>sql</code>...FIXME</p>"},{"location":"embedded/KsqlContext/#executing-statement","text":"","title":"Executing Statement <pre><code>ExecuteResult execute(\n  KsqlExecutionContext executionContext,\n  ParsedStatement stmt,\n  KsqlConfig ksqlConfig,\n  Map&lt;String, Object&gt; mutableSessionPropertyOverrides,\n  Injector injector)\n</code></pre> <p><code>execute</code>...FIXME</p>"},{"location":"parser/","text":"<p>ksqlDB uses AstBuilder to parse and build Statement tree nodes from SQL text (possibly with multiple SQL statements separated by <code>;</code>).</p> <p>ksqlDB uses DefaultKsqlParser to prepare a statement for execution.</p> <p><code>EngineContext</code> is used for Variable Substitution and sanitize while preparing a statement for execution.</p>","title":"Query Parsing"},{"location":"parser/AlterSystemProperty/","text":"<p><code>AlterSystemProperty</code> is a Statement for ALTER SYSTEM statements.</p>","title":"AlterSystemProperty"},{"location":"parser/AlterSystemProperty/#creating-instance","text":"<p><code>AlterSystemProperty</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> Property Name <li> Property Value  <p><code>AlterSystemProperty</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to visitAlterSystemProperty</li> </ul>","title":"Creating Instance"},{"location":"parser/AstBuilder/","text":"<p><code>AstBuilder</code> uses Visitor to parse SQL statements (using ANTLR).</p>","title":"AstBuilder"},{"location":"parser/AstBuilder/#creating-instance","text":"<p><code>AstBuilder</code> takes the following to be created:</p> <ul> <li> TypeRegistry  <p><code>AstBuilder</code> is created when:</p> <ul> <li><code>QueryAnonymizer.Visitor</code> is requested to <code>visitExpression</code></li> <li><code>DefaultKsqlParser</code> is requested to prepare</li> <li><code>ExpressionParser</code> is requested to <code>parseSelectExpression</code>, <code>parseExpression</code>, <code>parseWindowExpression</code></li> </ul>","title":"Creating Instance"},{"location":"parser/AstBuilder/#building-statement","text":"","title":"Building Statement <pre><code>Statement buildStatement(\n  ParserRuleContext parseTree)\n</code></pre> <p><code>buildStatement</code> collects the source names (in a SQL statement) and builds a Statement.</p>  <p><code>buildStatement</code> is used when:</p> <ul> <li><code>DefaultKsqlParser</code> is requested to prepare a ParsedStatement</li> </ul>"},{"location":"parser/AstBuilder/#collecting-source-names","text":"","title":"Collecting Source Names <pre><code>Set&lt;SourceName&gt; getSources(\n  ParseTree parseTree)\n</code></pre> <p><code>getSources</code> creates a SourceAccumulator to visit (the nodes of) the given <code>ParseTree</code>. In the end, <code>getSources</code> requests the <code>SourceAccumulator</code> for the sources.</p>"},{"location":"parser/AstBuilder/#building-parsed-tree-build","text":"","title":"Building Parsed Tree (build) <pre><code>&lt;T extends Node&gt; T build(\n  Optional&lt;Set&lt;SourceName&gt;&gt; sources, // (1)!\n  ParserRuleContext parseTree)\n</code></pre> <ol> <li>Only given when <code>AstBuilder</code> is requested to build a Statement</li> </ol> <p><code>build</code> creates a Visitor to build a node tree (for a given <code>ParserRuleContext</code> that represents a parsed SQL text).</p>  <p><code>build</code> is used when:</p> <ul> <li><code>AstBuilder</code> is requested to build a Statement, an Expression, a WindowExpression and an AssertStatement</li> </ul>"},{"location":"parser/AstBuilder_Visitor/","text":"<p><code>Visitor</code> is a <code>SqlBaseBaseVisitor</code> to build a Node tree (that <code>AstBuilder</code> uses to build a parsed tree).</p>  <p>ANTLR</p> <p><code>SqlBaseBaseVisitor</code> is generated from SqlBase.g4 SQL grammar by ANTLR at build time.</p>","title":"AstBuilder.Visitor"},{"location":"parser/AstBuilder_Visitor/#creating-instance","text":"<p><code>Visitor</code> takes the following to be created:</p> <ul> <li> Source Names <li> <code>TypeRegistry</code>  <p><code>Visitor</code> is created when:</p> <ul> <li><code>AstBuilder</code> is requested to build a parsed tree</li> </ul>","title":"Creating Instance"},{"location":"parser/AstBuilder_Visitor/#parsing-statements","text":"","title":"Parsing Statements"},{"location":"parser/AstBuilder_Visitor/#alter-system","text":"","title":"ALTER SYSTEM <pre><code>Node visitAlterSystemProperty(\n  SqlBaseParser.AlterSystemPropertyContext context)\n</code></pre> <p><code>visitAlterSystemProperty</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>ALTER SYSTEM</code> statements.</p> <pre><code>ALTER SYSTEM name = value   #alterSystemProperty\n</code></pre> <p><code>visitAlterSystemProperty</code> creates an AlterSystemProperty.</p>  <p>Note</p> <p>\"Cannot alter system configs when KSQL_SHARED_RUNTIME_ENABLED is turned off\" exception is thrown by <code>ValidatedCommandFactory</code> is requested to createForAlterSystemQuery.</p>"},{"location":"parser/AstBuilder_Visitor/#assert-table","text":"","title":"ASSERT TABLE <pre><code>Node visitAssertTable(\n  AssertTableContext context)\n</code></pre> <p><code>visitAssertTable</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>ASSERT TABLE</code> statements:</p> <pre><code>ASSERT TABLE sourceName\n(tableElements)?\n(WITH tableProperties)?\n</code></pre> <p><code>visitAssertTable</code> creates an <code>AssertTable</code> with a CreateTable.</p>"},{"location":"parser/AstBuilder_Visitor/#create-stream","text":"","title":"CREATE STREAM <pre><code>Node visitCreateStream(\n  SqlBaseParser.CreateStreamContext context)\n</code></pre> <p><code>visitCreateStream</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE STREAM</code> statements.</p> <pre><code>CREATE (OR REPLACE)? (SOURCE)? STREAM (IF NOT EXISTS)? sourceName\n(tableElements)?\n(WITH tableProperties)?\n\ntableElements\n    : '(' tableElement (',' tableElement)* ')'\n    ;\n\ntableElement\n    : identifier type columnConstraints?\n    ;\n\ntype\n    : type ARRAY\n    | ARRAY '&lt;' type '&gt;'\n    | MAP '&lt;' type ',' type '&gt;'\n    | STRUCT '&lt;' (identifier type (',' identifier type)*)? '&gt;'\n    | DECIMAL '(' number ',' number ')'\n    | baseType ('(' typeParameter (',' typeParameter)* ')')?\n    ;\n\ncolumnConstraints\n    : ((PRIMARY)? KEY)\n    | HEADERS\n    | HEADER '(' text ')'\n    ;\n\ntableProperties\n    : '(' tableProperty (',' tableProperty)* ')'\n    ;\n</code></pre> <p><code>visitCreateStream</code> creates a CreateStream.</p>"},{"location":"parser/AstBuilder_Visitor/#create-stream-as","text":"","title":"CREATE STREAM AS <pre><code>Node visitCreateStreamAs(\n  SqlBaseParser.CreateStreamAsContext context)\n</code></pre> <p><code>visitCreateStreamAs</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE STREAM AS</code> (CSAS) statements.</p> <pre><code>CREATE (OR REPLACE)? STREAM (IF NOT EXISTS)? sourceName\n  (WITH tableProperties)? AS query\n</code></pre> <p><code>visitCreateStreamAs</code> creates a CreateStreamAsSelect.</p>"},{"location":"parser/AstBuilder_Visitor/#create-table","text":"","title":"CREATE TABLE <pre><code>Node visitCreateTable(\n  SqlBaseParser.CreateTableContext context)\n</code></pre> <p><code>visitCreateTable</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE TABLE</code> statements.</p> <pre><code>CREATE (OR REPLACE)? (SOURCE)? TABLE (IF NOT EXISTS)? sourceName\n(tableElements)?\n(WITH tableProperties)?\n\ntableElements\n    : '(' tableElement (',' tableElement)* ')'\n    ;\n\ntableElement\n    : identifier type columnConstraints?\n    ;\n\ncolumnConstraints\n    : ((PRIMARY)? KEY)\n    | HEADERS\n    | HEADER '(' STRING ')'\n    ;\n</code></pre> <p><code>visitCreateTable</code> creates a CreateTable.</p>"},{"location":"parser/AstBuilder_Visitor/#create-table-as","text":"","title":"CREATE TABLE AS <pre><code>Node visitCreateTableAs(\n  SqlBaseParser.CreateTableAsContext context)\n</code></pre> <p><code>visitCreateTableAs</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE TABLE AS</code> (CTAS) statements.</p> <pre><code>CREATE (OR REPLACE)? TABLE (IF NOT EXISTS)? sourceName\n  (WITH tableProperties)? AS query\n</code></pre> <p><code>visitCreateTableAs</code> creates a CreateTableAsSelect.</p>"},{"location":"parser/AstBuilder_Visitor/#explain","text":"","title":"EXPLAIN <pre><code>Node visitExplain(\n  SqlBaseParser.ExplainContext ctx)\n</code></pre> <p><code>visitExplain</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>EXPLAIN</code> statements.</p> <pre><code>EXPLAIN (statement | identifier)\n</code></pre> <p><code>visitExplain</code> creates an Explain.</p>"},{"location":"parser/AstBuilder_Visitor/#insert-into","text":"","title":"INSERT INTO <pre><code>Node visitInsertInto(\n  SqlBaseParser.InsertIntoContext context)\n</code></pre> <p><code>visitInsertInto</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>INSERT INTO</code> statements.</p> <pre><code>INSERT INTO sourceName (WITH tableProperties)? query\n</code></pre> <p><code>visitInsertInto</code> creates a InsertInto.</p>"},{"location":"parser/AstBuilder_Visitor/#list-streams","text":"","title":"LIST STREAMS <pre><code>Node visitListStreams(\n  SqlBaseParser.ListStreamsContext context)\n</code></pre> <p><code>visitListStreams</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>LIST STREAMS</code> statements.</p> <pre><code>(LIST | SHOW) STREAMS EXTENDED?\n</code></pre> <p><code>visitListStreams</code> creates a ListStreams.</p>"},{"location":"parser/AstBuilder_Visitor/#select","text":"","title":"SELECT <pre><code>Query visitQuery(\n  SqlBaseParser.QueryContext context)\n</code></pre> <p><code>visitQuery</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>SELECT</code> statements (queries).</p> <pre><code>query\n    : SELECT selectItem (',' selectItem)*\n      FROM from=relation\n      (WINDOW  windowExpression)?\n      (WHERE where=booleanExpression)?\n      (GROUP BY groupBy)?\n      (PARTITION BY partitionBy)?\n      (HAVING having=booleanExpression)?\n      (EMIT resultMaterialization)?\n      limitClause?\n    ;\n</code></pre> <p><code>visitQuery</code> creates a Query.</p>"},{"location":"parser/AstBuilder_Visitor/#buildingpersistentquery-flag","text":"","title":"buildingPersistentQuery Flag <p><code>Visitor</code> defines <code>buildingPersistentQuery</code> internal flag that is <code>false</code> when created.</p> <p><code>buildingPersistentQuery</code> flag is turned on (<code>true</code>) when withinPersistentQuery.</p>"},{"location":"parser/AstBuilder_Visitor/#withinpersistentquery","text":"","title":"withinPersistentQuery <pre><code>T withinPersistentQuery(\n  Supplier&lt;T&gt; task)\n</code></pre> <p><code>withinPersistentQuery</code>...FIXME</p> <p><code>withinPersistentQuery</code> is used when:</p> <ul> <li><code>Visitor</code> is requested to parse CreateStreamAs, CreateTableAs and InsertInto statements</li> </ul>"},{"location":"parser/AstNode/","text":"<p><code>AstNode</code> is an extension of the Node abstraction for AST nodes.</p>","title":"AstNode"},{"location":"parser/AstNode/#contract","text":"","title":"Contract"},{"location":"parser/AstNode/#accept","text":"","title":"accept <pre><code>R accept(\n  AstVisitor&lt;R, C&gt; visitor,\n  C context)\n</code></pre> <p>Used when:</p> <ul> <li><code>AstVisitor</code> is requested to process a node</li> </ul>"},{"location":"parser/AstNode/#implementations","text":"<ul> <li>AstNode</li> <li><code>AlterOption</code></li> <li><code>AssertStatement</code></li> <li><code>GroupBy</code></li> <li><code>PartitionBy</code></li> <li><code>Relation</code></li> <li><code>Select</code></li> <li><code>SelectItem</code></li> <li>Statement</li> <li><code>Statements</code></li> <li><code>TableElement</code></li> <li><code>WindowExpression</code></li> <li><code>WithinExpression</code></li> </ul>","title":"Implementations"},{"location":"parser/AstVisitor/","text":"<p><code>AstVisitor&lt;R, C&gt;</code> is an abstraction of AST visitors.</p>","title":"AstVisitor"},{"location":"parser/AstVisitor/#implementations","text":"<ul> <li>DefaultTraversalVisitor</li> <li>others</li> </ul>","title":"Implementations"},{"location":"parser/CommonCreateConfigs/","text":"","title":"CommonCreateConfigs"},{"location":"parser/CommonCreateConfigs/#format","text":"","title":"FORMAT"},{"location":"parser/CommonCreateConfigs/#kafka_topic","text":"","title":"KAFKA_TOPIC <p>The topic that stores the data of the source</p> <p>Default: (undefined)</p>"},{"location":"parser/CommonCreateConfigs/#key_delimiter_property","text":"","title":"KEY_DELIMITER_PROPERTY"},{"location":"parser/CommonCreateConfigs/#key_format_property","text":"","title":"KEY_FORMAT_PROPERTY"},{"location":"parser/CommonCreateConfigs/#key_schema_full_name","text":"","title":"KEY_SCHEMA_FULL_NAME"},{"location":"parser/CommonCreateConfigs/#key_schema_id","text":"","title":"KEY_SCHEMA_ID <p>Default: (undefined)</p> <p>Used when:</p> <ul> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateAsStatement</code>, <code>forCreateStatement</code>, <code>shouldInferSchema</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>stripSchemaIdConfig</code>, <code>registerForCreateSource</code>, <code>registerForCreateAs</code>, <code>sanityCheck</code>, <code>registerRawSchema</code></li> <li><code>CreateSourceAsProperties</code> is requested to getKeySchemaId</li> <li><code>CreateSourceProperties</code> is requested to getKeySchemaId</li> </ul>"},{"location":"parser/CommonCreateConfigs/#source_number_of_replicas","text":"","title":"SOURCE_NUMBER_OF_REPLICAS"},{"location":"parser/CommonCreateConfigs/#timestamp_name_property","text":"","title":"TIMESTAMP_NAME_PROPERTY"},{"location":"parser/CommonCreateConfigs/#timestamp_format","text":"","title":"TIMESTAMP_FORMAT"},{"location":"parser/CommonCreateConfigs/#value_avro_schema_full_name","text":"","title":"VALUE_AVRO_SCHEMA_FULL_NAME"},{"location":"parser/CommonCreateConfigs/#value_delimiter_property","text":"","title":"VALUE_DELIMITER_PROPERTY"},{"location":"parser/CommonCreateConfigs/#value_format","text":"","title":"VALUE_FORMAT <p>The format of the serialized value</p> <p>Default: (undefined)</p> <p>Overrides KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG</p> <p>Must not be specified with FORMAT</p> <p>Used when:</p> <ul> <li><code>DefaultSchemaInjector</code> is requested to <code>shouldInferSchema</code></li> <li><code>CreateSourceAsProperties</code> is requested for the value_format</li> <li><code>CreateSourceProperties</code> is requested for the value_format and to withFormats</li> </ul>"},{"location":"parser/CommonCreateConfigs/#value_schema_full_name","text":"","title":"VALUE_SCHEMA_FULL_NAME"},{"location":"parser/CommonCreateConfigs/#value_schema_id","text":"","title":"VALUE_SCHEMA_ID"},{"location":"parser/CommonCreateConfigs/#wrap_single_value","text":"","title":"WRAP_SINGLE_VALUE"},{"location":"parser/CommonCreateConfigs/#partitions","text":"","title":"PARTITIONS <p>The number of partitions in the backing topic. Required if creating a source without an existing topic.</p> <p>Default: (undefined)</p>"},{"location":"parser/CommonCreateConfigs/#addtoconfigdef","text":"","title":"addToConfigDef <pre><code>void addToConfigDef(\n  ConfigDef configDef,\n  boolean topicNameRequired)\n</code></pre> <p><code>addToConfigDef</code> defines configuration properties (in the given <code>ConfigDef</code>).</p> <p><code>addToConfigDef</code> is used when:</p> <ul> <li><code>CreateAsConfigs</code> is created</li> <li><code>CreateConfigs</code> is created</li> </ul>"},{"location":"parser/CreateAsSelect/","text":"<p><code>CreateAsSelect</code> is...FIXME</p>","title":"CreateAsSelect"},{"location":"parser/CreateSource/","text":"<p><code>CreateSource</code> is an extension of the Statement abstraction for CREATE SOURCE statements.</p>","title":"CreateSource"},{"location":"parser/CreateSource/#contract","text":"","title":"Contract"},{"location":"parser/CreateSource/#copywith","text":"","title":"copyWith <pre><code>CreateSource copyWith(\n  TableElements elements,\n  CreateSourceProperties properties)\n</code></pre> <p>Overrides <code>TableElements</code> and <code>CreateSourceProperties</code> of this <code>CreateSource</code></p> <p>Used when:</p> <ul> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitCreateStream</code> and <code>visitCreateTable</code></li> <li><code>DefaultFormatInjector</code> is requested to <code>injectForCreateStatement</code></li> <li><code>DefaultSchemaInjector</code> is requested to <code>addSchemaFields</code></li> <li><code>SourcePropertyInjector</code> is requested to <code>buildConfiguredStatement</code></li> <li><code>TopicCreateInjector</code> is requested to <code>injectForCreateSource</code></li> </ul>"},{"location":"parser/CreateSource/#getsourcetype","text":"","title":"getSourceType <pre><code>SourceType getSourceType()\n</code></pre>"},{"location":"parser/CreateSource/#implementations","text":"<ul> <li>CreateStream</li> <li>CreateTable</li> </ul>","title":"Implementations"},{"location":"parser/CreateSource/#creating-instance","text":"<p><code>CreateSource</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>SourceName</code> <li> <code>TableElements</code> <li> <code>orReplace</code> flag <li> <code>notExists</code> flag <li> CreateSourceProperties <li> <code>isSource</code> flag   <p>Abstract Class</p> <p><code>CreateSource</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete CreateSources.</p>","title":"Creating Instance"},{"location":"parser/CreateSourceAsProperties/","text":"<p><code>CreateSourceAsProperties</code> is...FIXME</p>","title":"CreateSourceAsProperties"},{"location":"parser/CreateSourceProperties/","text":"","title":"CreateSourceProperties"},{"location":"parser/CreateSourceProperties/#creating-instance","text":"<p><code>CreateSourceProperties</code> takes the following to be created:</p> <ul> <li> Originals (<code>Map&lt;String, Literal&gt;</code>) <li> Duration Parser (<code>Function&lt;String, Duration&gt;</code>)  <p><code>CreateSourceProperties</code> is created using from factory and when:</p> <ul> <li>withKeyValueSchemaName</li> <li>withPartitions</li> <li>withFormats</li> </ul> <p>While being created, <code>CreateSourceProperties</code> creates a PropertiesConfig and performs parameter validations.</p>","title":"Creating Instance"},{"location":"parser/CreateSourceProperties/#creating-createsourceproperties","text":"","title":"Creating CreateSourceProperties <pre><code>CreateSourceProperties from(\n  Map&lt;String, Literal&gt; literals)\n</code></pre> <p><code>from</code> creates a CreateSourceProperties (with the given <code>literals</code> and the default <code>DurationParser</code>).</p>  <p><code>from</code> is used when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to visitCreateTable, visitCreateStream, visitAssertStream and visitAssertTable</li> </ul>"},{"location":"parser/CreateSourceProperties/#propertiesconfig","text":"","title":"PropertiesConfig <p>When created, <code>CreateSourceProperties</code> creates a <code>PropertiesConfig</code> with the following table-specific configuration properties (in addition to CommonCreateConfigs).</p>"},{"location":"parser/CreateSourceProperties/#source_connector","text":"","title":"SOURCE_CONNECTOR <p>Indicates that this source was created by a connector with the given name.</p> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#window_size","text":"","title":"WINDOW_SIZE <p>Window size of <code>HOPPING</code> or <code>TUMBLING</code> windows, e.g. <code>20 SECONDS</code></p> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#window_type","text":"","title":"WINDOW_TYPE <p>Supported values:</p> <ul> <li><code>SESSION</code></li> <li><code>HOPPING</code></li> <li><code>TUMBLING</code></li> </ul> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#value_format","text":"","title":"value_format <pre><code>Optional&lt;FormatInfo&gt; getValueFormat()\n</code></pre> <p><code>getValueFormat</code> takes FORMAT (if defined) or defaults to VALUE_FORMAT property (using the PropertiesConfig).</p> <p>If defined (using either configuration property), the value format is converted to <code>FormatInfo</code> (with getValueFormatProperties).</p> <p><code>getValueFormat</code> is used when:</p> <ul> <li><code>DefaultFormatInjector</code> is requested to <code>injectForCreateStatement</code></li> <li><code>SourcePropertiesUtil</code> is requested to getValueFormat</li> </ul>"},{"location":"parser/CreateSourceProperties/#getkeyformat","text":"","title":"getKeyFormat <pre><code>Optional&lt;FormatInfo&gt; getKeyFormat(\n  SourceName name)\n</code></pre> <p><code>getKeyFormat</code>...FIXME</p>  <p><code>getKeyFormat</code> is used when:</p> <ul> <li><code>DefaultFormatInjector</code> is requested for <code>injectForCreateStatement</code></li> <li><code>SourcePropertiesUtil</code> is requested to getKeyFormat</li> </ul>"},{"location":"parser/CreateSourceProperties/#getkeyformatproperties","text":"","title":"getKeyFormatProperties <pre><code>Map&lt;String, String&gt; getKeyFormatProperties(\n  String keyFormat,\n  String name)\n</code></pre> <p><code>getKeyFormatProperties</code>...FIXME</p>"},{"location":"parser/CreateSourceProperties/#getkeyschemaid","text":"","title":"getKeySchemaId <pre><code>Optional&lt;Integer&gt; getKeySchemaId()\n</code></pre> <p><code>getKeySchemaId</code> is the value of KEY_SCHEMA_ID property.</p>  <p><code>getKeySchemaId</code> is used when:</p> <ul> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateStatement</code>, <code>getKeySchema</code>, <code>addSchemaFields</code></li> <li><code>CreateSourceProperties</code> is requested to getKeyFormatProperties</li> </ul>"},{"location":"parser/CreateStream/","text":"<p><code>CreateStream</code> is a CreateSource and a ExecutableDdlStatement that represents CREATE STREAM and ASSERT STREAM statements.</p> <p><code>CreateStream</code> is handled by:</p> <ul> <li>CommandFactories is used to handleCreateStream</li> <li><code>CreateSourceFactory</code> is used to createStreamCommand</li> <li><code>CommandIdAssigner</code> is requested to <code>getTopicStreamCommandId</code></li> </ul>","title":"CreateStream"},{"location":"parser/CreateStream/#creating-instance","text":"<p><code>CreateStream</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>SourceName</code> <li> <code>TableElements</code> <li> <code>orReplace</code> flag <li> <code>notExists</code> flag <li> CreateSourceProperties <li> <code>isSource</code> flag  <p><code>CreateStream</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to parse CREATE STREAM and ASSERT STREAM statements</li> <li><code>CreateStream</code> is requested to copyWith</li> </ul>","title":"Creating Instance"},{"location":"parser/CreateStream/#copywith","text":"","title":"copyWith <pre><code>CreateSource copyWith(\n  TableElements elements,\n  CreateSourceProperties properties\n)\n</code></pre> <p><code>copyWith</code> is part of the CreateSource abstraction.</p>  <p><code>copyWith</code> creates a new CreateStream with the given <code>TableElements</code> and <code>CreateSourceProperties</code>.</p>"},{"location":"parser/CreateStream/#planning","text":"","title":"Planning <p><code>EngineExecutor</code> is requested to plan CREATE STREAM statements</p>"},{"location":"parser/CreateStream/#execution","text":"","title":"Execution <ul> <li>DistributingExecutor</li> <li>StatementExecutor</li> </ul>"},{"location":"parser/CreateStreamAsSelect/","text":"<p><code>CreateStreamAsSelect</code> is...FIXME</p>","title":"CreateStreamAsSelect"},{"location":"parser/CreateTable/","text":"<p><code>CreateTable</code> is a CreateSource and a ExecutableDdlStatement that represents CREATE TABLE and ASSERT TABLE statements.</p>","title":"CreateTable"},{"location":"parser/CreateTable/#creating-instance","text":"<p><code>CreateTable</code> takes the following to be created:</p> <ul> <li> Node Location <li> Source Name <li> <code>TableElements</code> <li> <code>orReplace</code> flag <li> <code>notExists</code> flag <li> CreateSourceProperties <li> <code>isSource</code> flag  <p><code>CreateTable</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to parse CREATE TABLE and ASSERT TABLE statements</li> </ul>","title":"Creating Instance"},{"location":"parser/CreateTableAsSelect/","text":"<p><code>CreateTableAsSelect</code> is...FIXME</p>","title":"CreateTableAsSelect"},{"location":"parser/DdlStatement/","text":"<p><code>DdlStatement</code> is a marker interface.</p> <p><code>DdlStatement</code> is used to create a DdlCommand.</p>","title":"DdlStatement"},{"location":"parser/DdlStatement/#implementations","text":"<ul> <li>ExecutableDdlStatement</li> </ul>","title":"Implementations"},{"location":"parser/DefaultKsqlParser/","text":"<p><code>DefaultKsqlParser</code> is a KsqlParser.</p>","title":"DefaultKsqlParser"},{"location":"parser/DefaultKsqlParser/#demo","text":"<pre><code>import io.confluent.ksql.parser.DefaultKsqlParser\nval parser = new DefaultKsqlParser()\n\nval ksql = \"SELECT * FROM my_stream;\"\nval statements = parser.parse(ksql)\n\nimport scala.jdk.CollectionConverters._\nval pstmt = statements.asScala.head\nassert(pstmt.isInstanceOf[io.confluent.ksql.parser.KsqlParser.ParsedStatement])\n</code></pre>","title":"Demo"},{"location":"parser/DefaultKsqlParser/#creating-instance","text":"<p><code>DefaultKsqlParser</code> takes no arguments to be created.</p> <p><code>DefaultKsqlParser</code> is created when:</p> <ul> <li><code>Cli</code> is created</li> <li><code>EngineContext</code> utility is used to create an EngineContext and createSandbox</li> <li><code>KsqlResource</code> is requested for TERMINATE_CLUSTER</li> </ul>","title":"Creating Instance"},{"location":"parser/DefaultKsqlParser/#parsing-sql-statements-parse","text":"","title":"Parsing SQL Statements (parse) <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> parses the given <code>sql</code> (using ANTLR) and creates as many <code>ParsedStatement</code>s as there are SQL statements in the <code>sql</code>.</p>  <p>ANTLR</p> <p>This is when a SQL text is parsed (transformed) using ANTLR into a collection of ksqlDB's <code>ParsedStatement</code>s according to the <code>SqlBase.g4</code> grammar:</p> <pre><code>statements\n    : (singleStatement)* EOF\n    ;\n</code></pre> <p>Every <code>ParsedStatement</code>s maps exactly to a <code>singleStatement</code>.</p>  <p><code>parse</code> is part of the KsqlParser abstraction.</p>"},{"location":"parser/DefaultKsqlParser/#preparing-statement-for-execution","text":"","title":"Preparing Statement for Execution <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  TypeRegistry typeRegistry)\n</code></pre> <p><code>prepare</code> is part of the KsqlParser abstraction.</p>  <p><code>prepare</code> creates an AstBuilder (with the given <code>TypeRegistry</code>) to build a Statement.</p> <p>In the end, <code>prepare</code> creates a <code>PreparedStatement</code> (with the SQL query in text format and as the Statement).</p>"},{"location":"parser/DefaultTraversalVisitor/","text":"<p><code>DefaultTraversalVisitor</code> is an extension of the AstVisitor abstraction for AST visitors with default implementation of the parent abstraction.</p>","title":"DefaultTraversalVisitor"},{"location":"parser/DefaultTraversalVisitor/#implementations","text":"<ul> <li><code>SourceTopicsExtractor</code></li> <li>Analyzer.Visitor</li> <li><code>DataSourceExtractor.Visitor</code></li> </ul>","title":"Implementations"},{"location":"parser/ExecutableDdlStatement/","text":"<p><code>ExecutableDdlStatement</code> is an extension of the DdlStatement abstraction and a marker interface for executable DDL statements.</p> <p><code>ExecutableDdlStatement</code> is among the executable statements for KsqlEngine.</p> <p><code>ExecutableDdlStatement</code>s are planned for execution by EngineExecutor.</p>","title":"ExecutableDdlStatement"},{"location":"parser/ExecutableDdlStatement/#implementations","text":"<ul> <li><code>AlterSource</code></li> <li>CreateStream</li> <li>CreateTable</li> <li><code>DropStream</code></li> <li><code>DropTable</code></li> <li><code>DropType</code></li> <li><code>RegisterType</code></li> </ul>","title":"Implementations"},{"location":"parser/Explain/","text":"<p><code>Explain</code> is a Statement.</p>","title":"Explain Statement"},{"location":"parser/Explain/#creating-instance","text":"<p><code>Explain</code> takes the following to be created:</p> <ul> <li> Node Location (in a SQL text) <li> Query ID <li> Statement  <p><code>Explain</code> is created when:</p> <ul> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitExplain</code></li> <li><code>AstBuilder.Visitor</code> is requested to visitExplain</li> </ul>","title":"Creating Instance"},{"location":"parser/Explain/#accept","text":"","title":"accept <pre><code>R accept(\n  AstVisitor&lt;R, C&gt; visitor,\n  C context)\n</code></pre> <p><code>accept</code> requests the given AstVisitor to visitExplain.</p> <p><code>accept</code> is part of the Statement abstraction.</p>"},{"location":"parser/Expression/","text":"<p><code>Expression</code> is...FIXME</p>","title":"Expression"},{"location":"parser/InsertInto/","text":"<p><code>InsertInto</code> is a Statement and a QueryContainer.</p>","title":"InsertInto"},{"location":"parser/InsertInto/#creating-instance","text":"<p><code>InsertInto</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> Source Name <li> Query <li> <code>InsertIntoProperties</code>  <p><code>InsertInto</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to parse INSERT INTO statement</li> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitInsertInto</code></li> </ul>","title":"Creating Instance"},{"location":"parser/KsqlParser/","text":"<p><code>KsqlParser</code> is an abstraction of SQL parsers.</p>","title":"KsqlParser"},{"location":"parser/KsqlParser/#contract","text":"","title":"Contract"},{"location":"parser/KsqlParser/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p>Parses the given SQL text into a collection of <code>ParsedStatement</code>s. There can be zero, one or more SQL statements in the given SQL text.</p> <p>See DefaultKsqlParser</p> <p>Used when:</p> <ul> <li><code>Cli</code> is requested to substituteVariables and handleStatements</li> <li><code>EngineContext</code> is requested to parse SQL statements</li> <li><code>KsqlResource</code> is requested for TERMINATE_CLUSTER</li> </ul>"},{"location":"parser/KsqlParser/#preparing-parsedstatement","text":"","title":"Preparing ParsedStatement <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement statement,\n  TypeRegistry typeRegistry)\n</code></pre> <p>See DefaultKsqlParser</p> <p>Used when:</p> <ul> <li><code>EngineContext</code> is requested to prepare a ParsedStatement</li> </ul>"},{"location":"parser/KsqlParser/#implementations","text":"<ul> <li>DefaultKsqlParser</li> </ul>","title":"Implementations"},{"location":"parser/KsqlWindowExpression/","text":"<p><code>KsqlWindowExpression</code> is...FIXME</p>","title":"KsqlWindowExpression"},{"location":"parser/ListStreams/","text":"<p><code>ListStreams</code> is a <code>StatementWithExtendedClause</code> (a Statement with optional <code>EXTENDED</code> clause) that represents the following ksql statement:</p> <pre><code>(LIST | SHOW) STREAMS EXTENDED?\n</code></pre> <p><code>ListStreams</code> is executed using ListSourceExecutor.</p>","title":"ListStreams"},{"location":"parser/ListStreams/#creating-instance","text":"<p><code>ListStreams</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>showExtended</code> flag  <p><code>ListStreams</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to parse LIST STREAMS statement</li> </ul>","title":"Creating Instance"},{"location":"parser/Node/","text":"<p><code>Node</code> is an abstraction of nodes of trees that are result of parsing SQL statements (using AstBuilder.Visitor).</p>","title":"Node"},{"location":"parser/Node/#implementations","text":"<ul> <li>AstNode</li> <li>Expression</li> <li>KsqlWindowExpression</li> </ul>","title":"Implementations"},{"location":"parser/Node/#creating-instance","text":"<p><code>Node</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> (with line and column numbers)   <p>Abstract Class</p> <p><code>Node</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete Nodes.</p>","title":"Creating Instance"},{"location":"parser/Query/","text":"<p><code>Query</code> is a Statement.</p>","title":"Query"},{"location":"parser/Query/#demo","text":"","title":"Demo"},{"location":"parser/Query/#create-ksqlengine","text":"<p>Create KsqlEngine with <code>bootstrap.servers</code> configuration property (to let the Injector resolve a stream source for a query).</p> <pre><code>import io.confluent.ksql.util.KsqlConfig\nimport scala.jdk.CollectionConverters._\nval props = Map(\"bootstrap.servers\" -&gt; \":9092\").asJava\nval ksqlConfig = new KsqlConfig(props)\n\nval ksqlEngine = ???\n</code></pre>","title":"Create KsqlEngine"},{"location":"parser/Query/#create-stream","text":"<pre><code>val ksql = \"\"\"\n  CREATE STREAM orders (\n    id bigint KEY,\n    item varchar)\n  WITH (\n    kafka_topic = 'orders_topic',\n    value_format = 'json',\n    partitions = 2);\n\"\"\"\n\nval statements = ksqlEngine.parse(ksql)\nval parsed = statements.asScala.head\nval prepared = ksqlEngine.prepare(parsed)\n</code></pre> <pre><code>import io.confluent.ksql.statement.Injectors\nval serviceContext = ksqlEngine.getServiceContext\nval injector = Injectors.DEFAULT(ksqlEngine, serviceContext)\nval executionOverrides = Map.empty[String, String].asJava;\n\nimport io.confluent.ksql.statement.ConfiguredStatement\nimport io.confluent.ksql.config.SessionConfig\nval preconfigured = ConfiguredStatement.of(\n  prepared,\n  SessionConfig.of(ksqlConfig, executionOverrides))\nval configured = injector.inject(preconfigured)\n\nksqlEngine.execute(serviceContext, configured)\n</code></pre>","title":"Create Stream"},{"location":"parser/Query/#pull-query","text":"<pre><code>val ksql = \"SELECT * FROM orders;\"\n\nval statements = ksqlEngine.parse(ksql)\nval parsed = statements.asScala.head\nval prepared = ksqlEngine.prepare(parsed)\n\nval preconfigured = ConfiguredStatement.of(\n  prepared,\n  SessionConfig.of(ksqlConfig, executionOverrides))\nval configured = injector.inject(preconfigured)\n\nimport io.confluent.ksql.parser.tree.Query\nval query = configured.getStatement.asInstanceOf[Query]\nassert(query.isPullQuery)\n</code></pre>","title":"Pull Query"},{"location":"parser/Query/#creating-instance","text":"<p><code>Query</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>Select</code> <li> <code>Relation</code> <li> <code>WindowExpression</code> <li> <code>Expression</code> <li> <code>GroupBy</code> <li> <code>PartitionBy</code> <li> <code>Expression</code> <li> <code>RefinementInfo</code> <li>pullQuery</li> <li> Limit  <p><code>Query</code> is created when:</p> <ul> <li><code>EngineExecutor</code> is requested to sourceTablePlan</li> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitQuery</code></li> <li><code>AstBuilder.Visitor</code> is requested to visitQuery</li> </ul>","title":"Creating Instance"},{"location":"parser/Query/#pullquery-flag","text":"","title":"pullQuery Flag <p><code>Query</code> is given a <code>pullQuery</code> flag when created (which is most importantly when <code>AstBuilder.Visitor</code> is requested to visitQuery).</p> <p><code>AstBuilder.Visitor</code> turns the <code>pullQuery</code> flag on (<code>true</code>) when the <code>Query</code> has no <code>EMIT</code> clause (and the buildingPersistentQuery internal flag is off).</p>"},{"location":"parser/Query/#ispullquery","text":"","title":"isPullQuery <pre><code>boolean isPullQuery()\n</code></pre> <p><code>isPullQuery</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitQuery</li> <li><code>QueryAnalyzer</code> is requested to analyze</li> <li><code>EngineExecutor</code> is requested to executeTablePullQuery</li> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitQuery</code></li> <li><code>SqlFormatter.Formatter</code> is requested to <code>visitQuery</code></li> <li><code>QueryExecutor</code> is requested to handleQuery</li> <li><code>ScalablePushUtil</code> is requested to isScalablePushQuery</li> </ul>"},{"location":"parser/Query/#accept","text":"","title":"accept <pre><code>R accept(\n  AstVisitor&lt;R, C&gt; visitor,\n  C context)\n</code></pre> <p><code>accept</code> requests the given AstVisitor to visit a Query.</p> <p><code>accept</code> is part of the AstNode abstraction.</p>"},{"location":"parser/QueryContainer/","text":"<p><code>QueryContainer</code> is an abstraction of SQL statements with a query.</p>","title":"QueryContainer"},{"location":"parser/QueryContainer/#contract","text":"","title":"Contract"},{"location":"parser/QueryContainer/#getquery","text":"","title":"getQuery <pre><code>Query getQuery()\n</code></pre> <p>Query</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a ConfiguredStatement</li> <li><code>TopicCreateInjector</code> is requested to <code>injectForCreateAsSelect</code></li> <li><code>DefaultTraversalVisitor</code> is requested to visitInsertInto, visitCreateStreamAsSelect, visitCreateTableAsSelect</li> <li>a few others</li> </ul>"},{"location":"parser/QueryContainer/#getqueryid","text":"","title":"getQueryId <pre><code>Optional&lt;String&gt; getQueryId()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a ConfiguredStatement</li> </ul>"},{"location":"parser/QueryContainer/#getsink","text":"","title":"getSink <pre><code>Sink getSink()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a statement</li> </ul>"},{"location":"parser/QueryContainer/#implementations","text":"<ul> <li>CreateAsSelect</li> <li>InsertInto</li> </ul>","title":"Implementations"},{"location":"parser/SourceAccumulator/","text":"<p><code>SourceAccumulator</code> is a <code>SqlBaseBaseVisitor</code> to collect source relations (possibly aliased) in a SQL query.</p> <pre><code>aliasedRelation\n    : relationPrimary (AS? sourceName)?\n    ;\n\nrelationPrimary\n    : sourceName                        #tableName\n    ;\n</code></pre>  <p>Note</p> <p><code>SqlBaseBaseVisitor</code> is generated from <code>io/confluent/ksql/parser/SqlBase.g4</code> at build time by ANTLR.</p>","title":"SourceAccumulator"},{"location":"parser/SourceAccumulator/#visitcreatestream","text":"","title":"visitCreateStream <p>Creates a CreateStream</p>"},{"location":"parser/SourcePropertiesUtil/","text":"","title":"SourcePropertiesUtil"},{"location":"parser/SourcePropertiesUtil/#getkeyformat","text":"","title":"getKeyFormat <pre><code>FormatInfo getKeyFormat(\n  CreateSourceProperties properties,\n  SourceName sourceName)\n</code></pre> <p><code>getKeyFormat</code> requests the given CreateSourceProperties for getKeyFormat of the <code>SourceName</code> (if available) or throws an <code>IllegalStateException</code>:</p> <pre><code>Key format not present\n</code></pre>  <p><code>getKeyFormat</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to buildFormats</li> <li><code>DefaultSchemaInjector</code> is requested to <code>getKeySchema</code>, <code>addSchemaFields</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateSource</code></li> </ul>"},{"location":"parser/SourcePropertiesUtil/#getvalueformat","text":"","title":"getValueFormat <pre><code>FormatInfo getValueFormat(\n  CreateSourceProperties properties)\n</code></pre> <p><code>getValueFormat</code> takes the value_format property from the given CreateSourceProperties or throws an <code>IllegalStateException</code>:</p> <pre><code>Value format not present\n</code></pre>  <p><code>getValueFormat</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to buildFormats</li> <li><code>DefaultSchemaInjector</code> is requested to <code>getValueSchema</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateSource</code></li> </ul>"},{"location":"parser/Statement/","text":"<p><code>Statement</code> is an extension of the AstNode abstraction for SQL statements after parsing from an AST tree.</p>","title":"Statement"},{"location":"parser/Statement/#implementations","text":"<ul> <li>AlterSystemProperty</li> <li>CreateAsSelect</li> <li>CreateSource</li> <li>InsertInto</li> <li>Query</li> <li>others</li> </ul>","title":"Implementations"},{"location":"parser/TerminateQuery/","text":"<p><code>TerminateQuery</code> is...FIXME</p>","title":"TerminateQuery"},{"location":"parser/VariableSubstitutor/","text":"","title":"VariableSubstitutor"},{"location":"parser/VariableSubstitutor/#variable-substitution-substitute","text":"","title":"Variable Substitution (substitute) <pre><code>String substitute(\n  KsqlParser.ParsedStatement parsedStatement,\n  Map&lt;String, String&gt; valueMap)\nString substitute(\n  String string,\n  Map&lt;String, String&gt; valueMap)\n</code></pre> <p><code>substitute</code> replaces variables in the SQL text (either as a <code>ParsedStatement</code> or a <code>String</code> using SqlSubstitutorVisitor).</p> <p><code>substitute</code> is used when:</p> <ul> <li><code>Cli</code> is requested to substituteVariables</li> <li><code>EngineContext</code> is requested to substituteVariables</li> <li><code>CommandParser</code> is used</li> </ul>"},{"location":"parser/VariableSubstitutor/#sqlsubstitutorvisitor","text":"","title":"SqlSubstitutorVisitor <p><code>SqlSubstitutorVisitor</code> is a <code>SqlBaseBaseVisitor</code> (that <code>VariableSubstitutor</code> uses for variable substitution).</p>  <p>ANTLR</p> <p><code>SqlBaseBaseVisitor</code> is generated from <code>SqlBase.g4</code> SQL grammar by ANTLR at build time.</p>"},{"location":"parser/VariableSubstitutor/#replace","text":"","title":"replace <pre><code>String replace(\n  SqlBaseParser.SingleStatementContext singleStatementContext)\n</code></pre> <p><code>replace</code> walks the statement tree (using <code>visit</code>) and then uses <code>StringSubstitutor.replace</code> (Commons Text) to substitute variables.</p>"},{"location":"planner/","text":"<p>ksqlDB uses EngineExecutor to plan a query for execution.</p> <p>At some point in a query lifecycle, QueryEngine is requested for a physical query plan (that uses Kafka Streams' StreamsBuilder to build a streaming topology).</p>","title":"Query Planning"},{"location":"planner/DataSourceNode/","text":"","title":"DataSourceNode"},{"location":"planner/DataSourceNode/#creating-instance","text":"<p><code>DataSourceNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> DataSource <li> Source Name <li>SchemaKStreamFactory</li> <li> <code>isWindowed</code> flag <li> KsqlConfig  <p><code>DataSourceNode</code> is created when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build a join or a non-join node</li> </ul>","title":"Creating Instance"},{"location":"planner/DataSourceNode/#schemakstreamfactory","text":"","title":"SchemaKStreamFactory <p><code>DataSourceNode</code> can be given a <code>SchemaKStreamFactory</code> when created. Unless given, <code>DataSourceNode</code> uses SchemaKSourceFactory.</p>  <p>Note</p> <p>Note the difference in type names, i.e. <code>SchemaKStreamFactory</code> (with <code>Stream</code> inside) vs <code>SchemaKSourceFactory</code> (with <code>Source</code> instead).</p>  <p>The <code>SchemaKStreamFactory</code> is used to create a SchemaKStream when <code>DataSourceNode</code> is requested to build one.</p>"},{"location":"planner/DataSourceNode/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p><code>buildStream</code> requests the given <code>PlanBuildContext</code> to <code>buildNodeContext</code>.</p> <p>In the end, requests the SchemaKStreamFactory for a SchemaKStream.</p>  <p><code>buildStream</code> is part of the PlanNode abstraction.</p>"},{"location":"planner/FlatMapNode/","text":"<p><code>FlatMapNode</code> is a SingleSourcePlanNode.</p>","title":"FlatMapNode"},{"location":"planner/FlatMapNode/#creating-instance","text":"<p><code>FlatMapNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> Parent PlanNode <li> <code>FunctionRegistry</code> <li> ImmutableAnalysis  <p><code>FlatMapNode</code> is created when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build a logical plan of a persistent query with a table function</li> </ul>","title":"Creating Instance"},{"location":"planner/FlatMapNode/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p><code>buildStream</code> requests the source node to build a SchemaKStream to flatMap.</p> <p><code>buildStream</code> is part of the PlanNode abstraction.</p>"},{"location":"planner/JoinNode/","text":"<p><code>JoinNode</code> is...FIXME</p>","title":"JoinNode"},{"location":"planner/KsqlStructuredDataOutputNode/","text":"<p><code>KsqlStructuredDataOutputNode</code> is an OutputNode.</p>","title":"KsqlStructuredDataOutputNode"},{"location":"planner/KsqlStructuredDataOutputNode/#creating-instance","text":"<p><code>KsqlStructuredDataOutputNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> Parent PlanNode <li> <code>LogicalSchema</code> <li> <code>TimestampColumn</code> <li> <code>KsqlTopic</code> <li> Limit <li> <code>doCreateInto</code> flag <li> Sink Name <li> <code>orReplace</code> flag  <p><code>KsqlStructuredDataOutputNode</code> is created when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build an OutputNode (for a QueryContainer)</li> </ul>","title":"Creating Instance"},{"location":"planner/KsqlStructuredDataOutputNode/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p><code>buildStream</code> requests the source PlanNode to build a SchemaKStream.</p> <p>In the end, <code>buildStream</code> requests the SchemaKStream to into (for the ksqlTopic and the timestampColumn).</p>  <p><code>buildStream</code> is part of the PlanNode abstraction.</p>"},{"location":"planner/LogicalPlanner/","text":"","title":"LogicalPlanner"},{"location":"planner/LogicalPlanner/#creating-instance","text":"<p><code>LogicalPlanner</code> takes the following to be created:</p> <ul> <li> KsqlConfig <li>ImmutableAnalysis</li> <li> MetaStore  <p><code>LogicalPlanner</code> is created when:</p> <ul> <li><code>EngineExecutor</code> is requested to buildAndValidateLogicalPlan</li> <li><code>QueryEngine</code> is requested to buildQueryLogicalPlan</li> </ul>","title":"Creating Instance"},{"location":"planner/LogicalPlanner/#immutableanalysis-and-rewrittenanalysis","text":"","title":"ImmutableAnalysis and RewrittenAnalysis <p><code>LogicalPlanner</code> creates a <code>RewrittenAnalysis</code> for the given ImmutableAnalysis when created.</p> <p>The <code>RewrittenAnalysis</code> is used when <code>LogicalPlanner</code> is requested for the following:</p> <ul> <li>buildSourceNode</li> <li>buildPersistentLogicalPlan</li> <li>buildQueryLogicalPlan</li> <li>buildOutputNode</li> <li>getWindowInfo</li> <li>getSinkTopic</li> <li>getSinkKeyFormat</li> <li>getTargetSchema</li> <li>buildAggregateNode</li> <li>buildUserProjectNode</li> <li>buildFlatMapNode</li> <li>buildJoinKey</li> <li>buildAggregateSchema</li> </ul>"},{"location":"planner/LogicalPlanner/#buildpersistentlogicalplan","text":"","title":"buildPersistentLogicalPlan <pre><code>OutputNode buildPersistentLogicalPlan()\n</code></pre> <p><code>buildPersistentLogicalPlan</code> creates an OutputNode.</p> <p><code>buildPersistentLogicalPlan</code> is used when:</p> <ul> <li><code>QueryEngine</code> is requested to build a logical plan of a query</li> </ul>"},{"location":"planner/LogicalPlanner/#step-1-source-node","text":"","title":"Step 1. Source Node <p><code>buildPersistentLogicalPlan</code> builds a source node (with <code>isWindowed</code> flag based on the RewrittenAnalysis of the query).</p>"},{"location":"planner/LogicalPlanner/#step-2-filternode","text":"","title":"Step 2. FilterNode <p>For a query with <code>WHERE</code> clause (per the RewrittenAnalysis), <code>buildPersistentLogicalPlan</code> creates a new <code>QueryFilterNode</code> to be the current PlanNode.</p>"},{"location":"planner/LogicalPlanner/#step-3-userrepartitionnode","text":"","title":"Step 3. UserRepartitionNode <p>For a query with <code>PartitionBy</code> clause (per the RewrittenAnalysis), <code>buildPersistentLogicalPlan</code> buildUserRepartitionNode.</p>"},{"location":"planner/LogicalPlanner/#step-4-flatmapnode","text":"","title":"Step 4. FlatMapNode <p>For a query with <code>TableFunctions</code> (per the RewrittenAnalysis), <code>buildPersistentLogicalPlan</code> buildFlatMapNode.</p>"},{"location":"planner/LogicalPlanner/#building-flatmapnode","text":"","title":"Building FlatMapNode <pre><code>FlatMapNode buildFlatMapNode(\n  PlanNode sourcePlanNode)\n</code></pre> <p><code>buildFlatMapNode</code> creates a FlatMapNode (with a <code>PlanNodeId</code> with <code>FlatMap</code> ID).</p>"},{"location":"planner/LogicalPlanner/#aggregatenode","text":"","title":"AggregateNode <p>For a query with <code>GroupBy</code> clause (per the RewrittenAnalysis), <code>buildPersistentLogicalPlan</code> buildAggregateNode. Otherwise, <code>buildPersistentLogicalPlan</code>...FIXME</p>"},{"location":"planner/LogicalPlanner/#refinementinfo","text":"","title":"RefinementInfo <p>For a query with a <code>RefinementInfo</code> (per the RewrittenAnalysis), <code>buildPersistentLogicalPlan</code>...FIXME</p>"},{"location":"planner/LogicalPlanner/#outputnode","text":"","title":"OutputNode <p>In the end, <code>buildPersistentLogicalPlan</code> builds an output node.</p>"},{"location":"planner/LogicalPlanner/#building-logical-plan-of-query-buildquerylogicalplan","text":"","title":"Building Logical Plan of Query (buildQueryLogicalPlan) <pre><code>OutputNode buildQueryLogicalPlan(\n  QueryPlannerOptions queryPlannerOptions,\n  boolean isScalablePush)\n</code></pre> <p><code>buildQueryLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to buildAndValidateLogicalPlan</li> </ul>"},{"location":"planner/LogicalPlanner/#step-1-source-node_1","text":"","title":"Step 1. Source Node <p><code>buildQueryLogicalPlan</code> builds a source node (with <code>isWindowed</code> flag based on the RewrittenAnalysis of the query).</p>"},{"location":"planner/LogicalPlanner/#step-2-filter-node","text":"","title":"Step 2. Filter Node <p>For a query with <code>WHERE</code> clause (per the RewrittenAnalysis), <code>buildQueryLogicalPlan</code> creates a new <code>QueryFilterNode</code> to be the current PlanNode. Otherwise, <code>buildQueryLogicalPlan</code> throws a <code>KsqlException</code> for a missing <code>WHERE</code> clause unless getTableScansEnabled is enabled.</p>"},{"location":"planner/LogicalPlanner/#step-3-limit-node","text":"","title":"Step 3. Limit Node <p>For a non-<code>isScalablePush</code> query with <code>LIMIT</code> clause, <code>buildQueryLogicalPlan</code> builds a limit PlanNode to be the current PlanNode.</p>"},{"location":"planner/LogicalPlanner/#step-4-project-node","text":"","title":"Step 4. Project Node <p>In the end, <code>buildQueryLogicalPlan</code> creates a <code>QueryProjectNode</code> (to be the current PlanNode) and builds an output node.</p>"},{"location":"planner/LogicalPlanner/#building-datasourcenode-or-joinnode-buildsourcenode","text":"","title":"Building DataSourceNode or JoinNode (buildSourceNode) <pre><code>PlanNode buildSourceNode(\n  boolean isWindowed)\n</code></pre> <p><code>buildSourceNode</code> buildNonJoinNode when the RewrittenAnalysis is not for a join.</p> <p>Otherwise, <code>buildSourceNode</code>...FIXME</p> <p><code>buildSourceNode</code> is used when:</p> <ul> <li><code>LogicalPlanner</code> is requested to buildPersistentLogicalPlan and buildQueryLogicalPlan</li> </ul>"},{"location":"planner/LogicalPlanner/#creating-datasourcenode-buildnonjoinnode","text":"","title":"Creating DataSourceNode (buildNonJoinNode) <pre><code>DataSourceNode buildNonJoinNode(\n  AliasedDataSource dataSource,\n  boolean isWindowed,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>buildNonJoinNode</code> creates a DataSourceNode (with a new <code>PlanNodeId</code> with <code>KsqlTopic</code> ID).</p>"},{"location":"planner/LogicalPlanner/#creating-joinnode-buildjoin","text":"","title":"Creating JoinNode (buildJoin) <pre><code>JoinNode buildJoin(\n  Join root,\n  String prefix,\n  boolean isWindowed)\n</code></pre> <p><code>buildJoin</code> creates a JoinNode.</p>"},{"location":"planner/LogicalPlanner/#building-output-node","text":"","title":"Building Output Node <pre><code>OutputNode buildOutputNode(\n  PlanNode sourcePlanNode)\n</code></pre> <p><code>buildOutputNode</code> creates a KsqlStructuredDataOutputNode or a <code>KsqlBareOutputNode</code> based on whether this is a QueryContainer or not (with a <code>Sink</code> to write into defined or not), respectively.</p> <p><code>buildOutputNode</code> is used when:</p> <ul> <li><code>LogicalPlanner</code> is requested to buildPersistentLogicalPlan and buildQueryLogicalPlan</li> </ul>"},{"location":"planner/OutputNode/","text":"<p><code>OutputNode</code> is an extension of the SingleSourcePlanNode abstraction for output nodes.</p>","title":"OutputNode"},{"location":"planner/OutputNode/#contract","text":"","title":"Contract"},{"location":"planner/OutputNode/#optional-sink-name","text":"","title":"Optional Sink Name <pre><code>Optional&lt;SourceName&gt; getSinkName()\n</code></pre> <p>The name of a stream or table (to write into)</p> <p>Used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to createStreamCommand and createTableCommand</li> <li><code>EngineExecutor</code> is requested to plan a statement, maybeCreateSinkDdl, validateExistingSink</li> <li><code>QueryIdUtil</code> is requested to <code>buildId</code></li> </ul>"},{"location":"planner/OutputNode/#implementations","text":"<ul> <li><code>KsqlBareOutputNode</code></li> <li>KsqlStructuredDataOutputNode</li> </ul>","title":"Implementations"},{"location":"planner/OutputNode/#creating-instance","text":"<p><code>OutputNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> Source PlanNode <li> <code>LogicalSchema</code> <li> Limit <li> <code>TimestampColumn</code>   <p>Abstract Class</p> <p><code>OutputNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete OutputNodes.</p>","title":"Creating Instance"},{"location":"planner/PlanNode/","text":"<p><code>PlanNode</code> is an abstraction of nodes of a query plan.</p>","title":"PlanNode"},{"location":"planner/PlanNode/#contract-abstract-methods","text":"","title":"Contract (Abstract Methods)"},{"location":"planner/PlanNode/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p>Builds a SchemaKStream</p> <p>Used when:</p> <ul> <li><code>PhysicalPlanBuilder</code> is requested to build a PhysicalPlan</li> <li>others (less important?)</li> </ul>"},{"location":"planner/PlanNode/#number-of-partitions","text":"","title":"Number of Partitions <pre><code>int getPartitions(\n  KafkaTopicClient kafkaTopicClient)\n</code></pre>"},{"location":"planner/PlanNode/#logicalschema","text":"","title":"LogicalSchema <pre><code>LogicalSchema getSchema()\n</code></pre>"},{"location":"planner/PlanNode/#sources","text":"","title":"Sources <pre><code>List&lt;PlanNode&gt; getSources()\n</code></pre>"},{"location":"planner/PlanNode/#implementations","text":"<ul> <li>DataSourceNode</li> <li>JoinNode</li> <li>SingleSourcePlanNode</li> </ul>","title":"Implementations"},{"location":"planner/PlanNode/#creating-instance","text":"<p><code>PlanNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li>DataSourceType</li> <li> Source Name   <p>Abstract Class</p> <p><code>PlanNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete PlanNodes.</p>","title":"Creating Instance"},{"location":"planner/PlanNode/#datasourcetype","text":"","title":"DataSourceType <p><code>PlanNode</code> is given a <code>DataSourceType</code> when created.</p>    DataSourceType ksqlType     KSTREAM STREAM   KTABLE TABLE"},{"location":"planner/QueryPlannerOptions/","text":"<p><code>QueryPlannerOptions</code> is...FIXME</p>","title":"QueryPlannerOptions"},{"location":"planner/SingleSourcePlanNode/","text":"<p><code>SingleSourcePlanNode</code> is an extension of the PlanNode abstraction for plan nodes with one source.</p>","title":"SingleSourcePlanNode"},{"location":"planner/SingleSourcePlanNode/#implementations","text":"<ul> <li><code>AggregateNode</code></li> <li><code>FilterNode</code></li> <li>FlatMapNode</li> <li>OutputNode</li> <li><code>PreJoinRepartitionNode</code></li> <li><code>ProjectNode</code></li> <li><code>QueryFilterNode</code></li> <li><code>QueryLimitNode</code></li> <li><code>SuppressNode</code></li> <li><code>UserRepartitionNode</code></li> </ul>","title":"Implementations"},{"location":"planner/SingleSourcePlanNode/#creating-instance","text":"<p><code>SingleSourcePlanNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> <code>DataSourceType</code> <li> Source Name <li>Source</li>   <p>Abstract Class</p> <p><code>SingleSourcePlanNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete SingleSourcePlanNodes.</p>","title":"Creating Instance"},{"location":"planner/SingleSourcePlanNode/#source-plannode","text":"","title":"Source PlanNode <p><code>SingleSourcePlanNode</code> is given a PlanNode when created.</p>"},{"location":"planner/SingleSourcePlanNode/#getsources","text":"","title":"getSources <pre><code>List&lt;PlanNode&gt; getSources()\n</code></pre> <p><code>getSources</code> returns the source.</p> <p><code>getSources</code> is part of the PlanNode abstraction.</p>"},{"location":"rest/","text":"<p><code>ksql-server-start</code> shell script is used to launch KsqlServerMain.</p> <pre><code>./bin/ksql-run-class io.confluent.ksql.rest.server.KsqlServerMain\n</code></pre> <pre><code>$ ./bin/ksql-server-start --help\nNAME\n        server - KSQL Cluster\n\nSYNOPSIS\n        server [ {-h | --help} ] [ --queries-file &lt;queriesFile&gt; ] [--]\n                &lt;config-file&gt;\n\nOPTIONS\n        -h, --help\n            Display help information\n\n        --queries-file &lt;queriesFile&gt;\n            Path to the query file on the local machine.\n\n        --\n            This option can be used to separate command-line options from the\n            list of arguments (useful when arguments might be mistaken for\n            command-line options)\n\n        &lt;config-file&gt;\n            A file specifying configs for the KSQL Server, KSQL, and its\n            underlying Kafka Streams instance(s). Refer to KSQL documentation\n            for a list of available configs.\n\n            This option may occur a maximum of 1 times\n</code></pre> <p>KsqlRestApplication creates a CommandRunner to process prior commands and then run new commands continuously (off a CommandQueue).</p>","title":"REST"},{"location":"rest/Command/","text":"","title":"Command"},{"location":"rest/Command/#creating-instance","text":"<p><code>Command</code> takes the following to be created:</p> <ul> <li> Statement Text <li> Overwrite Properties (<code>Map&lt;String, Object&gt;</code>) <li> Original Properties (<code>Map&lt;String, String&gt;</code>) <li>KsqlPlan</li> <li> Version <li> Expected Version  <p><code>Command</code> is created using of utilities and when:</p> <ul> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> </ul>","title":"Creating Instance"},{"location":"rest/Command/#ksqlplan","text":"","title":"KsqlPlan <p><code>Command</code> can be given a KsqlPlan when created (using of utility that accepts a ConfiguredKsqlPlan).</p>"},{"location":"rest/Command/#creating-command","text":"","title":"Creating Command <pre><code>Command of(\n  ConfiguredKsqlPlan configuredPlan)\nCommand of(\n  ConfiguredStatement&lt;?&gt; configuredStatement)\n</code></pre> <p><code>of</code> creates a Command.</p>  <p><code>of</code> (with a ConfiguredKsqlPlan) is used when:</p> <ul> <li><code>ValidatedCommandFactory</code> utility is used to createForPlannedQuery</li> </ul> <p><code>of</code> (with a <code>ConfiguredStatement</code>) is used when:</p> <ul> <li><code>ValidatedCommandFactory</code> utility is used to createCommand, createForAlterSystemQuery, createForTerminateQuery</li> </ul>"},{"location":"rest/CommandIdAssigner/","text":"<p><code>CommandIdAssigner</code> is...FIXME</p>","title":"CommandIdAssigner"},{"location":"rest/CommandQueue/","text":"<p><code>CommandQueue</code> is an abstraction of command queues.</p>","title":"CommandQueue"},{"location":"rest/CommandQueue/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"rest/CommandQueue/#getnewcommands","text":"","title":"getNewCommands <pre><code>List&lt;QueuedCommand&gt; getNewCommands(\n  Duration timeout)\n</code></pre> <p>Fetches <code>QueuedCommand</code>s (e.g., from a CommandTopic)</p> <p>See CommandStore</p> <p>Used when:</p> <ul> <li><code>CommandRunner</code> is requested to fetchAndRunCommands</li> </ul>"},{"location":"rest/CommandQueue/#enqueuecommand","text":"","title":"enqueueCommand <pre><code>QueuedCommandStatus enqueueCommand(\n  CommandId commandId,\n  Command command,\n  Producer&lt;CommandId, Command&gt; transactionalProducer)\n</code></pre> <p>See CommandStore</p> <p>Used when:</p> <ul> <li><code>DistributingExecutor</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/CommandQueue/#implementations","text":"<ul> <li>CommandStore</li> </ul>","title":"Implementations"},{"location":"rest/CommandRunner/","text":"","title":"CommandRunner"},{"location":"rest/CommandRunner/#creating-instance","text":"<p><code>CommandRunner</code> takes the following to be created:</p> <ul> <li> InteractiveStatementExecutor <li>CommandQueue</li> <li> <code>maxRetries</code> <li> <code>ClusterTerminator</code> <li> <code>ServerState</code> <li> ksql Service ID <li> commandRunnerHealth Timeout <li> metricsGroup Prefix <li>Command Deserializer</li> <li> Error Handler <li> <code>KafkaTopicClient</code> <li> Name of the Command Topic <li> <code>Metrics</code>  <p><code>CommandRunner</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication</li> </ul>","title":"Creating Instance"},{"location":"rest/CommandRunner/#commandqueue","text":"","title":"CommandQueue <p><code>CommandRunner</code> is given a CommandQueue when created.</p> <p>The <code>CommandQueue</code> is used when <code>CommandRunner</code> is requested for the following:</p> <ul> <li>processPriorCommands</li> <li>fetchAndRunCommands</li> </ul>"},{"location":"rest/CommandRunner/#getcommandqueue","text":"","title":"getCommandQueue <pre><code>CommandQueue getCommandQueue()\n</code></pre> <p><code>getCommandQueue</code> is used when:</p> <ul> <li><code>KsqlResource</code> is requested to configure and handleKsqlStatements</li> </ul>"},{"location":"rest/CommandRunner/#command-deserializer","text":"","title":"Command Deserializer <p><code>CommandRunner</code> is given a <code>Deserializer</code> (Apache Kafka) of Commands when created.</p> <p>The <code>Deserializer</code> is used in the following:</p> <ul> <li>processPriorCommands</li> <li>start (to fetchAndRunCommands and executeStatement)</li> </ul>"},{"location":"rest/CommandRunner/#start-processing-queued-commands","text":"","title":"Start Processing Queued Commands <pre><code>void start()\n</code></pre> <p><code>start</code> creates and starts a Java thread (on a single-threaded thread pool) to continuously fetch and run queued commands.</p> <p>Every time fetchAndRunCommands is executed, the thread prints out the following TRACE message to the logs:</p> <pre><code>Polling for new writes to command topic\n</code></pre>  <p><code>start</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> </ul>"},{"location":"rest/CommandRunner/#fetching-and-running-queued-commands","text":"","title":"Fetching and Running Queued Commands <pre><code>void fetchAndRunCommands()\n</code></pre> <p><code>fetchAndRunCommands</code> requests the CommandQueue for new commands (with <code>5 second</code> timeout).</p> <p>If there are no commands, <code>fetchAndRunCommands</code> leaves early (also checks if the commandTopicExists).</p> <p><code>fetchAndRunCommands</code> checks for incompatible commands and then tries to find TERMINATE CLUSTER command (to terminate the cluster if found).</p> <p><code>fetchAndRunCommands</code> prints out the following DEBUG message to the logs:</p> <pre><code>Found [size] new writes to command topic\n</code></pre> <p><code>fetchAndRunCommands</code> executes every command (one by one).</p>"},{"location":"rest/CommandRunner/#executing-statement","text":"","title":"Executing Statement <pre><code>void executeStatement(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>executeStatement</code> prints out the following INFO message to the logs:</p> <pre><code>Executing statement [commandId]\n</code></pre> <p><code>executeStatement</code> creates a <code>Runnable</code> (Java) that, when started, requests the InteractiveStatementExecutor to execute the command and then prints out the following INFO message to the logs:</p> <pre><code>Executed statement [commandId]\n</code></pre> <p><code>executeStatement</code> executes the command (with retries and backoff until successful).</p>"},{"location":"rest/CommandRunner/#processpriorcommands","text":"","title":"processPriorCommands <pre><code>void processPriorCommands(\n  PersistentQueryCleanupImpl queryCleanup)\n</code></pre> <p><code>processPriorCommands</code>...FIXME</p> <p><code>processPriorCommands</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> </ul>"},{"location":"rest/CommandRunner/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.rest.server.computation.CommandRunner</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.rest.server.computation.CommandRunner=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"rest/CommandStore/","text":"<p><code>CommandStore</code> is a CommandQueue that uses the CommandTopic for fetching commands.</p> <p><code>CommandStore</code> is used to create the following services while building a KsqlRestApplication:</p> <ul> <li>StreamedQueryResource</li> <li>CommandRunner</li> <li>KsqlRestApplication</li> </ul>  <p></p>","title":"CommandStore"},{"location":"rest/CommandStore/#creating-instance","text":"<p><code>CommandStore</code> takes the following to be created:</p> <ul> <li> Name of the Command Topic <li>CommandTopic</li> <li> <code>SequenceNumberFutureStore</code> <li> Kafka Consumer Properties <li> Kafka Producer Properties <li> Command Queue Catchup Timeout <li> <code>Serializer&lt;CommandId&gt;</code> <li> <code>Serializer&lt;Command&gt;</code> <li> <code>Deserializer&lt;CommandId&gt;</code> <li> <code>CommandTopicBackup</code>  <p><code>CommandStore</code> is created using Factory.create utility.</p>","title":"Creating Instance"},{"location":"rest/CommandStore/#commandtopic","text":"","title":"CommandTopic <p><code>CommandStore</code> is given a CommandTopic when created.</p> <p>The <code>CommandTopic</code> is started in start and runs until close.</p> <p>Used when:</p> <ul> <li>getNewCommands</li> <li>getCommandTopicName</li> <li>getRestoreCommands</li> <li>isEmpty</li> <li>completeSatisfiedSequenceNumberFutures</li> <li>wakeup</li> </ul>"},{"location":"rest/CommandStore/#creating-commandstore","text":"","title":"Creating CommandStore <pre><code>CommandStore create(\n  KsqlConfig ksqlConfig,\n  String commandTopicName,\n  Duration commandQueueCatchupTimeout,\n  Map&lt;String, Object&gt; kafkaConsumerProperties,\n  Map&lt;String, Object&gt; kafkaProducerProperties,\n  KafkaTopicClient internalTopicClient)\n</code></pre> <p><code>create</code> adds the following configuration properties to the given <code>kafkaConsumerProperties</code> (possibly overriding the current value if set).</p>    Configuration Property Value     <code>isolation.level</code> <code>READ_COMMITTED</code>   <code>auto.offset.reset</code> <code>none</code>    <p><code>create</code> adds the following configuration properties to the given <code>kafkaProducerProperties</code> (possibly overriding the current value if set).</p>    Configuration Property Value     <code>transactional.id</code> ksql.service.id   <code>acks</code> <code>all</code>    <p><code>create</code> creates a <code>CommandTopicBackup</code> (based on ksql.metastore.backup.location).</p> <p>In the end, <code>create</code> creates a CommandStore with the following:</p> <ul> <li>The given <code>commandTopicName</code></li> <li>A new CommandTopic</li> <li>A new <code>SequenceNumberFutureStore</code></li> <li>others</li> </ul>  <p><code>create</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication instance</li> </ul>"},{"location":"rest/CommandStore/#starting-up","text":"","title":"Starting Up <pre><code>void start()\n</code></pre> <p><code>start</code> requests the CommandTopic to start.</p>  <p><code>start</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> </ul>"},{"location":"rest/CommandStore/#enqueuecommand","text":"","title":"enqueueCommand <pre><code>QueuedCommandStatus enqueueCommand(\n  CommandId commandId,\n  Command command,\n  Producer&lt;CommandId, Command&gt; transactionalProducer)\n</code></pre> <p><code>enqueueCommand</code> is part of the CommandQueue abstraction.</p>  <p><code>enqueueCommand</code> creates a <code>ProducerRecord</code> (Apache Kafka) as follows:</p> <ul> <li>Topic: commandTopicName</li> <li>Partition: <code>0</code></li> <li>Key: the given <code>commandId</code></li> <li>Value: the given Command</li> </ul> <p><code>enqueueCommand</code> requests the given <code>transactionalProducer</code> to send the record.</p> <p><code>enqueueCommand</code> returns a <code>QueuedCommandStatus</code> with the record offset (and a <code>CommandStatusFuture</code>).</p>"},{"location":"rest/CommandStore/#fetching-new-commands","text":"","title":"Fetching New Commands <pre><code>List&lt;QueuedCommand&gt; getNewCommands(\n  Duration timeout)\n</code></pre> <p><code>getNewCommands</code> is part of the CommandQueue abstraction.</p>  <p><code>getNewCommands</code> requests the CommandTopic for new commands (<code>ConsumerRecord&lt;byte[], byte[]&gt;</code>s).</p> <p><code>getNewCommands</code> creates a <code>QueuedCommand</code> for every new command with a non-<code>null</code> value.</p> <p><code>getNewCommands</code> returns the <code>QueuedCommand</code>s.</p>"},{"location":"rest/CommandStore/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.rest.server.computation.CommandStore</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.rest.server.computation.CommandStore=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"rest/CommandStoreUtil/","text":"<p><code>CommandStoreUtil</code> is...FIXME</p>","title":"CommandStoreUtil"},{"location":"rest/CommandTopic/","text":"<p><code>CommandTopic</code> manages a KafkaConsumer to fetch new commands (for CommandStore) from the internal command topic.</p>  <p></p>   <p>Note</p> <p>KsqlRestApplication uses commandTopic utility to build the name of the command topic.</p>","title":"CommandTopic"},{"location":"rest/CommandTopic/#creating-instance","text":"<p><code>CommandTopic</code> takes the following to be created:</p> <ul> <li> Name of the internal command topic <li> <code>KafkaConsumer</code> Properties <li> <code>CommandTopicBackup</code>  <p><code>CommandTopic</code> is created when:</p> <ul> <li><code>CommandStore.Factory</code> is requested to create a CommandStore</li> </ul>","title":"Creating Instance"},{"location":"rest/CommandTopic/#kafkaconsumer","text":"","title":"KafkaConsumer <p><code>CommandTopic</code> can be given a <code>Consumer&lt;byte[], byte[]&gt;</code> or properties to create one when created.</p> <p>The <code>Consumer</code> is assigned the commandTopicPartition in start.</p> <p>The <code>Consumer</code> fetches <code>ConsumerRecord&lt;byte[], byte[]&gt;</code>s when requested for new commands.</p>"},{"location":"rest/CommandTopic/#commandtopicpartition","text":"","title":"commandTopicPartition <p><code>CommandTopic</code> creates a Kafka's <code>TopicPartition</code> for the commandTopicName and <code>0</code> partition when created.</p> <p>The <code>commandTopicPartition</code> is assigned to commandConsumer in start.</p>"},{"location":"rest/CommandTopic/#starting-up","text":"","title":"Starting Up <pre><code>void start()\n</code></pre> <p><code>start</code> requests the CommandTopicBackup to initialize.</p> <p><code>start</code> requests the KafkaConsumer to consume records from the commandTopicPartition only (using KafkaConsumer.assign).</p>  <p><code>start</code> is used when:</p> <ul> <li><code>CommandStore</code> is requested to start</li> </ul>"},{"location":"rest/CommandTopic/#fetching-new-commands","text":"","title":"Fetching New Commands <pre><code>Iterable&lt;ConsumerRecord&lt;byte[], byte[]&gt;&gt; getNewCommands(\n  Duration timeout)\n</code></pre> <p><code>getNewCommands</code> requests the commandConsumer to fetch records (<code>ConsumerRecord&lt;byte[], byte[]&gt;</code>s).</p> <p><code>getNewCommands</code> makes a backup of every record.</p>  <p><code>getNewCommands</code> is used when:</p> <ul> <li><code>CommandStore</code> is requested for new commands</li> </ul>"},{"location":"rest/CommandTopicBackup/","text":"<p><code>CommandTopicBackup</code> is...FIXME</p>","title":"CommandTopicBackup"},{"location":"rest/CustomExecutors/","text":"<p><code>CustomExecutors</code> is a collection of StatementExecutors that do not need to be distributed.</p> <p><code>CustomExecutors</code> is used by KsqlResource to create a RequestHandler (and shouldSynchronize for the <code>DefaultCommandQueueSync</code>).</p>","title":"CustomExecutors"},{"location":"rest/CustomExecutors/#executor_map","text":"","title":"EXECUTOR_MAP    Enum Name Class StatementExecutor      <code>CreateConnector</code> <code>ConnectExecutor::execute</code>    <code>DefineVariable</code> <code>VariableExecutor::set</code>    <code>DescribeConnector</code> <code>DescribeConnectorExecutor::execute</code>    <code>DescribeFunction</code> <code>DescribeFunctionExecutor::execute</code>   <code>DESCRIBE_STREAMS</code> <code>DescribeStreams</code> <code>ListSourceExecutor::describeStreams</code>   <code>DESCRIBE_TABLES</code> <code>DescribeTables</code> <code>ListSourceExecutor::describeTables</code>    <code>DropConnector</code> <code>DropConnectorExecutor::execute</code>    Explain <code>ExplainExecutor::execute</code>    <code>InsertValues</code> <code>InsertValuesExecutor::execute</code>   <code>LIST_CONNECTORS</code> <code>ListConnectors</code> <code>ListConnectorsExecutor::execute</code>   <code>LIST_CONNECTOR_PLUGINS</code> <code>ListConnectorPlugins</code> <code>ListConnectorPluginsExecutor::execute</code>   <code>LIST_FUNCTIONS</code> <code>ListFunctions</code> <code>ListFunctionsExecutor::execute</code>   <code>LIST_PROPERTIES</code> <code>ListProperties</code> <code>ListPropertiesExecutor::execute</code>   <code>LIST_QUERIES</code> <code>ListQueries</code> <code>ListQueriesExecutor::execute</code>   <code>LIST_STREAMS</code> <code>ListStreams</code> ListSourceExecutor   <code>LIST_TABLES</code> <code>ListTables</code> <code>ListSourceExecutor::tables</code>   <code>LIST_TOPICS</code> <code>ListTopics</code> <code>ListTopicsExecutor::execute</code>   <code>LIST_TYPES</code> <code>ListTypes</code> <code>ListTypesExecutor::execute</code>   <code>LIST_VARIABLES</code> <code>ListVariables</code> <code>ListVariablesExecutor::execute</code>    <code>SetProperty</code> <code>PropertyExecutor::set</code>    <code>ShowColumns</code> <code>ListSourceExecutor::columns</code>    <code>TerminateQuery</code> <code>TerminateQueryExecutor::execute</code>    <code>UndefineVariable</code> <code>VariableExecutor::unset</code>    <code>UnsetProperty</code> <code>PropertyExecutor::unset</code>"},{"location":"rest/CustomExecutors/#explain","text":"","title":"Explain <ul> <li>Explain</li> <li>ExplainExecutor</li> </ul>"},{"location":"rest/DistributingExecutor/","text":"<p>When requested to execute a statement, <code>DistributingExecutor</code> uses a transactional Kafka producer to enqueue the command (to the CommandQueue).</p>","title":"DistributingExecutor"},{"location":"rest/DistributingExecutor/#creating-instance","text":"<p><code>DistributingExecutor</code> takes the following to be created:</p> <ul> <li> KsqlConfig <li> CommandQueue <li> Distributed Command Response Timeout <li> Injector factory (for a KsqlExecutionContext and ServiceContext) <li> <code>KsqlAuthorizationValidator</code> <li> ValidatedCommandFactory <li> Error Handler <li> CommandRunner Warning (<code>Supplier&lt;String&gt;</code>)  <p><code>DistributingExecutor</code> is created when:</p> <ul> <li><code>KsqlResource</code> is requested to configure (and creates a RequestHandler)</li> </ul>","title":"Creating Instance"},{"location":"rest/DistributingExecutor/#executing-statement","text":"","title":"Executing Statement <pre><code>StatementExecutorResponse execute(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext executionContext,\n  KsqlSecurityContext securityContext)\n</code></pre> <p><code>execute</code> requests the injectorFactory to inject into the given <code>ConfiguredStatement</code>.</p> <p>For InsertIntos, <code>execute</code> validateInsertIntoQueries.</p> <p><code>execute</code> checkIfNotExistsResponse.</p> <p><code>execute</code> checkAuthorization.</p> <p><code>execute</code> requests the CommandQueue for a transactional Kafka producer (<code>Producer&lt;CommandId, Command&gt;</code> to produce to the command topic).</p> <p><code>execute</code> initialize transactions (using Kafka's Producer.initTransactions).</p> <p><code>execute</code> starts a transaction (using Kafka's Producer.beginTransaction).</p> <p><code>execute</code> requests the CommandQueue to waitForCommandConsumer (to let it process all available commands).</p> <p><code>execute</code>...FIXME</p> <p><code>execute</code> requests the CommandQueue to enqueue the command and commits the transaction (using Kafka's Producer.commitTransaction).</p> <p><code>execute</code> waits for the final status (of executing the command) distributedCmdResponseTimeout time.</p> <p>In the end, <code>execute</code> creates a <code>StatementExecutorResponse</code> (as handled) and closes the transactional Kafka producer.</p>  <p><code>execute</code> is used when:</p> <ul> <li><code>RequestHandler</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/Executable/","text":"<p><code>Executable</code> is an abstraction of executables.</p>","title":"Executable"},{"location":"rest/Executable/#contract","text":"","title":"Contract"},{"location":"rest/Executable/#awaitterminated","text":"","title":"awaitTerminated <pre><code>void awaitTerminated()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>awaitTerminated</code></li> </ul>"},{"location":"rest/Executable/#notifyterminated","text":"","title":"notifyTerminated <pre><code>void notifyTerminated()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>notifyTerminated</code></li> </ul>"},{"location":"rest/Executable/#shutdown","text":"","title":"shutdown <pre><code>void shutdown()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>shutdown</code></li> </ul>"},{"location":"rest/Executable/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>startAsync</code></li> </ul>"},{"location":"rest/Executable/#implementations","text":"<ul> <li>StandaloneExecutor</li> <li><code>MultiExecutable</code></li> <li><code>ConnectExecutable</code></li> <li>KsqlRestApplication</li> </ul>","title":"Implementations"},{"location":"rest/ExplainExecutor/","text":"<p><code>ExplainExecutor</code> is a utility to explain queries or statements.</p>","title":"ExplainExecutor"},{"location":"rest/ExplainExecutor/#executing-explain","text":"","title":"Executing Explain <pre><code>StatementExecutorResponse execute(\n  ConfiguredStatement&lt;Explain&gt; statement,\n  SessionProperties sessionProperties,\n  KsqlExecutionContext executionContext,\n  ServiceContext serviceContext)\n</code></pre> <p><code>execute</code> creates a <code>StatementExecutorResponse</code> with explain (for the given arguments).</p> <p><code>execute</code> is used when:</p> <ul> <li><code>CustomExecutors</code> is requested to handle an Explain statement</li> </ul>"},{"location":"rest/ExplainExecutor/#explaining-query-or-statement","text":"","title":"Explaining Query or Statement <pre><code>QueryDescriptionEntity explain(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Explain&gt; statement,\n  KsqlExecutionContext executionContext,\n  SessionProperties sessionProperties)\n</code></pre> <p><code>explain</code> looks up a query ID from the given <code>ConfiguredStatement</code>.</p> <p>If found, <code>explain</code> explainQuery. Otherwise, <code>explain</code> explainStatement.</p>"},{"location":"rest/ExplainExecutor/#explaining-statement","text":"","title":"Explaining Statement <pre><code>QueryDescription explainStatement(\n  ConfiguredStatement&lt;Explain&gt; explain,\n  KsqlExecutionContext executionContext,\n  ServiceContext serviceContext)\n</code></pre> <p><code>explainStatement</code>...FIXME</p>"},{"location":"rest/ExplainExecutor/#explaining-query","text":"","title":"Explaining Query <pre><code>QueryDescription explainQuery(\n  String queryId,\n  KsqlExecutionContext executionContext,\n  SessionProperties sessionProperties)\n</code></pre> <p><code>explainQuery</code>...FIXME</p>"},{"location":"rest/InteractiveStatementExecutor/","text":"","title":"InteractiveStatementExecutor"},{"location":"rest/InteractiveStatementExecutor/#creating-instance","text":"<p><code>InteractiveStatementExecutor</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlEngine <li> StatementParser <li> <code>SpecificQueryIdGenerator</code> <li> Command Deserializer  <p><code>InteractiveStatementExecutor</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to build a KsqlRestApplication (to create a CommandRunner and a <code>StatusResource</code>)</li> </ul>","title":"Creating Instance"},{"location":"rest/InteractiveStatementExecutor/#executing-queued-command","text":"","title":"Executing Queued Command <pre><code>void handleStatement(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>handleStatement</code> handles the Command (from the given <code>QueuedCommand</code> with <code>EXECUTE</code> mode).</p>  <p><code>handleStatement</code> is used when:</p> <ul> <li><code>CommandRunner</code> is requested to execute a statement</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#handlerestore","text":"","title":"handleRestore <pre><code>void handleRestore(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>handleRestore</code>...FIXME</p> <p><code>handleRestore</code> is used when:</p> <ul> <li><code>CommandRunner</code> is requested to processPriorCommands</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#executing-command","text":"","title":"Executing Command <pre><code>void handleStatementWithTerminatedQueries(\n  Command command,\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture,\n  Mode mode,\n  long offset)\n</code></pre> <p><code>handleStatementWithTerminatedQueries</code> handles the given Command based on whether it has a KsqlPlan or just a statement.</p>  <p><code>handleStatementWithTerminatedQueries</code> is used when:</p> <ul> <li><code>InteractiveStatementExecutor</code> is requested to handleStatement (with <code>EXECUTE</code> mode) and handleRestore (with <code>RESTORE</code> mode)</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#ksqlplan","text":"","title":"KsqlPlan <p>If the given Command has a KsqlPlan, <code>handleStatementWithTerminatedQueries</code> executes the KsqlPlan.</p>"},{"location":"rest/InteractiveStatementExecutor/#statement","text":"","title":"Statement <p><code>handleStatementWithTerminatedQueries</code> puts PARSING status.</p> <p><code>handleStatementWithTerminatedQueries</code> requests the StatementParser to parse the statement (from the command).</p> <p><code>handleStatementWithTerminatedQueries</code> puts EXECUTING status.</p> <p><code>handleStatementWithTerminatedQueries</code> executeStatement.</p>"},{"location":"rest/InteractiveStatementExecutor/#executing-ksqlplan","text":"","title":"Executing KsqlPlan <pre><code>void executePlan(\n  Command command,\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture,\n  KsqlPlan plan,\n  Mode mode,\n  long offset,\n  boolean restoreInProgress)\n</code></pre> <p><code>executePlan</code> builds merged config.</p> <p><code>executePlan</code> puts EXECUTING status for the command with the message:</p> <pre><code>Executing statement\n</code></pre> <p><code>executePlan</code> requests the KsqlEngine to execute the given KsqlPlan.</p> <p><code>executePlan</code> increments <code>queryIdGenerator</code> internal counter.</p> <p>If this is a QueryMetadata and the given mode is <code>EXECUTE</code>, <code>executePlan</code> requests the query to start.</p> <p>In the end, <code>executePlan</code> puts SUCCESS final status with the command result or the following message:</p> <pre><code>Created query with ID [queryId]\n</code></pre>"},{"location":"rest/InteractiveStatementExecutor/#executing-statement","text":"","title":"Executing Statement <pre><code>void executeStatement(\n  PreparedStatement&lt;?&gt; statement,\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture)\n</code></pre> <p><code>executeStatement</code> branches off based on the type of the statement.</p>"},{"location":"rest/InteractiveStatementExecutor/#terminatequery","text":"","title":"TerminateQuery <p>For TerminateQuery, <code>executeStatement</code> terminateQuery and puts SUCCESS final status with the following message:</p> <pre><code>Query terminated.\n</code></pre>"},{"location":"rest/InteractiveStatementExecutor/#executableddlstatement","text":"","title":"ExecutableDdlStatement <p>For ExecutableDdlStatement, <code>executeStatement</code> throwUnsupportedStatementError.</p>"},{"location":"rest/InteractiveStatementExecutor/#createasselect","text":"","title":"CreateAsSelect <p>For CreateAsSelect, <code>executeStatement</code> throwUnsupportedStatementError.</p>"},{"location":"rest/InteractiveStatementExecutor/#insertinto","text":"","title":"InsertInto <p>For InsertInto, <code>executeStatement</code> throwUnsupportedStatementError.</p>"},{"location":"rest/InteractiveStatementExecutor/#altersystemproperty","text":"","title":"AlterSystemProperty <p>For AlterSystemProperty, <code>executeStatement</code> requests the KsqlExecutionContext to alterSystemProperty and then to updateStreamsPropertiesAndRestartRuntime.</p> <p>In the end, <code>executeStatement</code> puts SUCCESS final status with the following message:</p> <pre><code>System property [name] was set to [value].\n</code></pre>"},{"location":"rest/InteractiveStatementExecutor/#other-types","text":"","title":"Other Types <p>For all other types, <code>executeStatement</code> throws a <code>KsqlException</code>:</p> <pre><code>Unexpected statement type: [className]\n</code></pre>"},{"location":"rest/InteractiveStatementExecutor/#putfinalstatus","text":"","title":"putFinalStatus <pre><code>void putFinalStatus(\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture,\n  CommandStatus status)\n</code></pre> <p><code>putFinalStatus</code> associates the given <code>CommandStatus</code> with the <code>CommandId</code> (in statusStore registry).</p> <p>If the given <code>CommandStatusFuture</code> is available, <code>putFinalStatus</code> sets its final status.</p>  <p><code>putFinalStatus</code> is used when:</p> <ul> <li><code>InteractiveStatementExecutor</code> is requested to execute a command (KsqlPlan or Statement)</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.rest.server.computation.InteractiveStatementExecutor</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.rest.server.computation.InteractiveStatementExecutor=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"rest/InternalKsqlClientFactory/","text":"<p><code>InternalKsqlClientFactory</code> is...FIXME</p>","title":"InternalKsqlClientFactory"},{"location":"rest/KsqlConfigurable/","text":"<p><code>KsqlConfigurable</code> is an abstraction of configurable services (of a ksqlDB API server instance).</p>","title":"KsqlConfigurable"},{"location":"rest/KsqlConfigurable/#contract","text":"","title":"Contract"},{"location":"rest/KsqlConfigurable/#configuring-service","text":"","title":"Configuring Service <pre><code>void configure(\n  KsqlConfig config)\n</code></pre> <p>Configures this service with the given KsqlConfig</p> <p>Used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to startAsync</li> </ul>"},{"location":"rest/KsqlConfigurable/#implementations","text":"<ul> <li><code>InteractiveStatementExecutor</code></li> <li>KsqlResource</li> <li><code>StreamedQueryResource</code></li> </ul>","title":"Implementations"},{"location":"rest/KsqlResource/","text":"<p><code>KsqlResource</code> is used by KsqlRestApplication to execute statements (indirectly using KsqlServerEndpoints).</p>","title":"KsqlResource"},{"location":"rest/KsqlResource/#creating-instance","text":"<p><code>KsqlResource</code> takes the following to be created:</p> <ul> <li> KsqlEngine <li> CommandRunner <li> <code>distributedCmdResponse</code> Timeout <li> <code>ActivenessRegistrar</code> <li> Injector factory <li> <code>KsqlAuthorizationValidator</code> <li> <code>Errors</code> Handlers <li> <code>DenyListPropertyValidator</code> <li> CommandRunner warning message  <p><code>KsqlResource</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication (and creates a KsqlRestApplication)</li> </ul>","title":"Creating Instance"},{"location":"rest/KsqlResource/#configure","text":"","title":"configure <pre><code>void configure(\n  KsqlConfig config)\n</code></pre> <p><code>configure</code> is part of the KsqlConfigurable abstraction.</p>  <p><code>configure</code>...FIXME</p>"},{"location":"rest/KsqlResource/#shouldsynchronize","text":"","title":"shouldSynchronize <pre><code>boolean shouldSynchronize(\n  Class&lt;? extends Statement&gt; statementClass)\n</code></pre> <p><code>shouldSynchronize</code> is <code>true</code> when the given <code>statementClass</code> is as follows:</p> <ol> <li>Not in SYNC_BLACKLIST</li> <li>In EXECUTOR_MAP</li> </ol>  <p><code>shouldSynchronize</code> is used when:</p> <ul> <li><code>KsqlResource</code> is requested to configure (and creates a <code>DefaultCommandQueueSync</code> for the RequestHandler)</li> </ul>"},{"location":"rest/KsqlResource/#sync_blacklist","text":"","title":"SYNC_BLACKLIST <ul> <li><code>ListTopics</code></li> <li><code>ListFunctions</code></li> <li><code>DescribeFunction</code></li> <li><code>ListProperties</code></li> <li><code>SetProperty</code></li> <li><code>UnsetProperty</code></li> </ul>"},{"location":"rest/KsqlResource/#requesthandler","text":"","title":"RequestHandler <p><code>KsqlResource</code> creates a RequestHandler when requested to configure.</p> <p><code>RequestHandler</code> is used when:</p> <ul> <li>terminateCluster</li> <li>handleKsqlStatements</li> </ul>"},{"location":"rest/KsqlResource/#handling-statements","text":"","title":"Handling Statements <pre><code>EndpointResponse handleKsqlStatements(\n  KsqlSecurityContext securityContext,\n  KsqlRequest request)\n</code></pre> <p><code>handleKsqlStatements</code> prints out the following INFO message to the logs:</p> <pre><code>Received: [request]\n</code></pre> <p><code>handleKsqlStatements</code> requests the KsqlEngine to parse the SQL text (from the given <code>KsqlRequest</code>).</p> <p><code>handleKsqlStatements</code> requests the RequestValidator to validate the statements (in a <code>SandboxedServiceContext</code>).</p> <p><code>handleKsqlStatements</code> requests the RequestHandler to execute the SQL statements.</p> <p>In the end, <code>handleKsqlStatements</code> prints out the following INFO message to the logs:</p> <pre><code>Processed successfully: [request]\n</code></pre>  <p><code>handleKsqlStatements</code> is used when:</p> <ul> <li><code>KsqlServerEndpoints</code> is requested to execute a KsqlRequest</li> <li><code>ServerInternalKsqlClient</code> is requested to <code>makeKsqlRequest</code></li> </ul>"},{"location":"rest/KsqlResource/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.rest.server.resources.KsqlResource</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.rest.server.resources.KsqlResource=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"rest/KsqlRestApplication/","text":"<p><code>KsqlRestApplication</code> is a ksqlDB REST API server.</p> <p><code>KsqlRestApplication</code> can be started using ksql-server-start shell script.</p>","title":"KsqlRestApplication"},{"location":"rest/KsqlRestApplication/#creating-instance","text":"<p><code>KsqlRestApplication</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlEngine <li> KsqlConfig <li> KsqlRestConfig <li>CommandRunner</li> <li> CommandStore <li> <code>StatusResource</code> <li> <code>StreamedQueryResource</code> <li>KsqlResource</li> <li> VersionCheckerAgent <li> <code>KsqlSecurityContextProvider</code> <li> <code>KsqlSecurityExtension</code> <li> <code>AuthenticationPlugin</code> <li> <code>ServerState</code> <li> <code>ProcessingLogContext</code> <li> <code>KsqlServerPrecondition</code>s <li>KsqlConfigurables</li> <li> RocksDB Config Setter Handler (Function of KsqlConfig) <li> <code>HeartbeatAgent</code> <li> <code>LagReportingAgent</code> <li> Vert.x <li> <code>DenyListPropertyValidator</code> <li> <code>PullQueryExecutorMetrics</code> <li> <code>ScalablePushQueryMetrics</code> <li> <code>LocalCommands</code> <li> QueryExecutor   <p>When created, <code>KsqlRestApplication</code> prints out the following DEBUG message to the logs:</p> <pre><code>Creating instance of ksqlDB API server\n</code></pre> <p>In the end, <code>KsqlRestApplication</code> prints out the following DEBUG message to the logs:</p> <pre><code>ksqlDB API server instance created\n</code></pre>  <p><code>KsqlRestApplication</code> is created using buildApplication utility.</p>","title":"Creating Instance"},{"location":"rest/KsqlRestApplication/#ksqlresource","text":"","title":"KsqlResource <p><code>KsqlRestApplication</code> is given a KsqlResource when created.</p> <p><code>KsqlResource</code> is used to create a KsqlServerEndpoints upon starting.</p> <p><code>KsqlResource</code> is also used to maybeCreateProcessingLogStream upon initializing.</p>"},{"location":"rest/KsqlRestApplication/#commandrunner","text":"","title":"CommandRunner <p><code>KsqlRestApplication</code> is given a CommandRunner when created.</p> <p>The <code>CommandRunner</code> is requested to processPriorCommands followed by starting command execution in initialize. The <code>CommandRunner</code> is up and running until shutdown (when it is requested to close).</p> <p>The <code>CommandRunner</code> is used to create a HealthCheckResource when <code>KsqlRestApplication</code> is created.</p>"},{"location":"rest/KsqlRestApplication/#ksqlconfigurables","text":"","title":"KsqlConfigurables <p><code>KsqlRestApplication</code> is given KsqlConfigurables when created.</p> <p>All the given KsqlConfigurables are also given separately to create the <code>KsqlRestApplication</code>:</p> <ul> <li>KsqlResource</li> <li>StreamedQueryResource</li> <li><code>InteractiveStatementExecutor</code> (that is part of the StatusResource)</li> </ul> <p><code>KsqlConfigurable</code>s are requested to configure (with a KsqlConfig with an application.server property assigned) in startAsync.</p>"},{"location":"rest/KsqlRestApplication/#building-ksqlrestapplication","text":"","title":"Building KsqlRestApplication <pre><code>KsqlRestApplication buildApplication(\n  KsqlRestConfig restConfig,\n  MetricCollectors metricCollectors)\nKsqlRestApplication buildApplication(\n  String metricsPrefix,\n  KsqlRestConfig restConfig,\n  ServerState serverState,\n  Function&lt;Supplier&lt;Boolean&gt;, VersionCheckerAgent&gt; versionCheckerFactory,\n  int maxStatementRetries,\n  ServiceContext serviceContext,\n  Supplier&lt;SchemaRegistryClient&gt; schemaRegistryClientFactory,\n  ConnectClientFactory connectClientFactory,\n  Vertx vertx,\n  KsqlClient sharedClient,\n  DefaultServiceContextFactory defaultServiceContextFactory,\n  UserServiceContextFactory userServiceContextFactory,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildApplication</code> is used when:</p> <ul> <li><code>KsqlServerMain</code> is requested for an Executable</li> </ul>"},{"location":"rest/KsqlRestApplication/#step-1-vertx","text":"","title":"Step 1. Vert.x <p><code>buildApplication</code> creates a Vert.x subsystem.</p>  <p>Vert.x</p> <p>Vert.x allows writing reactive applications on the JVM with support for HTTP, TCP, UDP, file system, asynchronous streams. etc.</p>  <p><code>buildApplication</code> creates an internal KsqlClient.</p> <p><code>buildApplication</code> creates a <code>KsqlSchemaRegistryClientFactory</code> and <code>DefaultConnectClientFactory</code>.</p> <p><code>buildApplication</code> determines the Kafka Cluster ID and reads the ksql.service.id configuration property (from the KsqlConfig).</p> <p><code>buildApplication</code> creates a KsqlRestConfig.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> creates a KsqlEngine.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> builds the name of the command topic (to create a CommandStore and a CommandRunner).</p> <p><code>buildApplication</code> creates a CommandStore.</p>"},{"location":"rest/KsqlRestApplication/#step-x-interactivestatementexecutor","text":"","title":"Step x. InteractiveStatementExecutor <p><code>buildApplication</code> creates an InteractiveStatementExecutor.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> creates a QueryExecutor and a <code>StreamedQueryResource</code>.</p>"},{"location":"rest/KsqlRestApplication/#step-x-commandrunner","text":"","title":"Step x. CommandRunner <p><code>buildApplication</code> creates a CommandRunner (with the InteractiveStatementExecutor).</p> <p><code>buildApplication</code>...FIXME</p>"},{"location":"rest/KsqlRestApplication/#step-x-ksqlrestapplication","text":"","title":"Step x. KsqlRestApplication <p>In the end, <code>buildApplication</code> creates a KsqlRestApplication.</p>"},{"location":"rest/KsqlRestApplication/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p><code>startAsync</code> is part of the Executable abstraction.</p>  <p><code>startAsync</code> prints out the following DEBUG message to the logs:</p> <pre><code>Starting the ksqlDB API server\n</code></pre> <p><code>startAsync</code> creates a ServerMetadataResource.</p> <p><code>startAsync</code> creates a StatementParser (with the KsqlEngine).</p> <p><code>startAsync</code>...FIXME</p> <p><code>startAsync</code> creates a Server and starts it.</p> <p><code>startAsync</code>...FIXME</p> <p>In the end, <code>startAsync</code> prints out the following INFO message to the logs followed by displayWelcomeMessage.</p> <pre><code>ksqlDB API server listening on [comma-separated listeners]\n</code></pre>"},{"location":"rest/KsqlRestApplication/#displaywelcomemessage","text":"","title":"displayWelcomeMessage <pre><code>void displayWelcomeMessage()\n</code></pre> <p><code>displayWelcomeMessage</code>...FIXME</p> <p>In the end, <code>displayWelcomeMessage</code> prints out the following to the standard output:</p> <pre><code>Server [version] listening on [comma-separated listeners]\n\nTo access the KSQL CLI, run:\nksql [listener]\n</code></pre>"},{"location":"rest/KsqlRestApplication/#startksql","text":"","title":"startKsql <pre><code>void startKsql(\n  KsqlConfig ksqlConfigWithPort)\n</code></pre> <p><code>startKsql</code> cleanupOldState and then initialize (with the given KsqlConfig).</p>"},{"location":"rest/KsqlRestApplication/#initializing","text":"","title":"Initializing <pre><code>void initialize(\n  KsqlConfig configWithApplicationServer)\n</code></pre> <p><code>initialize</code> executes the rocksDBConfigSetterHandler with the ksqlConfigNoPort.</p> <p><code>initialize</code> registerCommandTopic.</p> <p><code>initialize</code> requests the CommandStore to start.</p> <p><code>initialize</code> maybeCreateProcessingLogTopic with the following:</p> <ul> <li>Shared KafkaTopicClient</li> <li>ProcessingLogConfig</li> <li>ksqlConfigNoPort</li> </ul> <p><code>initialize</code> requests the CommandRunner to processPriorCommands (with a new <code>PersistentQueryCleanupImpl</code>).</p> <p><code>initialize</code> requests the CommandRunner to start processing commands.</p> <p><code>initialize</code> maybeCreateProcessingLogStream.</p> <p><code>initialize</code> starts the heartbeatAgent and the lagReportingAgent agents (if specified).</p> <p>In the end, <code>initialize</code> changes the ServerState to <code>READY</code>.</p>"},{"location":"rest/KsqlRestApplication/#registercommandtopic","text":"","title":"registerCommandTopic <pre><code>void registerCommandTopic()\n</code></pre> <p><code>registerCommandTopic</code> requests the CommandStore for the name of the command topic.</p> <p><code>registerCommandTopic</code> makes sure that the internal command topic is available in the Kafka cluster and in sync with backup (if configured).</p> <p><code>registerCommandTopic</code> creates the command topic if not exists.</p>"},{"location":"rest/KsqlRestApplication/#maybecreateprocessinglogstream","text":"","title":"maybeCreateProcessingLogStream <pre><code>void maybeCreateProcessingLogStream(\n  ProcessingLogConfig processingLogConfig,\n  KsqlConfig ksqlConfig,\n  KsqlRestConfig restConfig,\n  KsqlResource ksqlResource,\n  ServiceContext serviceContext)\n</code></pre> <p><code>maybeCreateProcessingLogStream</code> does nothing and returns immediately when ksql.logging.processing.stream.auto.create is turned off (<code>false</code>).</p> <p><code>maybeCreateProcessingLogStream</code>...FIXME</p>"},{"location":"rest/KsqlRestApplication/#logging","text":"","title":"Logging <p>Enable <code>ALL</code> logging level for <code>io.confluent.ksql.rest.server.KsqlRestApplication</code> logger to see what happens inside.</p> <p>Add the following line to <code>log4j.properties</code>:</p> <pre><code>log4j.logger.io.confluent.ksql.rest.server.KsqlRestApplication=ALL\n</code></pre> <p>Refer to Logging.</p>"},{"location":"rest/KsqlRestConfig/","text":"","title":"KsqlRestConfig"},{"location":"rest/KsqlRestConfig/#listeners","text":"","title":"listeners"},{"location":"rest/KsqlRestConfig/#ksqlverticleinstances","text":"","title":"ksql.verticle.instances <p>The number of server verticle instances to start per listener.</p> <p>Default: Twice as much as the number of available CPU cores</p> <p>Must be at least <code>1</code></p> <p>Recommended: at least as many instances as there are CPU cores to use, as each instance is single-threaded.</p> <p>Used when:</p> <ul> <li><code>Server</code> is requested to start</li> <li><code>PreconditionServer</code> is requested to <code>start</code></li> </ul>"},{"location":"rest/KsqlServerEndpoints/","text":"<p><code>KsqlServerEndpoints</code> is an Endpoints.</p>","title":"KsqlServerEndpoints"},{"location":"rest/KsqlServerEndpoints/#creating-instance","text":"<p><code>KsqlServerEndpoints</code> takes the following to be created:</p> <ul> <li>KsqlEngine</li> <li> KsqlConfig <li> <code>KsqlSecurityContextProvider</code> <li>KsqlResource</li> <li>StreamedQueryResource</li> <li> <code>ServerInfoResource</code> <li> <code>HeartbeatResource</code> <li> <code>ClusterStatusResource</code> <li> <code>StatusResource</code> <li> <code>LagReportingResource</code> <li> <code>HealthCheckResource</code> <li> <code>ServerMetadataResource</code> <li> <code>WSQueryEndpoint</code> <li> <code>PullQueryExecutorMetrics</code> <li> QueryExecutor <li> <code>KsqlAuthTokenProvider</code>  <p><code>KsqlServerEndpoints</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to startAsync</li> </ul>","title":"Creating Instance"},{"location":"rest/KsqlServerEndpoints/#ksqlengine","text":"","title":"KsqlEngine <p><code>KsqlServerEndpoints</code> is given a KsqlEngine when created.</p> <p>The <code>KsqlEngine</code> is used when:</p> <ul> <li>createQueryPublisher (to create a QueryEndpoint)</li> <li>createInsertsSubscriber (to create a <code>InsertsStreamEndpoint</code>)</li> </ul>"},{"location":"rest/KsqlServerEndpoints/#ksqlresource","text":"","title":"KsqlResource <p><code>KsqlServerEndpoints</code> is given a KsqlResource when created.</p> <p><code>KsqlResource</code> is used when:</p> <ul> <li>Executing ksqlRequest</li> <li>executeTerminate</li> <li>executeIsValidProperty</li> </ul>"},{"location":"rest/KsqlServerEndpoints/#streamedqueryresource","text":"","title":"StreamedQueryResource <p><code>KsqlServerEndpoints</code> is given a StreamedQueryResource when created.</p> <p>The <code>StreamedQueryResource</code> is used to executeQueryRequest.</p>"},{"location":"rest/KsqlServerEndpoints/#creating-querypublisher","text":"","title":"Creating QueryPublisher <pre><code>CompletableFuture&lt;QueryPublisher&gt; createQueryPublisher(\n  String sql,\n  Map&lt;String, Object&gt; properties,\n  Map&lt;String, Object&gt; sessionVariables,\n  Map&lt;String, Object&gt; requestProperties,\n  Context context,\n  WorkerExecutor workerExecutor,\n  ApiSecurityContext apiSecurityContext,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Optional&lt;Boolean&gt; isInternalRequest)\n</code></pre> <p><code>createQueryPublisher</code> is part of the Endpoints abstraction.</p>  <p><code>createQueryPublisher</code> executes the following on the given <code>WorkerExecutor</code>:</p> <ul> <li>Create a QueryEndpoint to createQueryPublisher</li> </ul>"},{"location":"rest/KsqlServerEndpoints/#executeisvalidproperty","text":"","title":"executeIsValidProperty <pre><code>CompletableFuture&lt;EndpointResponse&gt; executeIsValidProperty(\n  String property,\n  WorkerExecutor workerExecutor,\n  ApiSecurityContext apiSecurityContext)\n</code></pre> <p><code>executeIsValidProperty</code> is part of the Endpoints abstraction.</p>  <p><code>executeIsValidProperty</code> requests the KsqlResource to isValidProperty.</p>"},{"location":"rest/KsqlServerEndpoints/#executeksqlrequest","text":"","title":"executeKsqlRequest <pre><code>CompletableFuture&lt;EndpointResponse&gt; executeKsqlRequest(\n  KsqlRequest request,\n  WorkerExecutor workerExecutor,\n  ApiSecurityContext apiSecurityContext)\n</code></pre> <p><code>executeKsqlRequest</code> is part of the Endpoints abstraction.</p>  <p><code>executeKsqlRequest</code> requests the KsqlResource to handle statements.</p>"},{"location":"rest/KsqlServerEndpoints/#executequeryrequest","text":"","title":"executeQueryRequest <pre><code>CompletableFuture&lt;EndpointResponse&gt; executeQueryRequest(\n  KsqlRequest request,\n  WorkerExecutor workerExecutor,\n  CompletableFuture&lt;Void&gt; connectionClosedFuture,\n  ApiSecurityContext apiSecurityContext,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  KsqlMediaType mediaType,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Context context)\n</code></pre> <p><code>executeQueryRequest</code> is part of the Endpoints abstraction.</p>  <p><code>executeQueryRequest</code> requests the StreamedQueryResource to streamQuery.</p>"},{"location":"rest/KsqlServerEndpoints/#executeterminate","text":"","title":"executeTerminate <pre><code>CompletableFuture&lt;EndpointResponse&gt; executeTerminate(\n  ClusterTerminateRequest request,\n  WorkerExecutor workerExecutor,\n  ApiSecurityContext apiSecurityContext)\n</code></pre> <p><code>executeTerminate</code> is part of the Endpoints abstraction.</p>  <p><code>executeTerminate</code> requests the KsqlResource to terminateCluster.</p>"},{"location":"rest/KsqlServerMain/","text":"<p><code>KsqlServerMain</code> is the ksqlDB server that can be started on command line using ksql-server-start shell script.</p> <p><code>KsqlServerMain</code> starts an Executable:</p> <ol> <li>StandaloneExecutor with queries file specified</li> <li>KsqlRestApplication unless ksql.connect.worker.config configuration property is specified</li> <li><code>MultiExecutable</code> with a <code>ConnectExecutable</code> and the KsqlRestApplication</li> </ol> <p><code>KsqlServerMain</code> supports command-line options.</p>","title":"KsqlServerMain"},{"location":"rest/KsqlServerMain/#creating-instance","text":"<p><code>KsqlServerMain</code> takes the following to be created:</p> <ul> <li> <code>PreconditionChecker</code> <li> Executable factory <li> Shutdown Handler  <p><code>KsqlServerMain</code> is created when:</p> <ul> <li><code>KsqlServerMain</code> application is launched</li> </ul>","title":"Creating Instance"},{"location":"rest/KsqlServerMain/#launching-application","text":"","title":"Launching Application <p><code>main</code> parses the command-line options and loads the required properties file (with the Java system properties applied overriding earlier values).</p> <p><code>main</code> creates and validates a KsqlConfig.</p> <p><code>main</code> configures QueryLogger (with the <code>KsqlConfig</code>).</p> <p><code>main</code> creates an Executable based on the following:</p> <ol> <li>Properties with the Java system properties applied</li> <li>queries file command-line option (if defined)</li> <li><code>ksql.server.install.dir</code> configuration property from the properties file</li> <li>A new KsqlConfig with the config and system properties</li> <li>A new <code>MetricCollectors</code></li> </ol> <p><code>main</code> creates a new KsqlServerMain (with the <code>Executable</code>) and starts it up.</p>  <p>Note</p> <p><code>main</code> is paused when starting up the executable (using awaitTerminated) until notifyTerminated which happens as part of a Java Virtual Machine shutdown hook.</p>"},{"location":"rest/KsqlServerMain/#creating-executable","text":"","title":"Creating Executable <pre><code>Executable createExecutable(\n  Map&lt;String, String&gt; properties,\n  Optional&lt;String&gt; queriesFile,\n  String installDir,\n  KsqlConfig ksqlConfig,\n  MetricCollectors metricCollectors)\n</code></pre> <p>With queries file specified, <code>createExecutable</code> returns a new StandaloneExecutor.</p> <p>Otherwise, <code>createExecutable</code> creates a KsqlRestConfig (with the given <code>properties</code>) to build a KsqlRestApplication (with the <code>KsqlRestConfig</code> and the given <code>MetricCollectors</code>).</p> <p>With no ksql.connect.worker.config configuration property specified, <code>createExecutable</code> returns the <code>KsqlRestApplication</code>. Otherwise, <code>createExecutable</code> creates a <code>ConnectExecutable</code> and returns a <code>MultiExecutable</code> (with the <code>ConnectExecutable</code> and the <code>KsqlRestApplication</code>).</p>"},{"location":"rest/KsqlServerMain/#trystartapp","text":"","title":"tryStartApp <pre><code>void tryStartApp()\n</code></pre> <p><code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Starting server\n</code></pre> <p><code>tryStartApp</code> requests the Executable to startAsync.</p> <p><code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Server up and running\n</code></pre> <p><code>tryStartApp</code> requests the Executable to awaitTerminated.</p> <p>Finally (when the Executable was requested to terminate), <code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Server shutting down\n</code></pre> <p><code>tryStartApp</code> requests the Executable to shutdown.</p>"},{"location":"rest/ListSourceExecutor/","text":"<p><code>ListSourceExecutor</code> is a CustomExecutors to handle the following statements:</p> <ul> <li>LIST_STREAMS</li> <li>others</li> </ul>","title":"ListSourceExecutor"},{"location":"rest/ListSourceExecutor/#streams","text":"","title":"streams <pre><code>StatementExecutorResponse streams(\n  ConfiguredStatement&lt;ListStreams&gt; statement,\n  SessionProperties sessionProperties,\n  KsqlExecutionContext executionContext,\n  ServiceContext serviceContext)\n</code></pre> <p><code>streams</code> getSpecificStreams.</p> <p><code>streams</code>...FIXME</p>  <p><code>streams</code> is used when:</p> <ul> <li><code>CustomExecutors</code> is requested for the LIST_STREAMS enum</li> </ul>"},{"location":"rest/ProcessingLogConfig/","text":"<p><code>ProcessingLogConfig</code> is a <code>AbstractConfig</code> (Apache Kafka) with the server properties of the Processing Log (with ksql.logging.processing prefix).</p>","title":"ProcessingLogConfig"},{"location":"rest/ProcessingLogConfig/#topicautocreate","text":"","title":"topic.auto.create <p>ksql.logging.processing.topic.auto.create enables automatic processing log topic creation.</p> <p>If <code>true</code>, a processing log topic is created when the ksqlDB server starts up.</p>    Topic Config Value     Name ksql.logging.processing.topic.name   Number of partitions ksql.logging.processing.topic.partitions   Replication factor ksql.logging.processing.topic.replication.factor    <p>Default: <code>false</code></p> <p>Used when:</p> <ul> <li><code>ProcessingLogServerUtils</code> is requested to maybeCreateProcessingLogTopic</li> <li><code>KsqlRestApplication</code> is requested to build an application</li> </ul>"},{"location":"rest/ProcessingLogContext/","text":"<p><code>ProcessingLogContext</code> is...FIXME</p>","title":"ProcessingLogContext"},{"location":"rest/ProcessingLogServerUtils/","text":"","title":"ProcessingLogServerUtils"},{"location":"rest/ProcessingLogServerUtils/#maybecreateprocessinglogtopic","text":"","title":"maybeCreateProcessingLogTopic <pre><code>Optional&lt;String&gt; maybeCreateProcessingLogTopic(\n  KafkaTopicClient topicClient,\n  ProcessingLogConfig config,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>maybeCreateProcessingLogTopic</code>...FIXME</p>  <p><code>maybeCreateProcessingLogTopic</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> <li><code>StandaloneExecutor</code> is requested to startAsync</li> </ul>"},{"location":"rest/QueryEndpoint/","text":"<p><code>QueryEndpoint</code> is created and requested to createQueryPublisher for KsqlServerEndpoints (when requested to createQueryPublisher).</p>","title":"QueryEndpoint"},{"location":"rest/QueryEndpoint/#creating-instance","text":"<p><code>QueryEndpoint</code> takes the following to be created:</p> <ul> <li> KsqlEngine <li> KsqlConfig <li> <code>PullQueryExecutorMetrics</code> <li> QueryExecutor  <p><code>QueryEndpoint</code> is created when:</p> <ul> <li><code>KsqlServerEndpoints</code> is requested to createQueryPublisher</li> </ul>","title":"Creating Instance"},{"location":"rest/QueryEndpoint/#createquerypublisher","text":"","title":"createQueryPublisher <pre><code>QueryPublisher createQueryPublisher(\n  String sql,\n  Map&lt;String, Object&gt; properties,\n  Map&lt;String, Object&gt; sessionVariables,\n  Map&lt;String, Object&gt; requestProperties,\n  Context context,\n  WorkerExecutor workerExecutor,\n  ServiceContext serviceContext,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Optional&lt;Boolean&gt; isInternalRequest)\n</code></pre> <p><code>createQueryPublisher</code> createStatement.</p> <p><code>createQueryPublisher</code> requests the QueryExecutor to handleStatement.</p> <p><code>createQueryPublisher</code>...FIXME</p>  <p><code>createQueryPublisher</code> is used when:</p> <ul> <li><code>KsqlServerEndpoints</code> is requested to createQueryPublisher</li> </ul>"},{"location":"rest/QueryExecutor/","text":"","title":"QueryExecutor"},{"location":"rest/QueryExecutor/#creating-instance","text":"<p><code>QueryExecutor</code> takes the following to be created:</p> <ul> <li> KsqlEngine <li> <code>KsqlRestConfig</code> <li> KsqlConfig <li> <code>PullQueryExecutorMetrics</code> <li> <code>ScalablePushQueryMetrics</code> <li> <code>RateLimiter</code> <li> <code>ConcurrencyLimiter</code> <li> <code>SlidingWindowRateLimiter</code> <li> <code>SlidingWindowRateLimiter</code> <li>HARouting</li> <li> <code>PushRouting</code> <li> <code>LocalCommands</code>  <p><code>QueryExecutor</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication</li> </ul>","title":"Creating Instance"},{"location":"rest/QueryExecutor/#harouting","text":"","title":"HARouting <p><code>QueryExecutor</code> is given a HARouting when created.</p> <p>The <code>HARouting</code> is used to handleTablePullQuery (for the KsqlExecutionContext to executeTablePullQuery).</p>"},{"location":"rest/QueryExecutor/#handling-statement","text":"","title":"Handling Statement <pre><code>QueryMetadataHolder handleStatement(\n  ServiceContext serviceContext,\n  Map&lt;String, Object&gt; configOverrides,\n  Map&lt;String, Object&gt; requestProperties,\n  PreparedStatement&lt;?&gt; statement,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Context context,\n  boolean excludeTombstones)\n</code></pre> <p>For a Query statement, <code>handleStatement</code> handles it. Otherwise, <code>handleStatement</code> returns an empty <code>QueryMetadataHolder</code>.</p>  <p><code>handleStatement</code> is used when:</p> <ul> <li><code>QueryEndpoint</code> is requested to createQueryPublisher</li> <li><code>StreamedQueryResource</code> is requested to <code>handleStatement</code></li> <li><code>WSQueryEndpoint</code> is requested to <code>handleStatement</code></li> </ul>"},{"location":"rest/QueryExecutor/#handling-query","text":"","title":"Handling Query <pre><code>QueryMetadataHolder handleQuery(\n  ServiceContext serviceContext,\n  PreparedStatement&lt;Query&gt; statement,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Map&lt;String, Object&gt; configOverrides,\n  Map&lt;String, Object&gt; requestProperties,\n  Context context,\n  boolean excludeTombstones)\n</code></pre>"},{"location":"rest/QueryExecutor/#pull-query","text":"","title":"Pull Query <p>For a pull query, <code>handleQuery</code> requests the KsqlEngine to analyzeQueryWithNoOutputTopic (that gives an ImmutableAnalysis).</p> <p>With ksql.pull.queries.enable disabled, <code>handleQuery</code> throws a <code>KsqlStatementException</code>:</p> <pre><code>Pull queries are disabled.\n</code></pre> <p><code>handleQuery</code> determines a <code>ConsistencyOffsetVector</code> based on ksql.query.pull.consistency.token.enabled in the KsqlConfig and the given <code>requestProperties</code>.</p> <p>For a <code>KTABLE</code> data source (<code>FROM</code> clause), <code>handleQuery</code> handleTablePullQuery.</p> <p>For a <code>KSTREAM</code> data source (<code>FROM</code> clause), <code>handleQuery</code> handleStreamPullQuery.</p>"},{"location":"rest/QueryExecutor/#scalable-push-query","text":"","title":"Scalable Push Query <p>For a scalable push query, <code>handleQuery</code> requests the KsqlEngine to analyzeQueryWithNoOutputTopic (that gives an ImmutableAnalysis).</p> <p><code>handleQuery</code> prints out the following INFO message to the logs:</p> <pre><code>Scalable push query created\n</code></pre> <p><code>handleQuery</code> handleScalablePushQuery.</p>"},{"location":"rest/QueryExecutor/#transient-query","text":"","title":"Transient Query <p>Otherwise, <code>handleQuery</code> prints out the following INFO message to the logs and handlePushQuery.</p> <pre><code>Transient query created\n</code></pre>"},{"location":"rest/QueryExecutor/#handlepushquery","text":"","title":"handlePushQuery <pre><code>QueryMetadataHolder handlePushQuery(\n  ServiceContext serviceContext,\n  PreparedStatement&lt;Query&gt; statement,\n  Map&lt;String, Object&gt; streamsProperties,\n  boolean excludeTombstones)\n</code></pre> <p><code>handlePushQuery</code>...FIXME</p>"},{"location":"rest/QueryExecutor/#handlescalablepushquery","text":"","title":"handleScalablePushQuery <pre><code>QueryMetadataHolder handleScalablePushQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  PreparedStatement&lt;Query&gt; statement,\n  Map&lt;String, Object&gt; configOverrides,\n  Map&lt;String, Object&gt; requestProperties,\n  Context context,\n  SlidingWindowRateLimiter scalablePushBandRateLimiter,\n  AtomicReference&lt;ScalablePushQueryMetadata&gt; resultForMetrics)\n</code></pre> <p><code>handleScalablePushQuery</code>...FIXME</p> <p><code>handleScalablePushQuery</code> requests the KsqlEngine to execute a scalable push query.</p> <p><code>handleScalablePushQuery</code>...FIXME</p> <p>In the end, <code>handleScalablePushQuery</code> prints out the following INFO message to the logs:</p> <pre><code>Streaming scalable push query\n</code></pre>  <p><code>handleScalablePushQuery</code> is used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handle a query</li> </ul>"},{"location":"rest/QueryExecutor/#handlestreampullquery","text":"","title":"handleStreamPullQuery <pre><code>QueryMetadataHolder handleStreamPullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; configured,\n  AtomicReference&lt;StreamPullQueryMetadata&gt; resultForMetrics,\n  AtomicReference&lt;Decrementer&gt; refDecrementer)\n</code></pre> <p>Most importantly, <code>handleStreamPullQuery</code> requests the KsqlExecutionContext to create a stream pull query (that gives a <code>StreamPullQueryMetadata</code> to be returned inside a <code>QueryMetadataHolder</code>).</p>  <p><code>handleStreamPullQuery</code> requests the RateLimiter to <code>checkLimit</code>.</p> <p><code>handleStreamPullQuery</code> requests the pullBandRateLimiter to allow a PULL query.</p> <p><code>handleStreamPullQuery</code> requests the KsqlExecutionContext to createStreamPullQuery (that gives a <code>StreamPullQueryMetadata</code>).</p> <p><code>handleStreamPullQuery</code> requests the LocalCommands (if defined) to <code>write</code> the <code>TransientQueryMetadata</code>.</p> <p>In the end, <code>handleStreamPullQuery</code> gives a <code>QueryMetadataHolder</code> with the <code>StreamPullQueryMetadata</code>.</p>  <p><code>handleStreamPullQuery</code> is used to handle a stream pull query.</p>"},{"location":"rest/QueryExecutor/#handletablepullquery","text":"","title":"handleTablePullQuery <pre><code>QueryMetadataHolder handleTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; configured,\n  Map&lt;String, Object&gt; requestProperties,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  SlidingWindowRateLimiter pullBandRateLimiter,\n  AtomicReference&lt;PullQueryResult&gt; resultForMetrics,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>handleTablePullQuery</code> creates a <code>PullQueryConfigRoutingOptions</code> and a <code>PullQueryConfigPlannerOptions</code>.</p> <p>In the end, <code>handleTablePullQuery</code> requests the KsqlEngine to executeTablePullQuery.</p>"},{"location":"rest/RequestHandler/","text":"","title":"RequestHandler"},{"location":"rest/RequestHandler/#creating-instance","text":"<p><code>RequestHandler</code> takes the following to be created:</p> <ul> <li> CustomExecutors <li>DistributingExecutor</li> <li>KsqlEngine</li> <li> <code>CommandQueueSync</code>  <p><code>RequestHandler</code> is created when:</p> <ul> <li><code>KsqlResource</code> is requested to configure</li> </ul>","title":"Creating Instance"},{"location":"rest/RequestHandler/#ksqlengine","text":"","title":"KsqlEngine <p><code>RequestHandler</code> is given a KsqlEngine when created.</p> <p>The <code>KsqlEngine</code> is used for executing SQL Statements (to execute a Statement and isVariableSubstitutionEnabled).</p>"},{"location":"rest/RequestHandler/#distributingexecutor","text":"","title":"DistributingExecutor <p><code>RequestHandler</code> is given a DistributingExecutor when created.</p> <p>The <code>DistributingExecutor</code> is used for executing SQL statements.</p>"},{"location":"rest/RequestHandler/#executing-sql-statements-execute","text":"","title":"Executing SQL Statements (execute) <pre><code>KsqlEntityList execute(\n  KsqlSecurityContext securityContext,\n  List&lt;ParsedStatement&gt; statements,\n  SessionProperties sessionProperties)\n</code></pre> <p>For every SQL statement (in the given <code>statements</code>), <code>execute</code> requests the KsqlEngine to prepare it for execution (possibly with variable substitution) and then executes it.</p> <p><code>execute</code> is used when:</p> <ul> <li><code>KsqlResource</code> is requested to handle a REST request to execute SQL statements and terminate the cluster</li> </ul>"},{"location":"rest/RequestHandler/#executing-statement","text":"","title":"Executing Statement <pre><code>&lt;T extends Statement&gt; Optional&lt;KsqlEntity&gt; executeStatement(\n  KsqlSecurityContext securityContext,\n  PreparedStatement&lt;T&gt; prepared,\n  SessionProperties sessionProperties,\n  KsqlEntityList entities)\n</code></pre> <p><code>executeStatement</code> requests the given <code>PreparedStatement</code> for the Statement and its Java class that is used to request the CommandQueueSync to <code>waitFor</code>.</p> <p><code>executeStatement</code> creates a <code>ConfiguredStatement</code> for the given <code>PreparedStatement</code> (with a new <code>SessionConfig</code>).</p> <p><code>executeStatement</code> looks up the StatementExecutor for the <code>Statement</code> class in the CustomExecutors registry (or defaults to the DistributingExecutor to execute the statement).</p> <p><code>executeStatement</code> requests the <code>StatementExecutor</code> to execute the statement.</p> <p>Unless handled, <code>executeStatement</code> requests the DistributingExecutor to execute the statement.</p>"},{"location":"rest/RequestHandler/#isvariablesubstitutionenabled","text":"","title":"isVariableSubstitutionEnabled <pre><code>boolean isVariableSubstitutionEnabled(\n  SessionProperties sessionProperties)\n</code></pre> <p><code>isVariableSubstitutionEnabled</code> is positive (<code>true</code>) when ksql.variable.substitution.enable is <code>true</code> in the given <code>SessionProperties</code> or the KsqlConfig (of the KsqlEngine).</p>"},{"location":"rest/RequestValidator/","text":"<p><code>RequestValidator</code> is...FIXME</p>","title":"RequestValidator"},{"location":"rest/ReservedInternalTopics/","text":"","title":"ReservedInternalTopics"},{"location":"rest/ReservedInternalTopics/#creating-instance","text":"<p><code>ReservedInternalTopics</code> takes the following to be created:</p> <ul> <li> KsqlConfig  <p><code>ReservedInternalTopics</code> is created mainly alongside a KsqlServerEndpoints and a DistributingExecutor but also when:</p> <ul> <li><code>InsertValuesExecutor</code> is requested to <code>getDataSource</code></li> <li><code>ListTopicsExecutor</code> is requested to <code>listTopics</code></li> </ul>","title":"Creating Instance"},{"location":"rest/ReservedInternalTopics/#internal-ksqldb-topics","text":"","title":"Internal ksqlDB Topics"},{"location":"rest/ReservedInternalTopics/#command-topic","text":"","title":"Command Topic <pre><code>String commandTopic(\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>commandTopic</code> builds the name of a ksqlDB internal topic with <code>command_topic</code> topic suffix:</p> <pre><code>_confluent-ksql-[ksql.service.id]_command_topic\n</code></pre>  <p><code>commandTopic</code> is used when:</p> <ul> <li><code>HealthCheckAgent.KafkaBrokerCheck</code> is requested to <code>check</code></li> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication (and creates a CommandStore)</li> <li><code>KsqlRestoreCommandTopic</code> is created</li> </ul>"},{"location":"rest/ReservedInternalTopics/#configs-topic","text":"","title":"Configs Topic <pre><code>String configsTopic(\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>configsTopic</code> builds the name of a ksqlDB internal topic with <code>configs</code> topic suffix:</p> <pre><code>_confluent-ksql-[ksql.service.id]_configs\n</code></pre> <p><code>configsTopic</code> is used when:</p> <ul> <li><code>StandaloneExecutorFactory</code> utility is used to create a StandaloneExecutor</li> </ul>"},{"location":"rest/ReservedInternalTopics/#toksqlinternaltopic","text":"","title":"toKsqlInternalTopic <pre><code>String toKsqlInternalTopic(\n  KsqlConfig ksqlConfig,\n  String topicSuffix)\n</code></pre> <p><code>toKsqlInternalTopic</code> builds a name (of a ksqlDB internal topic) in the following format (based on the ksql.service.id in the given KsqlConfig and the given <code>topicSuffix</code>):</p> <pre><code>_confluent-ksql-[ksql.service.id]_[topicSuffix]\n</code></pre> <p><code>toKsqlInternalTopic</code> is used when:</p> <ul> <li><code>ReservedInternalTopics</code> utility is used for commandTopic and configsTopic</li> </ul>"},{"location":"rest/RestServiceContextFactory/","text":"<p><code>RestServiceContextFactory</code> is...FIXME</p>","title":"RestServiceContextFactory"},{"location":"rest/ScalablePushUtil/","text":"<p><code>ScalablePushUtil</code> is...FIXME</p>","title":"ScalablePushUtil"},{"location":"rest/ServerOptions/","text":"<p><code>ServerOptions</code> is used to handle the command-line options of KsqlServerMain.</p> <p><code>ServerOptions</code> uses Airline annotation-driven Java library for building Command Line Interfaces (CLIs).</p>","title":"ServerOptions"},{"location":"rest/ServerOptions/#properties-file","text":"","title":"Properties File <p>(required) A file with the configuration properties for the KSQL Server, KSQL, and underlying Kafka Streams instances.</p>"},{"location":"rest/ServerOptions/#query-file","text":"","title":"Query File <p>A path to a query file on the local machine.</p> <p>A query file can be specified using the following (in the order of precedence):</p> <ol> <li><code>--queries-file</code> command-line option</li> <li><code>ksql.queries.file</code> Java property</li> </ol>"},{"location":"rest/StandaloneExecutor/","text":"<p><code>StandaloneExecutor</code> is an Executable for headless execution mode.</p>","title":"StandaloneExecutor"},{"location":"rest/StandaloneExecutor/#creating-instance","text":"<p><code>StandaloneExecutor</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> <code>ProcessingLogConfig</code> <li> KsqlConfig <li> KsqlEngine <li> Queries File <li> UserFunctionLoader <li> <code>failOnNoQueries</code> flag <li> VersionCheckerAgent <li> <code>injectorFactory</code> function <code>BiFunction&lt;KsqlExecutionContext, ServiceContext, Injector&gt;</code> <li> <code>MetricCollectors</code>  <p><code>StandaloneExecutor</code> is created when:</p> <ul> <li><code>StandaloneExecutorFactory</code> utility is used to create a StandaloneExecutor</li> </ul>","title":"Creating Instance"},{"location":"rest/StandaloneExecutor/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p><code>startAsync</code> requests the UserFunctionLoader to load.</p> <p><code>startAsync</code> maybeCreateProcessingLogTopic.</p> <p>With <code>stream.auto.create</code> enabled, <code>startAsync</code> prints out the following WARN message to the logs:</p> <pre><code>processing log auto-create is enabled, but this is not supported for headless mode.\n</code></pre> <p><code>startAsync</code> reads the queriesFile to process.</p> <p><code>startAsync</code> showWelcomeMessage.</p> <p>In the end, <code>startAsync</code> requests the VersionCheckerAgent to start (with the <code>SERVER</code> module type and non-null configuration properties of the KsqlConfig).</p>  <p><code>startAsync</code> is part of the Executable abstraction.</p>"},{"location":"rest/StandaloneExecutor/#loading-queries-file","text":"","title":"Loading Queries File <pre><code>String readQueriesFile(\n  String queryFilePath)\n</code></pre> <p><code>readQueriesFile</code> reads the given <code>queryFilePath</code> with <code>UTF_8</code> encoding.</p>"},{"location":"rest/StandaloneExecutor/#processing-queries","text":"","title":"Processing Queries <pre><code>void processesQueryFile(\n  String queries)\n</code></pre> <p><code>processesQueryFile</code> requests the KsqlEngine to parse the SQL queries (into a collection of <code>ParsedStatement</code>s).</p> <p><code>processesQueryFile</code> validates the ParsedStatements.</p> <p><code>processesQueryFile</code> uses the injectorFactory to create an <code>Injector</code> (with the KsqlEngine and the ServiceContext).</p> <p><code>processesQueryFile</code>...FIXME</p>"},{"location":"rest/StandaloneExecutor/#validating-parsedstatements","text":"","title":"Validating ParsedStatements <pre><code>void validateStatements(\n  List&lt;ParsedStatement&gt; statements)\n</code></pre> <p><code>validateStatements</code> requests the KsqlEngine to create a SandboxedExecutionContext (with the ServiceContext).</p> <p><code>validateStatements</code> uses the injectorFactory to create an <code>Injector</code> (with the SandboxedExecutionContext and its ServiceContext).</p> <p><code>validateStatements</code> creates a StatementExecutor to execute the ParsedStatements.</p> <p>In the end, if failOnNoQueries and there was no QueryContainer, <code>validateStatements</code> throws a <code>KsqlException</code>:</p> <pre><code>The SQL file does not contain any persistent queries.\ni.e. it contains no 'INSERT INTO', 'CREATE TABLE x AS SELECT' or\n'CREATE STREAM x AS SELECT' style statements.\n</code></pre>"},{"location":"rest/StandaloneExecutor/#executing-statements","text":"","title":"Executing Statements <pre><code>boolean executeStatements(\n  List&lt;ParsedStatement&gt; statements,\n  StatementExecutor executor)\n</code></pre> <p><code>executeStatements</code> requests the given StatementExecutor to execute the given <code>ParsedStatement</code>s one by one.</p> <p>In the end, <code>executeStatements</code> returns whether there was a <code>ParsedStatement</code> with a query.</p> <p><code>executeStatements</code> is used when:</p> <ul> <li><code>StandaloneExecutor</code> is requested to processes a query file and validate statements</li> </ul>"},{"location":"rest/StandaloneExecutorFactory/","text":"","title":"StandaloneExecutorFactory"},{"location":"rest/StandaloneExecutorFactory/#creating-standaloneexecutor","text":"","title":"Creating StandaloneExecutor <pre><code>StandaloneExecutor create(\n  Map&lt;String, String&gt; properties,\n  String queriesFile,\n  String installDir)\n</code></pre> <p><code>create</code>...FIXME</p> <p><code>create</code> is used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to createExecutable (with a queries file)</li> </ul>"},{"location":"rest/StandaloneExecutor_StatementExecutor/","text":"<p><code>StatementExecutor</code> is a <code>private static final class</code> of StandaloneExecutor with statement handlers.</p>","title":"StatementExecutor"},{"location":"rest/StandaloneExecutor_StatementExecutor/#creating-instance","text":"<p><code>StatementExecutor</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlExecutionContext <li> <code>Injector</code> <li> KsqlConfig  <p><code>StatementExecutor</code> is created when:</p> <ul> <li><code>StandaloneExecutor</code> is requested to processesQueryFile and validateStatements</li> </ul>","title":"Creating Instance"},{"location":"rest/StandaloneExecutor_StatementExecutor/#statement-handlers","text":"","title":"Statement Handlers <p><code>StatementExecutor</code> creates <code>HANDLERS</code> collection of handlers (functions) of Statements.</p>    SQL Statement Class Handler      SET <code>SetProperty</code> <code>StatementExecutor::handleSetProperty</code>   UNSET <code>UnsetProperty</code> <code>StatementExecutor::handleUnsetProperty</code>   CREATE STREAM CreateStream <code>StatementExecutor::handleExecutableDdl</code>   CREATE TABLE <code>CreateTable</code> <code>StatementExecutor::handleExecutableDdl</code>   REGISTER TYPE <code>RegisterType</code> <code>StatementExecutor::handleExecutableDdl</code>    CREATE STREAM AS SELECT <code>CreateStreamAsSelect</code> handlePersistentQuery    CREATE TABLE AS SELECT <code>CreateTableAsSelect</code> handlePersistentQuery    INSERT INTO InsertInto handlePersistentQuery    <p>The <code>HANDLERS</code> is used in execute and generateSupportedMessage.</p>"},{"location":"rest/StandaloneExecutor_StatementExecutor/#handlepersistentquery","text":"","title":"handlePersistentQuery <pre><code>void handlePersistentQuery(\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>handlePersistentQuery</code> requests the KsqlExecutionContext to execute the given statement (in the ServiceContext) to produce a QueryMetadata.</p> <p><code>handlePersistentQuery</code> makes sure that the <code>QueryMetadata</code> is a <code>PersistentQueryMetadata</code> or throws a <code>KsqlStatementException</code>:</p> <pre><code>Could not build the query\n</code></pre> <p><code>handlePersistentQuery</code> is used when:</p> <ul> <li><code>StatementExecutor</code> is requested to handle CREATE STREAM AS SELECT, CREATE TABLE AS SELECT and INSERT INTO SQL statements</li> </ul>"},{"location":"rest/StatementExecutor/","text":"<p><code>StatementExecutor</code> is an abstraction of executors of Statements.</p> <p><code>StatementExecutor</code> is a <code>FunctionalInterface</code> (Java).</p>","title":"StatementExecutor"},{"location":"rest/StatementExecutor/#contract","text":"","title":"Contract"},{"location":"rest/StatementExecutor/#executing-statement","text":"","title":"Executing Statement <pre><code>StatementExecutorResponse execute(\n  ConfiguredStatement&lt;T&gt; statement,\n  SessionProperties sessionProperties,\n  KsqlExecutionContext executionContext,\n  ServiceContext serviceContext)\n</code></pre> <p>Used when:</p> <ul> <li><code>CustomExecutors</code> is requested to execute</li> <li><code>RequestHandler</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/StatementExecutor/#implementations","text":"<ul> <li>many</li> </ul>","title":"Implementations"},{"location":"rest/StatementParser/","text":"<p><code>StatementParser</code> is...FIXME</p>","title":"StatementParser"},{"location":"rest/StreamedQueryResource/","text":"","title":"StreamedQueryResource"},{"location":"rest/StreamedQueryResource/#creating-instance","text":"<p><code>StreamedQueryResource</code> takes the following to be created:</p> <ul> <li> KsqlExecutionContext <li> KsqlRestConfig <li> StatementParser <li>CommandQueue</li> <li> <code>disconnectCheckInterval</code> <li> <code>commandQueueCatchupTimeout</code> <li> <code>ActivenessRegistrar</code> <li> <code>KsqlAuthorizationValidator</code> <li> <code>Errors</code> handler <li> <code>DenyListPropertyValidator</code> <li> QueryExecutor  <p><code>StreamedQueryResource</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to build a KsqlRestApplication</li> </ul>","title":"Creating Instance"},{"location":"rest/StreamedQueryResource/#commandqueue","text":"","title":"CommandQueue <p><code>StreamedQueryResource</code> is given a CommandQueue when created.</p> <p>The <code>CommandQueue</code> is used to httpWaitForCommandSequenceNumber when streamQuery.</p>"},{"location":"rest/StreamedQueryResource/#streamquery","text":"","title":"streamQuery <pre><code>EndpointResponse streamQuery(\n  KsqlSecurityContext securityContext,\n  KsqlRequest request,\n  CompletableFuture&lt;Void&gt; connectionClosedFuture,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Context context)\n</code></pre> <p><code>streamQuery</code> requests the ActivenessRegistrar to <code>updateLastRequestTime</code>.</p> <p><code>streamQuery</code> parseStatement the given <code>KsqlRequest</code> (into a <code>PreparedStatement</code>).</p> <p><code>streamQuery</code> httpWaitForCommandSequenceNumber (with the commandQueue, the given <code>KsqlRequest</code>, and the commandQueueCatchupTimeout).</p> <p>In the end, <code>streamQuery</code> handles the ksql statement.</p>  <p><code>streamQuery</code> is used when:</p> <ul> <li><code>KsqlServerEndpoints</code> is requested to executeQueryRequest</li> </ul>"},{"location":"rest/StreamedQueryResource/#parsestatement","text":"","title":"parseStatement <pre><code>PreparedStatement&lt;?&gt; parseStatement(\n  KsqlRequest request)\n</code></pre> <p><code>parseStatement</code> requests the StatementParser to parse the ksql statement (from the given <code>KsqlRequest</code>).</p>"},{"location":"rest/StreamedQueryResource/#handlestatement","text":"","title":"handleStatement <pre><code>EndpointResponse handleStatement(\n  KsqlSecurityContext securityContext,\n  KsqlRequest request,\n  PreparedStatement&lt;?&gt; statement,\n  CompletableFuture&lt;Void&gt; connectionClosedFuture,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Context context)\n</code></pre> <p><code>handleStatement</code> handles Query and PrintTopic statements only.</p>  <p><code>handleStatement</code> requests the KsqlAuthorizationValidator to <code>checkAuthorization</code> (if defined).</p> <p><code>handleStatement</code> requests the DenyListPropertyValidator to <code>validateAll</code> the config overrides (from the given <code>KsqlRequest</code>).</p>"},{"location":"rest/StreamedQueryResource/#query","text":"","title":"Query <p>For a Query statement, <code>handleStatement</code> requests the QueryExecutor to handle the statement and then handleQuery.</p>"},{"location":"rest/StreamedQueryResource/#printtopic","text":"","title":"PrintTopic <p>For a <code>PrintTopic</code> statement, <code>handleStatement</code> handlePrintTopic.</p>"},{"location":"rest/StreamedQueryResource/#handlequery","text":"","title":"handleQuery <pre><code>EndpointResponse handleQuery(\n  PreparedStatement&lt;Query&gt; statement,\n  CompletableFuture&lt;Void&gt; connectionClosedFuture,\n  QueryMetadataHolder queryMetadataHolder)\n</code></pre> <p><code>handleQuery</code> handles pull and push queries (and uses the given <code>QueryMetadataHolder</code> to determine the type).</p> <p>For a pull query, <code>handleQuery</code> requests the given <code>QueryMetadataHolder</code> for the <code>PullQueryResult</code> and returns a new <code>PullQueryStreamWriter</code> in response.</p> <p>For a push query, <code>handleQuery</code> requests the given <code>QueryMetadataHolder</code> for the <code>PushQueryMetadata</code> and returns a new <code>QueryStreamWriter</code> in response.</p> <p>For other types, <code>handleQuery</code> responds with <code>400 Bad Request</code> error code and the following message:</p> <pre><code>Statement type `className' not supported for this resource\n</code></pre>"},{"location":"rest/ValidatedCommandFactory/","text":"<p><code>ValidatedCommandFactory</code> is a collection of utilities to create validated commands (that are safe to enqueue onto the command queue).</p>","title":"ValidatedCommandFactory"},{"location":"rest/ValidatedCommandFactory/#creating-validated-command","text":"","title":"Creating Validated Command <pre><code>Command create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\nCommand create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context\n</code></pre> <p><code>create</code> creates a Command.</p> <p><code>create</code>...FIXME</p>  <p><code>create</code> is used when:</p> <ul> <li><code>DistributingExecutor</code> is requested to execute a statement</li> <li><code>RequestValidator</code> is requested to validate</li> </ul>"},{"location":"rest/ValidatedCommandFactory/#creating-command","text":"","title":"Creating Command <pre><code>Command create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\nCommand create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context\n</code></pre> <p><code>createCommand</code>...FIXME</p>"},{"location":"rest/ValidatedCommandFactory/#createforaltersystemquery","text":"","title":"createForAlterSystemQuery <pre><code>Command createForAlterSystemQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForAlterSystemQuery</code>...FIXME</p>"},{"location":"rest/ValidatedCommandFactory/#createforplannedquery","text":"","title":"createForPlannedQuery <pre><code>Command createForPlannedQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForPlannedQuery</code> requests the given KsqlExecutionContext to plan a DDL/DML statement (that gives a KsqlPlan).</p> <p><code>createForPlannedQuery</code> creates a ConfiguredKsqlPlan.</p> <p><code>createForPlannedQuery</code>...FIXME</p>"},{"location":"rest/ValidatedCommandFactory/#createforterminatequery","text":"","title":"createForTerminateQuery <pre><code>Command createForTerminateQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForTerminateQuery</code> assumes that the given <code>statement</code> is a <code>TerminateQuery</code>.</p> <p><code>createForTerminateQuery</code> handles the following cases:</p> <ol> <li>No <code>queryId</code> defined to close all the running persistent queries</li> <li><code>queryId</code>s with the <code>transient_</code> query name prefix</li> <li>Non-<code>CREATE_SOURCE</code> persistent queries</li> </ol>  <p>With no <code>queryId</code> defined, <code>createForTerminateQuery</code> requests all the running persistent queries (in the given KsqlExecutionContext) to close and returns a Command with the given <code>statement</code>.</p> <p>For a <code>queryId</code> that contains the <code>transient_</code> query name prefix, <code>createForTerminateQuery</code> returns a Command with the given <code>statement</code>.</p> <p>For all the other <code>queryId</code>s, <code>createForTerminateQuery</code> looks up the query (in the given KsqlExecutionContext) to close it.</p> <p>In the end, <code>createForTerminateQuery</code> returns a Command with the given <code>statement</code>.</p>  <p><code>createForTerminateQuery</code> throws a <code>KsqlStatementException</code> for <code>CREATE_SOURCE</code> queries:</p> <pre><code>Cannot terminate query '[queryId]' because it is linked to a source table.\n</code></pre>"},{"location":"types/SqlBaseType/","text":"<p><code>SqlBaseType</code> is a collection (enum) of built-in SQL data types in ksqlDB:</p> <ul> <li><code>ARRAY</code></li> <li><code>BIGINT</code></li> <li><code>BOOLEAN</code></li> <li><code>BYTES</code></li> <li><code>DATE</code></li> <li><code>DECIMAL</code></li> <li><code>DOUBLE</code></li> <li><code>INTEGER</code></li> <li><code>MAP</code></li> <li><code>STRING</code></li> <li><code>STRUCT</code></li> <li><code>TIME</code></li> <li><code>TIMESTAMP</code></li> </ul>","title":"SqlBaseType"},{"location":"types/SqlBaseType/#numeric-types","text":"","title":"Numeric Types <pre><code>boolean isNumber()\n</code></pre> <p><code>isNumber</code> is <code>true</code> when this <code>SqlBaseType</code> is one of the following:</p> <ul> <li><code>INTEGER</code></li> <li><code>BIGINT</code></li> <li><code>DECIMAL</code></li> <li><code>DOUBLE</code></li> </ul>"},{"location":"types/SqlBaseType/#time-types","text":"","title":"Time Types <pre><code>boolean isTime()\n</code></pre> <p><code>isTime</code> is <code>true</code> when this <code>SqlBaseType</code> is one of the following:</p> <ul> <li><code>TIME</code></li> <li><code>DATE</code></li> <li><code>TIMESTAMP</code></li> </ul>"},{"location":"types/SqlPrimitiveType/","text":"<p><code>SqlPrimitiveType</code> is a SqlType.</p>","title":"SqlPrimitiveType"},{"location":"types/SqlPrimitiveType/#primitive-types","text":"","title":"Primitive Types <ul> <li><code>ARRAY</code></li> <li><code>BIGINT</code></li> <li><code>BOOLEAN</code></li> <li><code>BYTES</code></li> <li><code>DATE</code></li> <li><code>DECIMAL</code></li> <li><code>DOUBLE</code></li> <li><code>INTEGER</code></li> <li><code>INT</code></li> <li><code>MAP</code></li> <li><code>STRING</code></li> <li><code>STRUCT</code></li> <li><code>TIMESTAMP</code></li> <li><code>TIME</code></li> <li><code>VARCHAR</code></li> </ul>"},{"location":"types/SqlPrimitiveType/#demo","text":"","title":"Demo <pre><code>import io.confluent.ksql.schema.ksql.types._\nval string = SqlPrimitiveType.of(SqlBaseType.STRING)\nassert(string.toString == \"STRING\")\n</code></pre>"},{"location":"types/SqlType/","text":"<p><code>SqlType</code> is an abstraction of SQL types.</p>","title":"SqlType"},{"location":"types/SqlType/#contract","text":"","title":"Contract"},{"location":"types/SqlType/#tostring","text":"","title":"toString <pre><code>String toString(\n  FormatOptions formatOptions)\n</code></pre> <p>Used when:</p> <ul> <li><code>Column</code> is requested to toString</li> <li><code>SqlTypeSchemaSerializer</code> is requested to serialize a SqlType</li> <li><code>FilterTypeValidator</code> is requested to <code>validateFilterExpression</code></li> <li><code>ExpressionFormatter.Formatter</code> is requested to <code>visitType</code></li> <li><code>QueryEndpoint</code> is requested to colTypesFromSchema</li> </ul>"},{"location":"types/SqlType/#implementations","text":"<ul> <li><code>SqlArray</code></li> <li><code>SqlDecimal</code></li> <li><code>SqlMap</code></li> <li>SqlPrimitiveType</li> <li><code>SqlStruct</code></li> </ul>","title":"Implementations"},{"location":"types/SqlType/#creating-instance","text":"<p><code>SqlType</code> takes the following to be created:</p> <ul> <li> SqlBaseType   <p>Abstract Class</p> <p><code>SqlType</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete SqlTypes.</p>","title":"Creating Instance"},{"location":"types/SqlType/#sqltypeschemaserializer","text":"","title":"SqlTypeSchemaSerializer <p><code>SqlType</code> is serialized using SqlTypeSchemaSerializer.</p>"},{"location":"udf/Column/","text":"<p><code>Column</code> is...FIXME</p>","title":"Column"},{"location":"udf/SqlTypeSchemaSerializer/","text":"<p><code>SqlTypeSchemaSerializer</code> is...FIXME</p>","title":"SqlTypeSchemaSerializer"}]}