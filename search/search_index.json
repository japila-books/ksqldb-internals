{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p>Welcome to The Internals of ksqlDB online book! \ud83e\udd19</p> <p>I'm Jacek Laskowski, an IT freelancer specializing in Apache Spark, Delta Lake, Apache Kafka and Kafka Streams (with brief forays into a wider data engineering space, e.g. Trino and ksqlDB, mostly during Warsaw Data Engineering meetups).</p> <p>I'm very excited to have you here and hope you will enjoy exploring the internals of ksqlDB as much as I have.</p>  <p>Flannery O'Connor</p> <p>I write to discover what I know.</p>   \"The Internals Of\" series <p>I'm also writing other online books in the \"The Internals Of\" series. Please visit \"The Internals Of\" Online Books home page.</p>  <p>Expect text and code snippets from a variety of public sources. Attribution follows.</p> <p>Now, let's take a deep dive into ksqlDB \ud83d\udd25</p>  <p>Last update: 2021-12-26</p>","title":"The Internals of ksqlDB 0.23.1"},{"location":"Analysis/","text":"<p><code>Analysis</code> is an ImmutableAnalysis.</p>","title":"Analysis"},{"location":"Analysis/#creating-instance","text":"<p><code>Analysis</code> takes the following to be created:</p> <ul> <li> <code>RefinementInfo</code> <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> <code>pullLimitClauseEnabled</code> flag  <p><code>Analysis</code> is created when:</p> <ul> <li><code>Analyzer.Visitor</code> is created</li> </ul>","title":"Creating Instance"},{"location":"Analysis/#selectitems","text":"","title":"SelectItems <p><code>Analysis</code> defines <code>joinInfo</code> registry of <code>JoinInfo</code>s that are added in addJoin.</p>"},{"location":"Analysis/#addselectitem","text":"","title":"addSelectItem <pre><code>void addSelectItem(\n  SelectItem selectItem)\n</code></pre> <p><code>addSelectItem</code> adds the given <code>SelectItem</code> to the selectItems registry.</p> <p><code>addSelectItem</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitSelect</li> </ul>"},{"location":"Analysis/#getselectitems","text":"","title":"getSelectItems <pre><code>List&lt;SelectItem&gt; getSelectItems()\n</code></pre> <p><code>getSelectItems</code> returns the selectItems.</p> <p><code>getSelectItems</code> is part of the ImmutableAnalysis abstraction.</p>"},{"location":"Analysis/#joininfos","text":"","title":"JoinInfos <p><code>Analysis</code> defines <code>joinInfo</code> registry of <code>JoinInfo</code>s that are added in addJoin.</p>"},{"location":"Analysis/#addjoin","text":"","title":"addJoin <pre><code>void addJoin(\n  JoinInfo joinInfo)\n</code></pre> <p><code>addJoin</code> adds the given <code>JoinInfo</code> to the joinInfo registry.</p> <p><code>addJoin</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitJoinedSource</li> </ul>"},{"location":"Analysis/#isjoin","text":"","title":"isJoin <pre><code>boolean isJoin()\n</code></pre> <p><code>isJoin</code> is <code>true</code> when there is a <code>JoinInfo</code> in the joinInfo registry.</p> <p><code>isJoin</code> is part of the ImmutableAnalysis abstraction.</p>"},{"location":"Analysis/#adddatasource","text":"","title":"addDataSource <pre><code>void addDataSource(\n  SourceName alias,\n  DataSource dataSource)\n</code></pre> <p><code>addDataSource</code>...FIXME</p> <p><code>addDataSource</code> is used when:</p> <ul> <li><code>Analyzer.Visitor</code> is requested to visitAliasedRelation</li> </ul>"},{"location":"Analyzer/","text":"","title":"Analyzer"},{"location":"Analyzer/#creating-instance","text":"<p><code>Analyzer</code> takes the following to be created:</p> <ul> <li> MetaStore <li> Topic Prefix <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> ksql.query.pull.limit.clause.enabled configuration property  <p><code>Analyzer</code> is created when:</p> <ul> <li><code>QueryAnalyzer</code> is created</li> </ul> <p></p>","title":"Creating Instance"},{"location":"Analyzer/#query-analysis","text":"","title":"Query Analysis <pre><code>Analysis analyze(\n  Query query,\n  Optional&lt;Sink&gt; sink)\n</code></pre> <p><code>analyze</code> creates a Visitor (for the given Query and a flag to indicate whether the sink is defined or not for persistent queries).</p> <p><code>analyze</code> requests the <code>Visitor</code> to process the given <code>Query</code> and analyzeNonStdOutSink if the sink is defined.</p> <p><code>analyze</code> requests the <code>Visitor</code> to validate the analysis.</p> <p>In the end, <code>analyze</code> requests the the <code>Visitor</code> for the Analysis.</p> <p><code>analyze</code> is used when:</p> <ul> <li><code>QueryAnalyzer</code> is requested to analyze a query</li> </ul>"},{"location":"Analyzer/#visitor","text":"","title":"Visitor <p><code>Visitor</code> is a DefaultTraversalVisitor to produce an <code>AstNode</code> that <code>Analyzer</code> uses to analyze queries.</p> <p><code>Visitor</code> is a <code>private final</code> class of <code>Analyzer</code>.</p>"},{"location":"Analyzer/#analysis","text":"","title":"Analysis <p><code>Visitor</code> creates an Analysis when created.</p> <p>The <code>Analysis</code> instance is mutated (changed) while visiting AST nodes while analyzing a query.</p>"},{"location":"Analyzer/#visitaliasedrelation","text":"","title":"visitAliasedRelation <pre><code>AstNode visitAliasedRelation(\n  AliasedRelation node,\n  Void context)\n</code></pre> <p><code>visitAliasedRelation</code> makes sure that the <code>Table</code> relation is registered in the MetaStore and requests the Analysis to register the alias with the DataSource.</p> <p><code>visitAliasedRelation</code> is part of the AstVisitor abstraction.</p>"},{"location":"Analyzer/#visitselect","text":"","title":"visitSelect <pre><code>AstNode visitSelect(\n  Select node,\n  Void context)\n</code></pre> <p><code>visitSelect</code>...FIXME</p> <p><code>visitSelect</code> is part of the AstVisitor abstraction.</p>"},{"location":"Analyzer_Visitor/","text":"<p><code>Visitor</code> is a DefaultTraversalVisitor.</p> <p><code>Visitor</code> is a <code>private final class</code> of Analyzer.</p>","title":"Visitor"},{"location":"Analyzer_Visitor/#creating-instance","text":"<p><code>Visitor</code> takes the following to be created:</p> <ul> <li> <code>Query</code> <li> <code>persistent</code> flag  <p><code>Visitor</code> is created when:</p> <ul> <li><code>Analyzer</code> is requested to analyze</li> </ul>","title":"Creating Instance"},{"location":"AstSanitizer/","text":"<p><code>AstSanitizer</code> is...FIXME</p>","title":"AstSanitizer"},{"location":"CommandFactories/","text":"<p><code>CommandFactories</code> is a DdlCommandFactory.</p>","title":"CommandFactories"},{"location":"CommandFactories/#creating-instance","text":"<p><code>CommandFactories</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> MetaStore  <p><code>CommandFactories</code> is created alongside an EngineContext</p>","title":"Creating Instance"},{"location":"CommandFactories/#command-factories","text":"","title":"Command Factories <p><code>CommandFactories</code> creates <code>FACTORIES</code> collection of handlers (functions) for DdlStatements to produce <code>DdlCommand</code>s.</p>    DdlStatement Handler     CreateStream handleCreateStream   CreateTable <code>handleCreateTable</code>   <code>DropStream</code> <code>handleDropStream</code>   <code>DropTable</code> <code>handleDropTable</code>   <code>RegisterType</code> <code>handleRegisterType</code>   <code>DropType</code> <code>handleDropType</code>   <code>AlterSource</code> <code>handleAlterSource</code>    <p>The <code>FACTORIES</code> is used in create.</p>"},{"location":"CommandFactories/#creating-ddlcommand","text":"","title":"Creating DdlCommand <p><code>create</code> is part of the DdlCommandFactory abstraction.</p>"},{"location":"CommandFactories/#ddlstatement","text":"","title":"DdlStatement <pre><code>DdlCommand create(\n  String sqlExpression,\n  DdlStatement ddlStatement,\n  SessionConfig config)\n</code></pre> <p><code>create</code> looks up (the class of) the given DdlStatement in the FACTORIES registry and requests it to handle it (and produce a <code>DdlCommand</code>).</p> <p>Unless found, <code>create</code> throws a <code>KsqlException</code>:</p> <pre><code>Unable to find ddl command factory for statement: [class] valid statements:[FACTORIES]\n</code></pre>"},{"location":"CommandFactories/#ksqlstructureddataoutputnode","text":"","title":"KsqlStructuredDataOutputNode <pre><code>DdlCommand create(\n  KsqlStructuredDataOutputNode outputNode)\n</code></pre> <p>For a <code>KSTREAM</code> node output type (of the given <code>KsqlStructuredDataOutputNode</code>), <code>create</code> requests the CreateSourceFactory for a CreateStreamCommand.</p> <p>Otherwise, <code>create</code> requests the CreateSourceFactory for a CreateTableCommand.</p>"},{"location":"CommandFactories/#handlecreatestream","text":"","title":"handleCreateStream <pre><code>CreateStreamCommand handleCreateStream(\n  CallInfo callInfo,\n  CreateStream statement)\n</code></pre> <p><code>handleCreateStream</code> requests the CreateSourceFactory for a CreateStreamCommand (for the given CreateStream statement).</p>"},{"location":"CreateSourceFactory/","text":"","title":"CreateSourceFactory"},{"location":"CreateSourceFactory/#creating-instance","text":"<p><code>CreateSourceFactory</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> MetaStore  <p><code>CreateSourceFactory</code> is created alongside a CommandFactories.</p>","title":"Creating Instance"},{"location":"CreateSourceFactory/#creating-createstreamcommand","text":"","title":"Creating CreateStreamCommand <pre><code>CreateStreamCommand createStreamCommand(\n  CreateStream statement,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>createStreamCommand</code> requests the MetaStore for the DataSource for the given CreateStream.</p> <p><code>createStreamCommand</code> throwIfCreateOrReplaceOnSourceStreamOrTable.</p> <p>In the end, <code>createStreamCommand</code> creates a CreateStreamCommand.</p> <p><code>createStreamCommand</code> is used when:</p> <ul> <li><code>CommandFactories</code> is requested to handle a CreateStream DDL statement</li> </ul>"},{"location":"CreateSourceFactory/#throwifcreateorreplaceonsourcestreamortable","text":"","title":"throwIfCreateOrReplaceOnSourceStreamOrTable <pre><code>void throwIfCreateOrReplaceOnSourceStreamOrTable(\n  CreateSource createSource,\n  DataSource existingSource)\n</code></pre> <p><code>throwIfCreateOrReplaceOnSourceStreamOrTable</code> throws a <code>KsqlException</code> when the given CreateSource is as follows:</p> <ol> <li>CREATE OR REPLACE</li> <li>SOURCE or the given DataSource is a source</li> </ol> <pre><code>Cannot add [stream|table] '[source-name]':\nCREATE OR REPLACE is not supported on source [stream|table]s.\n</code></pre> <p><code>throwIfCreateOrReplaceOnSourceStreamOrTable</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested for CreateStreamCommand and CreateTableCommand DDL commands</li> </ul>"},{"location":"CreateSourceFactory/#buildformats","text":"","title":"buildFormats <pre><code>Formats buildFormats(\n  SourceName name,\n  LogicalSchema schema,\n  CreateSourceProperties props,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>buildFormats</code>...FIXME</p> <p><code>buildFormats</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested for a CreateStreamCommand and CreateTableCommand</li> </ul>"},{"location":"CreateStreamCommand/","text":"<p><code>CreateStreamCommand</code> is...FIXME</p>","title":"CreateStreamCommand"},{"location":"DataSource/","text":"<p><code>DataSource</code> is...FIXME</p>","title":"DataSource"},{"location":"DataSourceNode/","text":"","title":"DataSourceNode"},{"location":"DataSourceNode/#creating-instance","text":"<p><code>DataSourceNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> DataSource <li> Source Name <li>SchemaKStreamFactory</li> <li> <code>isWindowed</code> flag <li> KsqlConfig  <p><code>DataSourceNode</code> is created when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build a join or a non-join node</li> </ul>","title":"Creating Instance"},{"location":"DataSourceNode/#schemakstreamfactory","text":"","title":"SchemaKStreamFactory <p><code>DataSourceNode</code> can be given a <code>SchemaKStreamFactory</code> when created. Unless given, <code>DataSourceNode</code> uses SchemaKSourceFactory.</p>  <p>Note</p> <p>Note the difference in type names, i.e. <code>SchemaKStreamFactory</code> (with <code>Stream</code> inside) vs <code>SchemaKSourceFactory</code> (with <code>Source</code> instead).</p>  <p>The <code>SchemaKStreamFactory</code> is used to create a SchemaKStream when <code>DataSourceNode</code> is requested to build one.</p>"},{"location":"DataSourceNode/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p><code>buildStream</code> requests the given <code>PlanBuildContext</code> to <code>buildNodeContext</code>.</p> <p>In the end, requests the SchemaKStreamFactory for a SchemaKStream.</p>  <p><code>buildStream</code> is part of the PlanNode abstraction.</p>"},{"location":"DdlCommandFactory/","text":"<p><code>DdlCommandFactory</code> is...FIXME</p>","title":"DdlCommandFactory"},{"location":"EngineContext/","text":"","title":"EngineContext"},{"location":"EngineContext/#creating-instance","text":"<p><code>EngineContext</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> <code>ProcessingLogContext</code> <li> <code>MutableMetaStore</code> <li> <code>QueryIdGenerator</code> <li> KsqlParser <li> <code>QueryCleanupService</code> <li> KsqlConfig <li> QueryRegistry  <p><code>EngineContext</code> is created using create and createSandbox factories.</p>","title":"Creating Instance"},{"location":"EngineContext/#commandfactories","text":"","title":"CommandFactories <p><code>EngineContext</code> creates a CommandFactories when created.</p> <p>The <code>CommandFactories</code> is used to create a DdlCommand.</p>"},{"location":"EngineContext/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> requests the KsqlParser to parse the given SQL statements.</p> <p><code>parse</code> is used when:</p> <ul> <li><code>EngineContext</code> is requested to substituteVariables</li> <li><code>KsqlEngine</code> is requested to parse a SQL text</li> <li><code>SandboxedExecutionContext</code> is requested to <code>parse</code></li> </ul>"},{"location":"EngineContext/#preparing-parsedstatement-prepare","text":"","title":"Preparing ParsedStatement (prepare) <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>prepare</code> substitutes variables (in the given <code>ParsedStatement</code> with the <code>variablesMap</code>) and then requests the KsqlParser to prepare the ParsedStatement (with the variables resolved).</p> <p><code>prepare</code> sanitizes the statement based on the following configuration properties (in the KsqlConfig):</p> <ul> <li>ksql.lambdas.enabled</li> <li>ksql.rowpartition.rowoffset.enabled</li> </ul> <p>In the end, <code>prepare</code> creates a new <code>PreparedStatement</code>.</p> <p><code>prepare</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to prepare a ParsedStatement</li> <li><code>SandboxedExecutionContext</code> is requested to <code>prepare</code> a <code>ParsedStatement</code></li> </ul>"},{"location":"EngineContext/#variable-substitution","text":"","title":"Variable Substitution <pre><code>ParsedStatement substituteVariables(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>substituteVariables</code> substitutes variables (in the given <code>ParsedStatement</code> with the <code>variablesMap</code>) and then parses the SQL text.</p>"},{"location":"EngineContext/#creating-enginecontext","text":"","title":"Creating EngineContext <pre><code>EngineContext create(\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MutableMetaStore metaStore,\n  QueryIdGenerator queryIdGenerator,\n  QueryCleanupService cleanupService,\n  KsqlConfig ksqlConfig,\n  Collection&lt;QueryEventListener&gt; registrationListeners)\n</code></pre> <p><code>create</code> creates a EngineContext (with a new DefaultKsqlParser, a new QueryRegistryImpl and the others).</p> <p><code>create</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is created</li> </ul>"},{"location":"EngineContext/#creating-sandboxed-enginecontext","text":"","title":"Creating Sandboxed EngineContext <pre><code>EngineContext createSandbox(\n  ServiceContext serviceContext)\n</code></pre> <p><code>createSandbox</code> creates an EngineContext.</p> <p><code>createSandbox</code> is used when:</p> <ul> <li><code>SandboxedExecutionContext</code> is created</li> </ul>"},{"location":"EngineContext/#creating-ddlcommand","text":"","title":"Creating DdlCommand <pre><code>DdlCommand createDdlCommand(\n  KsqlStructuredDataOutputNode outputNode)\nDdlCommand createDdlCommand(\n  String sqlExpression,\n  ExecutableDdlStatement statement,\n  SessionConfig config)\n</code></pre> <p><code>createDdlCommand</code> requests the CommandFactories to create a DdlCommand.</p> <p><code>createDdlCommand</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a ExecutableDdlStatement and maybeCreateSinkDdl</li> </ul>"},{"location":"EngineExecutor/","text":"","title":"EngineExecutor"},{"location":"EngineExecutor/#creating-instance","text":"<p><code>EngineExecutor</code> takes the following to be created:</p> <ul> <li> EngineContext <li> ServiceContext <li> SessionConfig  <p><code>EngineExecutor</code> is created using create factory.</p>","title":"Creating Instance"},{"location":"EngineExecutor/#creating-engineexecutor","text":"","title":"Creating EngineExecutor <pre><code>EngineExecutor create(\n  EngineContext engineContext,\n  ServiceContext serviceContext,\n  SessionConfig config)\n</code></pre> <p><code>create</code> creates an EngineExecutor.</p>  <p>Note</p> <p><code>create</code> is simply a convenient static factory method that does nothing but <code>new EngineExecutor</code> yet makes for a more readable fluent client code.</p> <pre><code>EngineExecutor\n  .create(...)\n  .plan(statement)\n</code></pre>  <p><code>create</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to plan, execute, executeTransientQuery, createStreamPullQuery, executeScalablePushQuery, executeTablePullQuery</li> <li><code>SandboxedExecutionContext</code> is requested to plan, execute, executeTransientQuery, executeTablePullQueryQuery, executeScalablePushQuery</li> </ul>"},{"location":"EngineExecutor/#executetablepullquery","text":"","title":"executeTablePullQuery <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>executeTablePullQuery</code>...FIXME</p> <p><code>executeTablePullQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to executeTablePullQuery</li> <li><code>SandboxedExecutionContext</code> is requested to executeTablePullQuery</li> </ul>"},{"location":"EngineExecutor/#buildandvalidatelogicalplan","text":"","title":"buildAndValidateLogicalPlan <pre><code>LogicalPlanNode buildAndValidateLogicalPlan(\n  ConfiguredStatement&lt;?&gt; statement,\n  ImmutableAnalysis analysis,\n  KsqlConfig config,\n  QueryPlannerOptions queryPlannerOptions,\n  boolean isScalablePush)\n</code></pre> <p><code>buildAndValidateLogicalPlan</code> creates a LogicalPlanner to buildQueryLogicalPlan (that gives an OutputNode).</p> <p>In the end, <code>buildAndValidateLogicalPlan</code> creates a <code>LogicalPlanNode</code> (with the statement of the given <code>ConfiguredStatement</code> and the OutputNode).</p> <p><code>buildAndValidateLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTablePullQuery (with the <code>isScalablePush</code> flag disabled) and executeScalablePushQuery (with the <code>isScalablePush</code> flag enabled)</li> </ul>"},{"location":"EngineExecutor/#executetransientquery","text":"","title":"executeTransientQuery <pre><code>TransientQueryMetadata executeTransientQuery(\n  ConfiguredStatement&lt;Query&gt; statement,\n  boolean excludeTombstones)\n</code></pre> <p><code>executeTransientQuery</code>...FIXME</p> <p>In the end, <code>executeTransientQuery</code> requests the EngineContext for the QueryRegistry to create a transient query.</p> <p><code>executeTransientQuery</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to executeTransientQuery</li> <li><code>SandboxedExecutionContext</code> is requested to executeTransientQuery</li> </ul>"},{"location":"EngineExecutor/#planquery","text":"","title":"planQuery <pre><code>ExecutorPlans planQuery(\n  ConfiguredStatement&lt;?&gt; statement,\n  Query query,\n  Optional&lt;Sink&gt; sink,\n  Optional&lt;String&gt; withQueryId,\n  MetaStore metaStore)\n</code></pre> <p><code>planQuery</code> requests the EngineContext to createQueryEngine (with the ServiceContext).</p> <p><code>planQuery</code> buildQueryLogicalPlan.</p> <p><code>planQuery</code>...FIXME</p> <p><code>planQuery</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTransientQuery, executeStreamPullQuery, sourceTablePlan, plan</li> </ul>"},{"location":"EngineExecutor/#query-planning-plan","text":"","title":"Query Planning (plan) <pre><code>KsqlPlan plan(\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> requests the given <code>ConfiguredStatement</code> for the Statement.</p>"},{"location":"EngineExecutor/#executableddlstatement","text":"","title":"ExecutableDdlStatement <p>For a ExecutableDdlStatement, <code>plan</code> determines whether it is a CreateStream or a <code>CreateTable</code>. They are supposed to be a source.</p> <p>For a source <code>CreateTable</code>, <code>plan</code> sourceTablePlan. Otherwise, <code>plan</code> requests the EngineContext to create a DdlCommand and then creates a KsqlPlanV1.</p>"},{"location":"EngineExecutor/#planning-querycontainer","text":"","title":"Planning QueryContainer <p>Otherwise, <code>plan</code> assumes that the <code>Statement</code> is a QueryContainer and plans the query (with the <code>Sink</code> among the others that gives a <code>PhysicalPlan</code>).</p> <p><code>plan</code> maybeCreateSinkDdl.</p> <p><code>plan</code> creates a QueryPlan.</p> <p>In the end, <code>plan</code> creates a KsqlPlanV1.</p>"},{"location":"EngineExecutor/#exceptions","text":"","title":"Exceptions <p><code>plan</code> throws a KsqlStatementException for a non-executable statement.</p> <p><code>plan</code> throws a <code>KsqlStatementException</code> for a CreateStream or a <code>CreateTable</code> that are source the ksql.source.table.materialization.enabled configuration property is disabled:</p> <pre><code>Cannot execute command because source table materialization is disabled.\n</code></pre>"},{"location":"EngineExecutor/#usage","text":"","title":"Usage <p><code>plan</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to plan a query</li> <li><code>SandboxedExecutionContext</code> is requested to plan a query</li> </ul>"},{"location":"EngineExecutor/#executing-query","text":"","title":"Executing Query <pre><code>ExecuteResult execute(\n  KsqlPlan plan)\n</code></pre> <p><code>execute</code>...FIXME</p> <p>In the end, <code>execute</code> executes the persistent query.</p> <p><code>execute</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a query</li> <li><code>SandboxedExecutionContext</code> is requested to execute a query</li> </ul>"},{"location":"EngineExecutor/#executing-persistent-query","text":"","title":"Executing Persistent Query <pre><code>PersistentQueryMetadata executePersistentQuery(\n  QueryPlan queryPlan,\n  String statementText,\n  KsqlConstants.PersistentQueryType persistentQueryType)\n</code></pre> <p><code>executePersistentQuery</code> requests the EngineContext for the QueryRegistry to create or replace a persistent query (for the given QueryPlan and <code>PersistentQueryType</code>).</p>"},{"location":"ExecutionStep/","text":"<p><code>ExecutionStep&lt;S&gt;</code> is an abstraction of execution steps (physical plans) to build S.</p> <p><code>S</code> can be one of the following:</p> <ul> <li><code>KStreamHolder</code></li> <li><code>KTableHolder</code></li> <li><code>KGroupedStreamHolder</code></li> <li><code>KGroupedTableHolder</code></li> </ul>","title":"ExecutionStep"},{"location":"ExecutionStep/#contract","text":"","title":"Contract"},{"location":"ExecutionStep/#building-s","text":"","title":"Building S <pre><code>S build(\n  PlanBuilder planBuilder) // (1)!\nS build(\n  PlanBuilder planBuilder,\n  PlanInfo planInfo)\n</code></pre> <ol> <li>Uses a PlanInfoExtractor to extract a PlanInfo</li> </ol> <p>Used when:</p> <ul> <li><code>QueryBuilder</code> is requested for a query implementation</li> </ul>"},{"location":"ExecutionStep/#extracting-planinfo","text":"","title":"Extracting PlanInfo <pre><code>PlanInfo extractPlanInfo(\n  PlanInfoExtractor planInfoExtractor)\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to planQuery</li> <li><code>ExecutionStep</code> is requested to build</li> <li><code>PlanInfoExtractor</code> is requested to visitRepartitionStep, visitJoinStep and visitSingleSourceStep</li> </ul>"},{"location":"ExecutionStep/#implementations","text":"<ul> <li><code>ForeignKeyTableTableJoin</code></li> <li>SourceStep</li> <li><code>StreamAggregate</code></li> <li><code>StreamFilter</code></li> <li><code>StreamFlatMap</code></li> <li><code>StreamGroupBy</code></li> <li><code>StreamGroupByKey</code></li> <li><code>StreamGroupByV1</code></li> <li><code>StreamSelect</code></li> <li><code>StreamSelectKey</code></li> <li><code>StreamSelectKeyV1</code></li> <li><code>StreamSink</code></li> <li><code>StreamStreamJoin</code></li> <li><code>StreamTableJoin</code></li> <li><code>StreamWindowedAggregate</code></li> <li><code>TableAggregate</code></li> <li><code>TableFilter</code></li> <li><code>TableGroupBy</code></li> <li><code>TableGroupByV1</code></li> <li><code>TableSelect</code></li> <li><code>TableSelectKey</code></li> <li><code>TableSink</code></li> <li><code>TableSuppress</code></li> <li><code>TableTableJoin</code></li> </ul>","title":"Implementations"},{"location":"ExecutionStepFactory/","text":"","title":"ExecutionStepFactory"},{"location":"ExecutionStepFactory/#creating-streamsource","text":"","title":"Creating StreamSource <pre><code>StreamSource streamSource(\n  QueryContext.Stacker stacker,\n  LogicalSchema sourceSchema,\n  String topicName,\n  Formats formats,\n  Optional&lt;TimestampColumn&gt; timestampColumn,\n  int pseudoColumnVersion)\n</code></pre> <p><code>streamSource</code> creates a StreamSource.</p> <p><code>streamSource</code> is used when:</p> <ul> <li><code>SchemaKSourceFactory</code> is requested to buildStream</li> </ul>"},{"location":"Format/","text":"<p><code>Format</code> is an abstraction of value and key formats.</p>","title":"Format"},{"location":"FormatFactory/","text":"<p><code>FormatFactory</code> contains built-in serialization Formats.</p>","title":"FormatFactory"},{"location":"FormatFactory/#avro","text":"","title":"AVRO <p><code>AvroFormat</code></p>"},{"location":"FormatFactory/#json","text":"","title":"JSON <p><code>JsonFormat</code></p>"},{"location":"FormatFactory/#json_sr","text":"","title":"JSON_SR <p><code>JsonSchemaFormat</code></p>"},{"location":"FormatFactory/#protobuf","text":"","title":"PROTOBUF <p><code>ProtobufFormat</code></p>"},{"location":"FormatFactory/#kafka","text":"","title":"KAFKA <p><code>KafkaFormat</code></p>"},{"location":"FormatFactory/#delimited","text":"","title":"DELIMITED <p><code>DelimitedFormat</code></p>"},{"location":"FormatFactory/#none","text":"","title":"NONE <p><code>NoneFormat</code></p>"},{"location":"ImmutableAnalysis/","text":"<p><code>ImmutableAnalysis</code> is an abstraction of query analysers.</p>","title":"ImmutableAnalysis"},{"location":"ImmutableAnalysis/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"ImmutableAnalysis/#getjoin","text":"","title":"getJoin <pre><code>List&lt;JoinInfo&gt; getJoin()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>LogicalPlanner</code> is requested to build a source node</li> </ul>"},{"location":"ImmutableAnalysis/#getselectitems","text":"","title":"getSelectItems <pre><code>List&lt;SelectItem&gt; getSelectItems()\n</code></pre> <p>See Analysis</p>"},{"location":"ImmutableAnalysis/#isjoin","text":"","title":"isJoin <pre><code>boolean isJoin()\n</code></pre> <p>See Analysis</p> <p>Used when:</p> <ul> <li><code>PullQueryValidator</code> is created</li> <li><code>LogicalPlanner</code> is requested to build a source node</li> </ul>"},{"location":"ImmutableAnalysis/#implementations","text":"<ul> <li>Analysis</li> </ul>","title":"Implementations"},{"location":"Injector/","text":"<p><code>Injector</code> is...FIXME</p>","title":"Injector"},{"location":"JoinNode/","text":"<p><code>JoinNode</code> is...FIXME</p>","title":"JoinNode"},{"location":"KSPlanBuilder/","text":"<p><code>KSPlanBuilder</code> is a PlanBuilder that builds a Kafka Streams application (from an execution plan).</p>","title":"KSPlanBuilder"},{"location":"KSPlanBuilder/#creating-instance","text":"<p><code>KSPlanBuilder</code> takes the following to be created:</p> <ul> <li> RuntimeBuildContext <li> <code>SqlPredicateFactory</code> <li> <code>AggregateParamsFactory</code> <li> <code>StreamsFactories</code>  <p><code>KSPlanBuilder</code> is created when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildQueryImplementation</li> </ul>","title":"Creating Instance"},{"location":"KSPlanBuilder/#visitstreamsource","text":"","title":"visitStreamSource <pre><code>KStreamHolder&lt;GenericKey&gt; visitStreamSource(\n  StreamSource streamSource,\n  PlanInfo planInfo) // (1)!\n</code></pre> <ol> <li>The given <code>PlanInfo</code> is not used.</li> </ol> <p><code>visitStreamSource</code> uses the SourceBuilderV1 to build a KStream (for the RuntimeBuildContext, the given StreamSource and the <code>ConsumedFactory</code> from the StreamsFactories).</p> <p><code>visitStreamSource</code> is part of the PlanBuilder abstraction.</p>"},{"location":"KSPlanBuilder/#visittablesource","text":"","title":"visitTableSource <pre><code>KTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSource tableSource,\n  PlanInfo planInfo)\nKTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSourceV1 tableSourceV1,\n  PlanInfo planInfo)\n</code></pre> <p><code>visitTableSource</code> requests the SourceBuilder or SourceBuilderV1 to buildTable.</p> <p><code>visitTableSource</code> is part of the PlanBuilder abstraction.</p>"},{"location":"KafkaStreamsBuilder/","text":"<p><code>KafkaStreamsBuilder</code> is an abstraction of KafkaStreams builders.</p>","title":"KafkaStreamsBuilder"},{"location":"KafkaStreamsBuilder/#contract","text":"","title":"Contract"},{"location":"KafkaStreamsBuilder/#building-kafkastreams-client","text":"","title":"Building KafkaStreams Client <pre><code>KafkaStreams build(\n  Topology topology,\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p>KafkaStreamsBuilderImpl</p> <p>Used when:</p> <ul> <li><code>QueryMetadataImpl</code> is requested to initialize</li> </ul>"},{"location":"KafkaStreamsBuilder/#buildnamedtopologywrapper","text":"","title":"buildNamedTopologyWrapper <pre><code>KafkaStreamsNamedTopologyWrapper buildNamedTopologyWrapper(\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p>KafkaStreamsBuilderImpl</p> <p>Used when:</p> <ul> <li><code>SharedKafkaStreamsRuntime</code> is created</li> <li><code>SharedKafkaStreamsRuntimeImpl</code> is requested to restartStreamsRuntime</li> </ul>"},{"location":"KafkaStreamsBuilder/#implementations","text":"<ul> <li>KafkaStreamsBuilderImpl</li> </ul>","title":"Implementations"},{"location":"KafkaStreamsBuilderImpl/","text":"<p><code>KafkaStreamsBuilderImpl</code> is a KafkaStreamsBuilder.</p> <p><code>KafkaStreamsBuilderImpl</code> acts as a bridge between ksqlDB and Kafka Streams library.</p>","title":"KafkaStreamsBuilderImpl"},{"location":"KafkaStreamsBuilderImpl/#creating-instance","text":"<p><code>KafkaStreamsBuilderImpl</code> takes the following to be created:</p> <ul> <li>KafkaClientSupplier</li> </ul> <p><code>KafkaStreamsBuilderImpl</code> is created along with a QueryBuilder.</p>","title":"Creating Instance"},{"location":"KafkaStreamsBuilderImpl/#kafkaclientsupplier","text":"","title":"KafkaClientSupplier <p><code>KafkaStreamsBuilderImpl</code> is given a <code>KafkaClientSupplier</code> (Kafka Streams) when created.</p>"},{"location":"KafkaStreamsBuilderImpl/#building-kafkastreams-client","text":"","title":"Building KafkaStreams Client <pre><code>KafkaStreams build(\n  Topology topology, \n  Map&lt;String, Object&gt; conf)\n</code></pre> <p><code>build</code> creates a <code>KafkaStreams</code> (Kafka Streams) with the given <code>Topology</code> (Kafka Streams) (with the given <code>conf</code> properties and the KafkaClientSupplier).</p> <p><code>build</code> is part of the KafkaStreamsBuilder abstraction.</p>"},{"location":"KafkaStreamsBuilderImpl/#buildnamedtopologywrapper","text":"","title":"buildNamedTopologyWrapper <pre><code>KafkaStreamsNamedTopologyWrapper buildNamedTopologyWrapper(\n  Map&lt;String, Object&gt; conf)\n</code></pre> <p><code>buildNamedTopologyWrapper</code> creates a <code>KafkaStreamsNamedTopologyWrapper</code> with the given <code>conf</code> properties and the KafkaClientSupplier.</p> <p><code>buildNamedTopologyWrapper</code> is part of the KafkaStreamsBuilder abstraction.</p>"},{"location":"KsqlConfig/","text":"","title":"KsqlConfig"},{"location":"KsqlConfig/#ksqlpersistencedefaultformatvalue","text":"","title":"ksql.persistence.default.format.value"},{"location":"KsqlConfig/#ksqllambdasenabled","text":"","title":"ksql.lambdas.enabled"},{"location":"KsqlConfig/#ksqloutputtopicnameprefix","text":"","title":"ksql.output.topic.name.prefix"},{"location":"KsqlConfig/#ksqlquerypulllimitclauseenabled","text":"","title":"ksql.query.pull.limit.clause.enabled"},{"location":"KsqlConfig/#ksqlrowpartitionrowoffsetenabled","text":"","title":"ksql.rowpartition.rowoffset.enabled"},{"location":"KsqlConfig/#ksqlsourcetablematerializationenabled","text":"","title":"ksql.source.table.materialization.enabled"},{"location":"KsqlConfig/#ksqlvariablesubstitutionenable","text":"","title":"ksql.variable.substitution.enable <p>Enables variable substitution on SQL statements</p> <p>Default: <code>true</code></p> <p>Used when:</p> <ul> <li><code>Cli</code> is requested to <code>isVariableSubstitutionEnabled</code></li> <li><code>RequestHandler</code> is requested to <code>isVariableSubstitutionEnabled</code></li> <li><code>RequestValidator</code> is requested to <code>isVariableSubstitutionEnabled</code></li> </ul>"},{"location":"KsqlEngine/","text":"<p><code>KsqlEngine</code> is a facade of EngineContext.</p>","title":"KsqlEngine"},{"location":"KsqlEngine/#creating-instance","text":"<p><code>KsqlEngine</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> ProcessingLogContext <li> Service ID <li> MutableMetaStore <li> <code>Function&lt;KsqlEngine, KsqlEngineMetrics&gt;</code> <li> QueryIdGenerator <li> KsqlConfig <li> <code>QueryEventListener</code>s  <p><code>KsqlEngine</code> is created when:</p> <ul> <li><code>KsqlContext</code> is requested to create</li> <li><code>KsqlRestApplication</code> is requested to buildApplication</li> <li><code>StandaloneExecutorFactory</code> is requested to create</li> </ul>","title":"Creating Instance"},{"location":"KsqlEngine/#enginecontext","text":"","title":"EngineContext <p><code>KsqlEngine</code> creates an EngineContext when created.</p> <p><code>KsqlEngine</code> is (pretty much) a facade of the <code>EngineContext</code>.</p>"},{"location":"KsqlEngine/#executing-statement","text":"","title":"Executing Statement <pre><code>ExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement) // (1)\nExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredKsqlPlan plan)\n</code></pre> <ol> <li>Plans the statement and creates a <code>ConfiguredKsqlPlan</code> for the other <code>execute</code></li> </ol> <p><code>execute</code> creates an EngineExecutor to execute the <code>KsqlPlan</code> (of the <code>ConfiguredKsqlPlan</code>).</p> <p><code>execute</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#query-planning-plan","text":"","title":"Query Planning (plan) <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> creates an EngineExecutor to plan the given <code>ConfiguredStatement</code>.</p> <p><code>plan</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#getalllivequeries","text":"","title":"getAllLiveQueries <pre><code>List&lt;QueryMetadata&gt; getAllLiveQueries()\n</code></pre> <p><code>getAllLiveQueries</code>...FIXME</p> <p><code>getAllLiveQueries</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> requests the EngineContext to parse the given SQL statements (into a collection of <code>ParsedStatement</code>s).</p> <p><code>parse</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#preparing-parsedstatement","text":"","title":"Preparing ParsedStatement <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\n</code></pre> <p><code>prepare</code> requests the EngineContext to prepare the given ParsedStatement.</p> <p><code>prepare</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#executetablepullquery","text":"","title":"executeTablePullQuery <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions plannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>executeTablePullQuery</code>...FIXME</p> <p><code>executeTablePullQuery</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"KsqlEngine/#isexecutablestatement","text":"","title":"isExecutableStatement <pre><code>boolean isExecutableStatement(\n  Statement statement)\n</code></pre> <p><code>isExecutableStatement</code> is positive (<code>true</code>) when the given Statement is one of the following:</p> <ul> <li>ExecutableDdlStatement</li> <li>QueryContainer</li> <li>Query</li> </ul> <p><code>isExecutableStatement</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to throwOnNonExecutableStatement</li> <li><code>RequestValidator</code> is requested to validate</li> </ul>"},{"location":"KsqlEngine/#analyzequerywithnooutputtopic","text":"","title":"analyzeQueryWithNoOutputTopic <pre><code>ImmutableAnalysis analyzeQueryWithNoOutputTopic(\n  Query query,\n  String queryText,\n  Map&lt;String, Object&gt; configOverrides)\n</code></pre> <p><code>analyzeQueryWithNoOutputTopic</code>...FIXME</p> <p><code>analyzeQueryWithNoOutputTopic</code> is used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handle pull or push queries</li> </ul>"},{"location":"KsqlExecutionContext/","text":"<p><code>KsqlExecutionContext</code> is an abstraction of execution contexts.</p>","title":"KsqlExecutionContext"},{"location":"KsqlExecutionContext/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"KsqlExecutionContext/#executetablepullquery","text":"","title":"executeTablePullQuery <pre><code>PullQueryResult executeTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; statement,\n  HARouting routing,\n  RoutingOptions routingOptions,\n  QueryPlannerOptions queryPlannerOptions,\n  Optional&lt;PullQueryExecutorMetrics&gt; pullQueryMetrics,\n  boolean startImmediately,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p>Used when:</p> <ul> <li><code>QueryExecutor</code> is requested to handleTablePullQuery</li> </ul>"},{"location":"KsqlExecutionContext/#getalllivequeries","text":"","title":"getAllLiveQueries <pre><code>List&lt;QueryMetadata&gt; getAllLiveQueries()\n</code></pre> <p>Used when:</p> <ul> <li><code>ListQueriesExecutor</code> is requested to <code>getLocalSimple</code>, <code>getLocalExtended</code></li> <li><code>QueryCapacityUtil</code> utility is used to <code>getNumLivePushQueries</code></li> </ul>"},{"location":"KsqlExecutionContext/#parsing-sql-text","text":"","title":"Parsing SQL Text <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to sql</li> <li><code>SqlFormatInjector</code> is requested to <code>inject</code></li> <li><code>QueryEndpoint</code> is requested to <code>createStatement</code></li> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>StandaloneExecutor</code> is requested to processesQueryFile</li> <li><code>StatementParser</code> is requested to <code>parseSingleStatement</code></li> <li><code>KsqlResource</code> is requested to handleKsqlStatements</li> </ul>"},{"location":"KsqlExecutionContext/#query-planning","text":"","title":"Query Planning <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlEngine</code> is requested to execute a SQL statement</li> <li><code>SandboxedExecutionContext</code> is requested to execute a SQL statement</li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateAs</code></li> <li><code>ValidatedCommandFactory</code> is requested to createForPlannedQuery</li> </ul>"},{"location":"KsqlExecutionContext/#preparing-parsedstatement","text":"","title":"Preparing ParsedStatement <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  Map&lt;String, String&gt; variablesMap)\nPreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt) // (1)\n</code></pre> <ol> <li>Uses an empty <code>Map</code></li> </ol> <p>Used when:</p> <ul> <li><code>KsqlContext</code> is requested to execute</li> <li><code>KsqlRestApplication</code> is requested to registerCommandTopic</li> <li><code>QueryEndpoint</code> is requested to <code>createStatement</code></li> <li><code>RequestHandler</code> is requested to execute</li> <li><code>RequestValidator</code> is requested to <code>validate</code></li> <li><code>SqlFormatInjector</code> is requested to <code>inject</code></li> <li><code>StandaloneExecutor.StatementExecutor</code> is requested to <code>prepare</code> a <code>ParsedStatement</code></li> <li><code>StatementParser</code> is requested to <code>parseSingleStatement</code></li> </ul>"},{"location":"KsqlExecutionContext/#implementations","text":"<ul> <li>KsqlEngine</li> <li>SandboxedExecutionContext</li> </ul>","title":"Implementations"},{"location":"KsqlPlan/","text":"<p><code>KsqlPlan</code> is an abstraction of query plans.</p>","title":"KsqlPlan"},{"location":"KsqlPlan/#contract","text":"","title":"Contract"},{"location":"KsqlPlan/#getddlcommand","text":"","title":"getDdlCommand <pre><code>Optional&lt;DdlCommand&gt; getDdlCommand()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>DefaultSchemaInjector</code> is requested to <code>forCreateAsStatement</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateAs</code></li> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> <li><code>RestoreCommandsCompactor.CompactedNode</code> is requested to <code>maybeAppend</code></li> </ul>"},{"location":"KsqlPlan/#getpersistentquerytype","text":"","title":"getPersistentQueryType <pre><code>Optional&lt;KsqlConstants.PersistentQueryType&gt; getPersistentQueryType()\n</code></pre> <p><code>PersistentQueryType</code> that can be one of the following:</p> <ul> <li><code>CREATE_SOURCE</code></li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> </ul>"},{"location":"KsqlPlan/#getqueryplan","text":"","title":"getQueryPlan <pre><code>Optional&lt;QueryPlan&gt; getQueryPlan()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>RestoreCommandsCompactor.CompactedNode</code> is requested to <code>maybeAppend</code></li> </ul>"},{"location":"KsqlPlan/#getstatementtext","text":"","title":"getStatementText <pre><code>String getStatementText()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a query</li> <li><code>KsqlEngine</code> is requested to execute a statement</li> <li><code>Command</code> utility is used to create a Command</li> </ul>"},{"location":"KsqlPlan/#withoutquery","text":"","title":"withoutQuery <pre><code>KsqlPlan withoutQuery()\n</code></pre> <p>Used when:</p> <ul> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> </ul>"},{"location":"KsqlPlan/#implementations","text":"<ul> <li>KsqlPlanV1</li> </ul>","title":"Implementations"},{"location":"KsqlPlan/#ddlplancurrent","text":"","title":"ddlPlanCurrent <pre><code>KsqlPlan ddlPlanCurrent(\n  String statementText,\n  DdlCommand ddlCommand)\n</code></pre> <p><code>ddlPlanCurrent</code> creates a KsqlPlanV1 with the given <code>statementText</code> and the <code>DdlCommand</code> (if given).</p> <p><code>ddlPlanCurrent</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a DdlStatement (for a non-source table)</li> </ul>"},{"location":"KsqlPlan/#creating-ksqlplanv1-queryplancurrent","text":"","title":"Creating KsqlPlanV1 (queryPlanCurrent) <pre><code>KsqlPlan queryPlanCurrent(\n  String statementText,\n  Optional&lt;DdlCommand&gt; ddlCommand,\n  QueryPlan queryPlan)\n</code></pre> <p><code>queryPlanCurrent</code> creates a KsqlPlanV1.</p> <p><code>queryPlanCurrent</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to sourceTablePlan and plan a statement</li> </ul>"},{"location":"KsqlPlanV1/","text":"<p><code>KsqlPlanV1</code> is a KsqlPlan.</p>","title":"KsqlPlanV1"},{"location":"KsqlPlanV1/#creating-instance","text":"<p><code>KsqlPlanV1</code> takes the following to be created:</p> <ul> <li> Statement Text <li> DDL command <li> QueryPlan  <p>When created, <code>KsqlPlanV1</code> makes sure that either a DDL command or query plan is given.</p> <p><code>KsqlPlanV1</code> is created when:</p> <ul> <li><code>KsqlPlan</code> is requested for ddlPlanCurrent and queryPlanCurrent</li> <li><code>KsqlPlanV1</code> is requested to create a new KsqlPlanV1 without a query plan</li> </ul>","title":"Creating Instance"},{"location":"LogicalPlanner/","text":"","title":"LogicalPlanner"},{"location":"LogicalPlanner/#creating-instance","text":"<p><code>LogicalPlanner</code> takes the following to be created:</p> <ul> <li> KsqlConfig <li>ImmutableAnalysis</li> <li> <code>MetaStore</code>  <p><code>LogicalPlanner</code> is created when:</p> <ul> <li><code>EngineExecutor</code> is requested to buildAndValidateLogicalPlan</li> <li><code>QueryEngine</code> is requested to buildQueryLogicalPlan</li> </ul>","title":"Creating Instance"},{"location":"LogicalPlanner/#immutableanalysis-and-rewrittenanalysis","text":"","title":"ImmutableAnalysis and RewrittenAnalysis <p><code>LogicalPlanner</code> creates a <code>RewrittenAnalysis</code> for the given <code>ImmutableAnalysis</code> when created.</p> <p>The <code>RewrittenAnalysis</code> is used when <code>LogicalPlanner</code> is requested for the following:</p> <ul> <li>buildSourceNode</li> <li>buildPersistentLogicalPlan</li> <li>buildQueryLogicalPlan</li> <li>buildOutputNode</li> <li>getWindowInfo</li> <li>getSinkTopic</li> <li>getSinkKeyFormat</li> <li>getTargetSchema</li> <li>buildAggregateNode</li> <li>buildUserProjectNode</li> <li>buildFlatMapNode</li> <li>buildJoinKey</li> <li>buildAggregateSchema</li> </ul>"},{"location":"LogicalPlanner/#buildpersistentlogicalplan","text":"","title":"buildPersistentLogicalPlan <pre><code>OutputNode buildPersistentLogicalPlan()\n</code></pre> <p><code>buildPersistentLogicalPlan</code> buildSourceNode.</p> <p><code>buildPersistentLogicalPlan</code>...FIXME</p> <p><code>buildPersistentLogicalPlan</code> is used when:</p> <ul> <li><code>QueryEngine</code> is requested to buildQueryLogicalPlan</li> </ul>"},{"location":"LogicalPlanner/#buildquerylogicalplan","text":"","title":"buildQueryLogicalPlan <pre><code>OutputNode buildQueryLogicalPlan(\n  QueryPlannerOptions queryPlannerOptions,\n  boolean isScalablePush)\n</code></pre> <p><code>buildQueryLogicalPlan</code>...FIXME</p> <p><code>buildQueryLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to buildAndValidateLogicalPlan</li> </ul>"},{"location":"LogicalPlanner/#buildsourcenode","text":"","title":"buildSourceNode <pre><code>PlanNode buildSourceNode(\n  boolean isWindowed)\n</code></pre> <p><code>buildSourceNode</code> buildNonJoinNode when the RewrittenAnalysis is not for a join.</p> <p>Otherwise, <code>buildSourceNode</code>...FIXME</p> <p><code>buildSourceNode</code> is used when:</p> <ul> <li><code>LogicalPlanner</code> is requested to buildPersistentLogicalPlan and buildQueryLogicalPlan</li> </ul>"},{"location":"LogicalPlanner/#buildnonjoinnode","text":"","title":"buildNonJoinNode <pre><code>DataSourceNode buildNonJoinNode(\n  AliasedDataSource dataSource,\n  boolean isWindowed,\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>buildNonJoinNode</code> creates a DataSourceNode (with a new <code>PlanNodeId</code> with <code>KsqlTopic</code> ID).</p>"},{"location":"LogicalPlanner/#buildjoin","text":"","title":"buildJoin <pre><code>JoinNode buildJoin(\n  Join root,\n  String prefix,\n  boolean isWindowed)\n</code></pre> <p><code>buildJoin</code> creates a JoinNode.</p>"},{"location":"MetaStore/","text":"<p><code>MetaStore</code> is...FIXME</p>","title":"MetaStore"},{"location":"OutputNode/","text":"<p><code>OutputNode</code> is an extension of the SingleSourcePlanNode abstraction for output nodes.</p>","title":"OutputNode"},{"location":"OutputNode/#contract","text":"","title":"Contract"},{"location":"OutputNode/#getsinkname","text":"","title":"getSinkName <pre><code>Optional&lt;SourceName&gt; getSinkName()\n</code></pre> <p>Used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to createStreamCommand and createTableCommand</li> <li><code>EngineExecutor</code> is requested to plan a statement, maybeCreateSinkDdl, validateExistingSink</li> <li><code>QueryIdUtil</code> is requested to <code>buildId</code></li> </ul>"},{"location":"OutputNode/#implementations","text":"<ul> <li><code>KsqlBareOutputNode</code></li> <li><code>KsqlStructuredDataOutputNode</code></li> </ul>","title":"Implementations"},{"location":"OutputNode/#creating-instance","text":"<p><code>OutputNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> Source PlanNode <li> <code>LogicalSchema</code> <li> Limit <li> <code>TimestampColumn</code>   <p>Abstract Class</p> <p><code>OutputNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete OutputNodes.</p>","title":"Creating Instance"},{"location":"PersistentQueryMetadata/","text":"<p><code>PersistentQueryMetadata</code> is an extension of the QueryMetadata abstraction for metadata of persistent queries.</p>","title":"PersistentQueryMetadata"},{"location":"PersistentQueryMetadata/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"PersistentQueryMetadata/#getpersistentquerytype","text":"","title":"getPersistentQueryType <pre><code>KsqlConstants.PersistentQueryType getPersistentQueryType()\n</code></pre> <p>One of the following:</p> <ul> <li><code>CREATE_SOURCE</code></li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>Used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to registerPersistentQuery and unregisterQuery</li> <li><code>PersistentQueryMetadataImpl</code> is created</li> <li><code>ValidatedCommandFactory</code> is requested to createForTerminateQuery</li> </ul>"},{"location":"PersistentQueryMetadata/#implementations","text":"<ul> <li><code>BinPackedPersistentQueryMetadataImpl</code></li> <li>PersistentQueryMetadataImpl</li> </ul>","title":"Implementations"},{"location":"PersistentQueryMetadataImpl/","text":"<p><code>PersistentQueryMetadataImpl</code> is a QueryMetadataImpl and a PersistentQueryMetadata.</p>","title":"PersistentQueryMetadataImpl"},{"location":"PersistentQueryMetadataImpl/#creating-instance","text":"<p><code>PersistentQueryMetadataImpl</code> takes the following to be created:</p> <ul> <li> <code>PersistentQueryType</code> <li> Statement Text <li> <code>PhysicalSchema</code> <li> Source Names <li> Sink DataSource <li> Execution Plan <li> <code>QueryId</code> <li> <code>MaterializationProviderBuilder</code> <li> Query Application ID <li> <code>Topology</code> (Kafka Streams) <li> KafkaStreamsBuilder <li> <code>QuerySchemas</code> <li> Streams Properties (<code>Map&lt;String, Object&gt;</code>) <li> Overrideen Properties (<code>Map&lt;String, Object&gt;</code>) <li> Close Timeout <li> <code>QueryErrorClassifier</code> <li> ExecutionStep <li> <code>maxQueryErrorsQueueSize</code> <li> <code>ProcessingLogger</code> <li> <code>retryBackoffInitialMs</code> <li> <code>retryBackoffMaxMs</code> <li> <code>QueryMetadata.Listener</code> <li> <code>ScalablePushRegistry</code>  <p><code>PersistentQueryMetadataImpl</code> is created when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildPersistentQueryInDedicatedRuntime</li> </ul>","title":"Creating Instance"},{"location":"PlanBuilder/","text":"<p><code>PlanBuilder</code> is an abstraction of query plan builders (for <code>QueryBuilder</code> to build a query implementation from an execution plan).</p>","title":"PlanBuilder"},{"location":"PlanBuilder/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"PlanBuilder/#visiting-streamsource","text":"","title":"Visiting StreamSource <pre><code>KStreamHolder&lt;GenericKey&gt; visitStreamSource(\n  StreamSource streamSource,\n  PlanInfo planInfo)\n</code></pre> <p>Visits a StreamSource</p> <p>See KSPlanBuilder</p> <p>Used when:</p> <ul> <li><code>StreamSource</code> is requested to build a KStreamHolder</li> </ul>"},{"location":"PlanBuilder/#visiting-tablesource","text":"","title":"Visiting TableSource <pre><code>KTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSourceV1 tableSourceV1,\n  PlanInfo planInfo)\nKTableHolder&lt;GenericKey&gt; visitTableSource(\n  TableSource tableSource,\n  PlanInfo planInfo)\n</code></pre> <p>See KSPlanBuilder</p> <p>Used when:</p> <ul> <li><code>TableSourceV1</code> is requested to <code>build</code> a <code>KTableHolder</code></li> <li><code>TableSource</code> is requested to <code>build</code> a <code>KTableHolder</code></li> </ul>"},{"location":"PlanBuilder/#implementations","text":"<ul> <li>KSPlanBuilder</li> </ul>","title":"Implementations"},{"location":"PlanInfoExtractor/","text":"<p><code>PlanInfoExtractor</code> is...FIXME</p>","title":"PlanInfoExtractor"},{"location":"PlanNode/","text":"<p><code>PlanNode</code> is an abstraction of nodes of a query plan.</p>","title":"PlanNode"},{"location":"PlanNode/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"PlanNode/#buildstream","text":"","title":"buildStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext)\n</code></pre> <p>Builds a SchemaKStream</p>"},{"location":"PlanNode/#implementations","text":"<ul> <li>DataSourceNode</li> <li>JoinNode</li> <li>SingleSourcePlanNode</li> </ul>","title":"Implementations"},{"location":"PlanNode/#creating-instance","text":"<p><code>PlanNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li>DataSourceType</li> <li> Source Name   <p>Abstract Class</p> <p><code>PlanNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete PlanNodes.</p>","title":"Creating Instance"},{"location":"PlanNode/#datasourcetype","text":"","title":"DataSourceType <p><code>PlanNode</code> is given a <code>DataSourceType</code> when created.</p>    DataSourceType ksqlType     KSTREAM STREAM   KTABLE TABLE"},{"location":"PullQueryValidator/","text":"<p><code>PullQueryValidator</code> is...FIXME</p>","title":"PullQueryValidator"},{"location":"QueryAnalyzer/","text":"","title":"QueryAnalyzer"},{"location":"QueryAnalyzer/#creating-instance","text":"<p><code>QueryAnalyzer</code> takes the following to be created:</p> <ul> <li> MetaStore <li> Output Topic Prefix <li> <code>rowpartitionRowoffsetEnabled</code> flag <li> <code>pullLimitClauseEnabled</code> flag  <p><code>QueryAnalyzer</code> is created when:</p> <ul> <li><code>KsqlEngine</code> is requested to analyzeQueryWithNoOutputTopic</li> <li><code>QueryEngine</code> utility is used to buildQueryLogicalPlan</li> </ul>","title":"Creating Instance"},{"location":"QueryAnalyzer/#analyzer","text":"","title":"Analyzer <p>Unless given, <code>QueryAnalyzer</code> creates an Analyzer when created.</p> <p>The <code>Analyzer</code> is used to analyze a query.</p>"},{"location":"QueryAnalyzer/#query-analysis","text":"","title":"Query Analysis <pre><code>Analysis analyze(\n  Query query,\n  Optional&lt;Sink&gt; sink)\n</code></pre> <p></p> <p><code>analyze</code> requests the Analyzer to analyze the query.</p> <p><code>analyze</code> requests the pull or push query validator to validate the analysis based on whether it is a pull query or not, respectively.</p>  <p>The optional <code>Sink</code> can only be defined when <code>QueryEngine</code> is requested to buildQueryLogicalPlan.</p>  <p><code>analyze</code> is used when:</p> <ul> <li><code>KsqlEngine</code> is requested to analyzeQueryWithNoOutputTopic</li> <li><code>QueryEngine</code> is requested to buildQueryLogicalPlan</li> </ul>"},{"location":"QueryApplicationId/","text":"","title":"QueryApplicationId"},{"location":"QueryApplicationId/#build","text":"","title":"build <pre><code>String build(\n  KsqlConfig config,\n  boolean persistent,\n  QueryId queryId)\n</code></pre> <p><code>build</code>...FIXME</p> <p><code>build</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested to <code>buildTransientQuery</code> and <code>buildPersistentQueryInDedicatedRuntime</code></li> <li><code>ListSourceExecutor</code> is requested to <code>queryOffsetSummaries</code></li> <li><code>KsqlRestoreCommandTopic</code> is requested to <code>maybeCleanUpQuery</code></li> </ul>"},{"location":"QueryBuilder/","text":"","title":"QueryBuilder"},{"location":"QueryBuilder/#creating-instance","text":"<p><code>QueryBuilder</code> takes the following to be created:</p> <ul> <li> <code>SessionConfig</code> <li> <code>ProcessingLogContext</code> <li> ServiceContext <li> <code>FunctionRegistry</code> <li>KafkaStreamsBuilder</li> <li> <code>MaterializationProviderBuilderFactory</code> <li> SharedKafkaStreamsRuntimes <li> <code>real</code> flag  <p><code>QueryBuilder</code> is created when:</p> <ul> <li><code>QueryRegistryImpl</code> is created</li> </ul>","title":"Creating Instance"},{"location":"QueryBuilder/#kafkastreamsbuilder","text":"","title":"KafkaStreamsBuilder <p><code>QueryBuilder</code> can be given a KafkaStreamsBuilder when created. Unless given, <code>QueryBuilder</code> creates a KafkaStreamsBuilderImpl with the KafkaClientSupplier from the given ServiceContext.</p> <p>The <code>KafkaStreamsBuilder</code> is used when:</p> <ul> <li>buildTransientQuery</li> <li>buildPersistentQueryInDedicatedRuntime</li> <li>getKafkaStreamsInstance</li> </ul>"},{"location":"QueryBuilder/#building-transient-query","text":"","title":"Building Transient Query <pre><code>TransientQueryMetadata buildTransientQuery(\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones,\n  QueryMetadata.Listener listener,\n  StreamsBuilder streamsBuilder,\n  Optional&lt;ImmutableMap&lt;TopicPartition, Long&gt;&gt; endOffsets)\n</code></pre>  <p>Kafka Streams</p> <p><code>buildTransientQuery</code> is given a new <code>StreamsBuilder</code> (Kafka Streams) that is used to build a RuntimeBuildContext and then a <code>Topology</code> (Kafka Streams).</p> <p>That means that the Kafka Streams topology can only be created while building the RuntimeBuildContext.</p>  <p><code>buildTransientQuery</code> requests the SessionConfig for the KsqlConfig (with overrides applied).</p> <p><code>buildTransientQuery</code> builds the following:</p> <ul> <li>Application ID (with <code>persistent</code> flag disabled)</li> <li>RuntimeBuildContext</li> <li>Configuration properties</li> <li>QueryImplementation</li> <li>TransientQueryQueue</li> </ul> <p><code>buildTransientQuery</code> requests the given <code>StreamsBuilder</code> (Kafka Streams) to build a <code>Topology</code> (Kafka Streams).</p> <p><code>buildTransientQuery</code> determines a <code>ResultType</code> (based on the <code>QueryImplementation</code> and the optional <code>windowInfo</code>):</p> <ul> <li><code>WINDOWED_TABLE</code> for a <code>KTableHolder</code> with the <code>windowInfo</code> specified</li> <li><code>TABLE</code> for a <code>KTableHolder</code> with no <code>windowInfo</code> specified</li> <li><code>STREAM</code> for all other cases</li> </ul> <p>In the end, <code>buildTransientQuery</code> creates a TransientQueryMetadata.</p> <p><code>buildTransientQuery</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to createTransientQuery and createStreamPullQuery</li> </ul>"},{"location":"QueryBuilder/#building-runtimebuildcontext","text":"","title":"Building RuntimeBuildContext <pre><code>RuntimeBuildContext buildContext(\n  String applicationId,\n  QueryId queryId,\n  StreamsBuilder streamsBuilder)\n</code></pre> <p><code>buildContext</code> creates a RuntimeBuildContext.</p> <p><code>buildContext</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildTransientQuery, buildPersistentQueryInDedicatedRuntime, buildPersistentQueryInSharedRuntime and getNamedTopology</li> </ul>"},{"location":"QueryBuilder/#building-query-implementation","text":"","title":"Building Query Implementation <pre><code>Object buildQueryImplementation(\n  ExecutionStep&lt;?&gt; physicalPlan,\n  RuntimeBuildContext runtimeBuildContext)\n</code></pre>  <p>Kafka Streams</p> <p>This is the moment in a ksqlDB query's life cycle when the physical plan is converted into a Kafka Streams application.</p>  <p><code>buildQueryImplementation</code> creates a KSPlanBuilder with the given RuntimeBuildContext.</p> <p>In the end, <code>buildQueryImplementation</code> requests the given physical plan to build a Kafka Streams application (with the <code>KSPlanBuilder</code>).</p> <p><code>buildQueryImplementation</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested to buildTransientQuery, buildPersistentQueryInDedicatedRuntime, buildPersistentQueryInSharedRuntime and getNamedTopology</li> </ul>"},{"location":"QueryBuilder/#createorreplacepersistentquery","text":"","title":"createOrReplacePersistentQuery <pre><code>PersistentQueryMetadata createOrReplacePersistentQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  Optional&lt;String&gt; sharedRuntimeId)\n</code></pre> <p><code>createOrReplacePersistentQuery</code>...FIXME</p> <p><code>createOrReplacePersistentQuery</code> is part of the QueryRegistry abstraction.</p>"},{"location":"QueryBuilder/#buildpersistentqueryinsharedruntime","text":"","title":"buildPersistentQueryInSharedRuntime <pre><code>PersistentQueryMetadata buildPersistentQueryInSharedRuntime(\n  KsqlConfig ksqlConfig,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  QueryMetadata.Listener listener,\n  Supplier&lt;List&lt;PersistentQueryMetadata&gt;&gt; allPersistentQueries,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildPersistentQueryInSharedRuntime</code>...FIXME</p>"},{"location":"QueryBuilder/#getkafkastreamsinstance","text":"","title":"getKafkaStreamsInstance <pre><code>SharedKafkaStreamsRuntime getKafkaStreamsInstance(\n  Set&lt;SourceName&gt; sources,\n  QueryId queryID,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>getKafkaStreamsInstance</code>...FIXME</p>"},{"location":"QueryBuilder/#buildpersistentqueryindedicatedruntime","text":"","title":"buildPersistentQueryInDedicatedRuntime <pre><code>PersistentQueryMetadata buildPersistentQueryInDedicatedRuntime(\n  KsqlConfig ksqlConfig,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  QueryMetadata.Listener listener,\n  Supplier&lt;List&lt;PersistentQueryMetadata&gt;&gt; allPersistentQueries,\n  StreamsBuilder streamsBuilder,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildPersistentQueryInDedicatedRuntime</code> builds an application ID (with the <code>persistent</code> flag enabled).</p> <p><code>buildPersistentQueryInDedicatedRuntime</code> buildStreamsProperties.</p> <p><code>buildPersistentQueryInDedicatedRuntime</code>...FIXME</p> <p><code>buildPersistentQueryInDedicatedRuntime</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to createOrReplacePersistentQuery (with a shared runtime ID)</li> </ul>"},{"location":"QueryBuilderFactory/","text":"<p><code>QueryBuilderFactory</code> is...FIXME</p>","title":"QueryBuilderFactory"},{"location":"QueryEngine/","text":"","title":"QueryEngine"},{"location":"QueryEngine/#building-logical-query-plan-buildquerylogicalplan","text":"","title":"Building Logical Query Plan (buildQueryLogicalPlan) <pre><code>OutputNode buildQueryLogicalPlan(\n  Query query,\n  Optional&lt;Sink&gt; sink,\n  MetaStore metaStore,\n  KsqlConfig config,\n  boolean rowpartitionRowoffsetEnabled)\n</code></pre> <p><code>buildQueryLogicalPlan</code> creates a QueryAnalyzer with the MetaStore and the values of the following configuration properties (from the given KsqlConfig):</p> <ul> <li>KSQL_OUTPUT_TOPIC_NAME_PREFIX_CONFIG</li> <li>KSQL_QUERY_PULL_LIMIT_CLAUSE_ENABLED</li> </ul> <p><code>buildQueryLogicalPlan</code> requests the <code>QueryAnalyzer</code> to analyze the given query.</p> <p>In the end, <code>buildQueryLogicalPlan</code> creates a LogicalPlanner to buildPersistentLogicalPlan.</p>  <p>The optional <code>Sink</code> can only be defined when <code>EngineExecutor</code> is requested to plan a statement (which is a QueryContainer).</p>  <p><code>buildQueryLogicalPlan</code> is used when:</p> <ul> <li><code>EngineExecutor</code> is requested to planQuery</li> </ul>"},{"location":"QueryEventListener/","text":"<p><code>QueryEventListener</code> is...FIXME</p>","title":"QueryEventListener"},{"location":"QueryLogger/","text":"<p><code>QueryLogger</code> is...FIXME</p>","title":"QueryLogger"},{"location":"QueryMetadata/","text":"<p><code>QueryMetadata</code> is...FIXME</p>","title":"QueryMetadata"},{"location":"QueryMetadataImpl/","text":"<p><code>QueryMetadataImpl</code> is a QueryMetadata.</p>","title":"QueryMetadataImpl"},{"location":"QueryMetadataImpl/#creating-instance","text":"<p><code>QueryMetadataImpl</code> takes the following to be created:</p> <ul> <li> Statement Text <li> <code>LogicalSchema</code> <li> Names of the Sources <li> Execution Plan <li> queryApplicationId <li> <code>Topology</code> <li>KafkaStreamsBuilder</li> <li> Streams Properties <li> overriddenProperties <li> <code>closeTimeout</code> <li> <code>QueryId</code> <li> <code>QueryErrorClassifier</code> <li> <code>maxQueryErrorsQueueSize</code> <li> <code>baseWaitingTimeMs</code> <li> <code>retryBackoffMaxMs</code> <li> <code>Listener</code>","title":"Creating Instance"},{"location":"QueryMetadataImpl/#kafkastreamsbuilder","text":"","title":"KafkaStreamsBuilder <p><code>QueryMetadataImpl</code> is given a KafkaStreamsBuilder when created.</p>"},{"location":"QueryMetadataImpl/#initialize","text":"","title":"initialize <pre><code>void initialize()\n</code></pre> <p><code>initialize</code> requests the KafkaStreamsBuilder to build a KafkaStreams instance (with the Topology and the streamsProperties).</p> <p><code>initialize</code> resets the KafkaStreams instance and turns the initialized flag on.</p> <p><code>initialize</code> is part of the QueryMetadata abstraction.</p>"},{"location":"QueryPlan/","text":"<p><code>QueryPlan</code> is...FIXME</p>","title":"QueryPlan"},{"location":"QueryRegistry/","text":"<p><code>QueryRegistry</code> is an abstraction of query registries for building and managing queries.</p>","title":"QueryRegistry"},{"location":"QueryRegistry/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"QueryRegistry/#createorreplacepersistentquery","text":"","title":"createOrReplacePersistentQuery <pre><code>PersistentQueryMetadata createOrReplacePersistentQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  Optional&lt;String&gt; sharedRuntimeId)\n</code></pre> <p>See QueryRegistryImpl.createOrReplacePersistentQuery</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to execute a persistent query</li> </ul>"},{"location":"QueryRegistry/#createtransientquery","text":"","title":"createTransientQuery <pre><code>TransientQueryMetadata createTransientQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones)\n</code></pre> <p>QueryRegistryImpl.createTransientQuery</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to executeTransientQuery</li> </ul>"},{"location":"QueryRegistry/#implementations","text":"<ul> <li>QueryRegistryImpl</li> </ul>","title":"Implementations"},{"location":"QueryRegistryImpl/","text":"","title":"QueryRegistryImpl"},{"location":"QueryRegistryImpl/#creating-transient-query","text":"","title":"Creating Transient Query <pre><code>TransientQueryMetadata createTransientQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Set&lt;SourceName&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  LogicalSchema schema,\n  OptionalInt limit,\n  Optional&lt;WindowInfo&gt; windowInfo,\n  boolean excludeTombstones)\n</code></pre> <p><code>createTransientQuery</code> requests the QueryBuilderFactory for a QueryBuilder.</p> <p><code>createTransientQuery</code> requests the <code>QueryBuilder</code> to build a transient query (with a new <code>StreamsBuilder</code> (Kafka Streams) that gives a TransientQueryMetadata).</p> <p><code>createTransientQuery</code> requests the <code>TransientQueryMetadata</code> to initialize.</p> <p><code>createTransientQuery</code> registerTransientQuery and returns the <code>TransientQueryMetadata</code>.</p>  <p><code>createTransientQuery</code> is part of the QueryRegistry abstraction.</p>"},{"location":"QueryRegistryImpl/#creating-or-replacing-persistent-query","text":"","title":"Creating or Replacing Persistent Query <pre><code>PersistentQueryMetadata createOrReplacePersistentQuery(\n  SessionConfig config,\n  ServiceContext serviceContext,\n  ProcessingLogContext processingLogContext,\n  MetaStore metaStore,\n  String statementText,\n  QueryId queryId,\n  Optional&lt;DataSource&gt; sinkDataSource,\n  Set&lt;DataSource&gt; sources,\n  ExecutionStep&lt;?&gt; physicalPlan,\n  String planSummary,\n  KsqlConstants.PersistentQueryType persistentQueryType,\n  Optional&lt;String&gt; sharedRuntimeId)\n</code></pre> <p><code>createOrReplacePersistentQuery</code> requests the QueryBuilderFactory for a QueryBuilder to build a persistent query in shared or dedicated runtime based on the given <code>sharedRuntimeId</code> (available or not, respectively).</p> <p>In the end, <code>createOrReplacePersistentQuery</code> registers the persistent query.</p>  <p><code>createOrReplacePersistentQuery</code> is part of the QueryRegistry abstraction.</p>"},{"location":"QueryRegistryImpl/#registerpersistentquery","text":"","title":"registerPersistentQuery <pre><code>void registerPersistentQuery(\n  ServiceContext serviceContext,\n  MetaStore metaStore,\n  PersistentQueryMetadata persistentQuery)\n</code></pre> <p><code>registerPersistentQuery</code> takes the <code>QueryId</code> from the given <code>PersistentQueryMetadata</code>.</p> <p><code>registerPersistentQuery</code> requests the given <code>PersistentQueryMetadata</code> to initialize when this is a new query (a new <code>QueryId</code>) or the old query is not sandboxed.</p> <p><code>registerPersistentQuery</code> adds the <code>QueryId</code> with the <code>PersistentQueryMetadata</code> to the persistentQueries registry.</p> <p><code>registerPersistentQuery</code> registers the persistent query based on the type:</p> <ul> <li> <p>For <code>CREATE_SOURCE</code>, the single source name with the query ID in the createAsQueries registry</p> </li> <li> <p>For <code>CREATE_AS</code>, the sink name with the query ID in the createAsQueries registry</p> </li> <li> <p>For <code>INSERT</code>, all the sink and source names with the query ID in the insertQueries registry</p> </li> </ul> <p><code>registerPersistentQuery</code> adds the <code>QueryId</code> with the <code>PersistentQueryMetadata</code> to the allLiveQueries registry.</p> <p>In the end, <code>registerPersistentQuery</code> notifies event listeners.</p>"},{"location":"QueryRegistryImpl/#notifying-queryeventlisteners-about-create-queries","text":"","title":"Notifying QueryEventListeners about Create Queries <pre><code>void notifyCreate(\n  ServiceContext serviceContext,\n  MetaStore metaStore,\n  QueryMetadata queryMetadata)\n</code></pre> <p><code>notifyCreate</code> requests the QueryEventListeners to onCreate</p> <p><code>notifyCreate</code> is used when:</p> <ul> <li><code>QueryRegistryImpl</code> is requested to create a StreamPullQuery and register persistent or transient queries</li> </ul>"},{"location":"QueryValidator/","text":"<p><code>QueryValidator</code> is...FIXME</p>","title":"QueryValidator"},{"location":"RewrittenAnalysis/","text":"<p><code>RewrittenAnalysis</code> is an ImmutableAnalysis.</p>","title":"RewrittenAnalysis"},{"location":"RuntimeBuildContext/","text":"","title":"RuntimeBuildContext"},{"location":"RuntimeBuildContext/#creating-instance","text":"<p><code>RuntimeBuildContext</code> takes the following to be created:</p> <ul> <li>StreamsBuilder</li> <li> KsqlConfig <li> ServiceContext <li> <code>ProcessingLogContext</code> <li> <code>FunctionRegistry</code> <li> Application ID <li> <code>QueryId</code> <li> <code>KeySerdeFactory</code> <li> <code>ValueSerdeFactory</code>  <p><code>RuntimeBuildContext</code> is created using of factory.</p>","title":"Creating Instance"},{"location":"RuntimeBuildContext/#streamsbuilder","text":"","title":"StreamsBuilder <p><code>RuntimeBuildContext</code> is given a <code>StreamsBuilder</code> (Kafka Streams) when created.</p> <p>The <code>StreamsBuilder</code> is used when:</p> <ul> <li><code>SourceBuilder</code> is requested to buildKTable</li> <li><code>SourceBuilderV1</code> is requested to buildKTable and buildKStream</li> </ul>"},{"location":"RuntimeBuildContext/#creating-runtimebuildcontext","text":"","title":"Creating RuntimeBuildContext <pre><code>RuntimeBuildContext of(\n  final StreamsBuilder streamsBuilder,\n  final KsqlConfig ksqlConfig,\n  final ServiceContext serviceContext,\n  final ProcessingLogContext processingLogContext,\n  final FunctionRegistry functionRegistry,\n  final String applicationId,\n  final QueryId queryId)\n</code></pre> <p><code>of</code> creates a RuntimeBuildContext (with a <code>GenericKeySerDe</code> and <code>GenericRowSerDe</code>).</p> <p><code>of</code> is used when:</p> <ul> <li><code>QueryBuilder</code> is requested for a RuntimeBuildContext</li> </ul>"},{"location":"SandboxedExecutionContext/","text":"<p><code>SandboxedExecutionContext</code> is a KsqlExecutionContext.</p>","title":"SandboxedExecutionContext"},{"location":"SandboxedExecutionContext/#creating-instance","text":"<p><code>SandboxedExecutionContext</code> takes the following to be created:</p> <ul> <li> EngineContext <li> ServiceContext  <p><code>SandboxedExecutionContext</code> is created when:</p> <ul> <li><code>KsqlEngine</code> is requested to createSandbox</li> <li><code>SandboxedExecutionContext</code> is requested to createSandbox</li> </ul>","title":"Creating Instance"},{"location":"SandboxedExecutionContext/#enginecontext","text":"","title":"EngineContext <p>While being created, <code>SandboxedExecutionContext</code> requests the given source EngineContext to create a sandboxed EngineContext.</p>"},{"location":"SandboxedExecutionContext/#query-planning-plan","text":"","title":"Query Planning (plan) <pre><code>KsqlPlan plan(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>plan</code> creates an EngineExecutor to plan the given <code>ConfiguredStatement</code>.</p> <p><code>plan</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"SandboxedExecutionContext/#executing-statement","text":"","title":"Executing Statement <pre><code>ExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;?&gt; statement) // (1)\nExecuteResult execute(\n  ServiceContext serviceContext,\n  ConfiguredKsqlPlan plan)\n</code></pre> <ol> <li>Plans the statement and creates a <code>ConfiguredKsqlPlan</code> for the other <code>execute</code></li> </ol> <p><code>execute</code> creates an EngineExecutor to execute the KsqlPlan (of the <code>ConfiguredKsqlPlan</code>) and produce an <code>ExecuteResult</code>.</p> <p><code>execute</code> requests the <code>ExecuteResult</code> for the QueryMetadata and get the KafkaStreams client that is closed right after.</p> <p>In the end, <code>execute</code> returns the <code>ExecuteResult</code>.</p> <p><code>execute</code> is part of the KsqlExecutionContext abstraction.</p>"},{"location":"SchemaKSourceFactory/","text":"","title":"SchemaKSourceFactory"},{"location":"SchemaKSourceFactory/#building-schemakstream","text":"","title":"Building SchemaKStream <pre><code>SchemaKStream&lt;?&gt; buildSource(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  QueryContext.Stacker contextStacker)\n</code></pre> <p><code>buildSource</code> requests the given DataSource whether it is windowed or not and the type.</p> <p>For <code>KSTREAM</code> type, <code>buildSource</code> builds a windowed or regular stream based on whether it is windowed or not, respectively.</p> <p>For <code>KTABLE</code> type, <code>buildSource</code> builds a windowed or regular table based on whether it is windowed or not, respectively.</p> <p><code>buildSource</code> is used when:</p> <ul> <li><code>DataSourceNode</code> is created</li> </ul>"},{"location":"SchemaKSourceFactory/#buildstream","text":"","title":"buildStream <pre><code>SchemaKStream&lt;?&gt; buildStream(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  Stacker contextStacker)\n</code></pre> <p><code>buildStream</code> creates a new SchemaKStream with a StreamSource.</p>"},{"location":"SchemaKSourceFactory/#buildwindowedstream","text":"","title":"buildWindowedStream <pre><code>SchemaKStream&lt;?&gt; buildWindowedStream(\n  PlanBuildContext buildContext,\n  DataSource dataSource,\n  Stacker contextStacker)\n</code></pre> <p><code>buildWindowedStream</code>...FIXME</p>"},{"location":"SchemaKSourceFactory/#schemakstream","text":"","title":"schemaKStream <pre><code>SchemaKStream&lt;K&gt; schemaKStream(\n  PlanBuildContext buildContext,\n  LogicalSchema schema,\n  KeyFormat keyFormat,\n  SourceStep&lt;KStreamHolder&lt;K&gt;&gt; streamSource)\n</code></pre> <p><code>schemaKStream</code> creates a SchemaKStream.</p>"},{"location":"SchemaKStream/","text":"<p><code>SchemaKStream&lt;K&gt;</code> is...FIXME</p>","title":"SchemaKStream"},{"location":"SchemaKStream/#creating-instance","text":"<p><code>SchemaKStream</code> takes the following to be created:</p> <ul> <li> ExecutionStep of <code>KStreamHolder&lt;K&gt;</code> <li> <code>LogicalSchema</code> <li> <code>KeyFormat</code> <li> KsqlConfig <li> <code>FunctionRegistry</code>  <p><code>SchemaKStream</code> is created when:</p> <ul> <li><code>SchemaKSourceFactory</code> is requested to schemaKStream</li> <li><code>SchemaKStream</code> is requested to into, filter, and others</li> </ul>","title":"Creating Instance"},{"location":"ServiceContext/","text":"<p><code>ServiceContext</code> is...FIXME</p>","title":"ServiceContext"},{"location":"SessionConfig/","text":"<p><code>SessionConfig</code> is...FIXME</p>","title":"SessionConfig"},{"location":"SharedKafkaStreamsRuntime/","text":"<p><code>SharedKafkaStreamsRuntime</code> is...FIXME</p>","title":"SharedKafkaStreamsRuntime"},{"location":"SharedKafkaStreamsRuntimeImpl/","text":"<p><code>SharedKafkaStreamsRuntimeImpl</code> is...FIXME</p>","title":"SharedKafkaStreamsRuntimeImpl"},{"location":"SingleSourcePlanNode/","text":"<p><code>SingleSourcePlanNode</code> is an extension of the PlanNode abstraction for plan nodes with one source.</p>","title":"SingleSourcePlanNode"},{"location":"SingleSourcePlanNode/#implementations","text":"<ul> <li><code>AggregateNode</code></li> <li><code>FilterNode</code></li> <li><code>FlatMapNode</code></li> <li>OutputNode</li> <li><code>PreJoinRepartitionNode</code></li> <li><code>ProjectNode</code></li> <li><code>QueryFilterNode</code></li> <li><code>QueryLimitNode</code></li> <li><code>SuppressNode</code></li> <li><code>UserRepartitionNode</code></li> </ul>","title":"Implementations"},{"location":"SingleSourcePlanNode/#creating-instance","text":"<p><code>SingleSourcePlanNode</code> takes the following to be created:</p> <ul> <li> <code>PlanNodeId</code> <li> <code>DataSourceType</code> <li> Source Name <li>Source</li>   <p>Abstract Class</p> <p><code>SingleSourcePlanNode</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete SingleSourcePlanNodes.</p>","title":"Creating Instance"},{"location":"SingleSourcePlanNode/#source-plannode","text":"","title":"Source PlanNode <p><code>SingleSourcePlanNode</code> is given a PlanNode when created.</p>"},{"location":"SingleSourcePlanNode/#getsources","text":"","title":"getSources <pre><code>List&lt;PlanNode&gt; getSources()\n</code></pre> <p><code>getSources</code> returns the source.</p> <p><code>getSources</code> is part of the PlanNode abstraction.</p>"},{"location":"SourceBuilder/","text":"<p><code>SourceBuilder</code> is a SourceBuilderBase.</p>","title":"SourceBuilder"},{"location":"SourceBuilder/#sourcebuilder-instance","text":"","title":"SourceBuilder Instance <p><code>SourceBuilder</code> defines <code>instance</code> static value with an instance of <code>SourceBuilder</code>.</p> <p>The <code>instance</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitTableSource</li> </ul>"},{"location":"SourceBuilder/#building-ktable","text":"","title":"Building KTable <pre><code>KTable&lt;K, GenericRow&gt; buildKTable(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator,\n  Materialized&lt;K, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt; materialized,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName,\n  PlanInfo planInfo)\n</code></pre> <p><code>buildKTable</code>...FIXME</p> <p><code>buildKTable</code> is part of the SourceBuilderBase abstraction.</p>"},{"location":"SourceBuilderBase/","text":"<p><code>SourceBuilderBase</code> is an abstraction of source builders (that <code>KSPlanBuilder</code> uses when visitTableSource).</p>","title":"SourceBuilderBase"},{"location":"SourceBuilderBase/#contract","text":"","title":"Contract"},{"location":"SourceBuilderBase/#building-ktable","text":"","title":"Building KTable <pre><code>KTable&lt;K, GenericRow&gt; buildKTable(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator,\n  Materialized&lt;K, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt; materialized,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName,\n  PlanInfo planInfo)\n</code></pre> <p>Builds a <code>KTable</code> (Kafka Streams)</p> <p>Used when:</p> <ul> <li><code>SourceBuilderBase</code> is requested to buildTable</li> <li><code>SourceBuilderV1</code> is requested to buildWindowedTable</li> </ul>"},{"location":"SourceBuilderBase/#building-table-materialized","text":"","title":"Building Table Materialized <pre><code>Materialized&lt;GenericKey, GenericRow, KeyValueStore&lt;Bytes, byte[]&gt;&gt;\nbuildTableMaterialized(\n  SourceStep&lt;KTableHolder&lt;GenericKey&gt;&gt; source,\n  RuntimeBuildContext buildContext,\n  MaterializedFactory materializedFactory,\n  Serde&lt;GenericKey&gt; keySerde,\n  Serde&lt;GenericRow&gt; valueSerde,\n  String stateStoreName)\n</code></pre> <p>Builds a <code>Materialized</code> (Kafka Streams)</p> <p>Used when:</p> <ul> <li><code>SourceBuilderBase</code> is requested to buildTable</li> </ul>"},{"location":"SourceBuilderBase/#implementations","text":"<ul> <li>SourceBuilder</li> <li>SourceBuilderV1</li> </ul>","title":"Implementations"},{"location":"SourceBuilderBase/#buildtable","text":"","title":"buildTable <pre><code>KTableHolder&lt;GenericKey&gt; buildTable(\n  RuntimeBuildContext buildContext,\n  SourceStep&lt;KTableHolder&lt;GenericKey&gt;&gt; source,\n  ConsumedFactory consumedFactory,\n  MaterializedFactory materializedFactory,\n  PlanInfo planInfo)\n</code></pre> <p><code>buildTable</code> gets a PhysicalSchema, a ValueSerde and a KeySerde (<code>Serde&lt;GenericKey&gt;</code>s).</p> <p><code>buildTable</code> buildSourceConsumed (with <code>AutoOffsetReset.EARLIEST</code> offset reset).</p> <p><code>buildTable</code> buildTableMaterialized and buildKTable (a <code>KTable&lt;GenericKey, GenericRow&gt;</code>).</p> <p>In the end, <code>buildTable</code> creates a <code>KTableHolder</code> (with the <code>KTable</code>).</p> <p><code>buildTable</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitTableSource</li> </ul>"},{"location":"SourceBuilderV1/","text":"<p><code>SourceBuilderV1</code> is a SourceBuilderBase.</p>","title":"SourceBuilderV1"},{"location":"SourceBuilderV1/#creating-instance","text":"<p><code>SourceBuilderV1</code> takes no arguments to be created.</p> <p><code>SourceBuilderV1</code> is created when the Java class is first loaded by JVM (and available using instance public static value).</p>","title":"Creating Instance"},{"location":"SourceBuilderV1/#sourcebuilderv1-instance","text":"","title":"SourceBuilderV1 Instance <p><code>SourceBuilderV1</code> uses an <code>instance</code> internal registry of the only application-wide <code>SourceBuilderV1</code> (that is created right when the class is loaded by JVM).</p>  <p>Note</p> <p><code>instance</code> is a <code>private static final</code> value.</p>  <p><code>instance</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitStreamSource, visitWindowedStreamSource, visitTableSource and visitWindowedTableSource</li> </ul>"},{"location":"SourceBuilderV1/#buildstream","text":"","title":"buildStream <pre><code>KStreamHolder&lt;GenericKey&gt; buildStream(\n  RuntimeBuildContext buildContext,\n  StreamSource source,\n  ConsumedFactory consumedFactory)\n</code></pre> <p><code>buildStream</code> gets a PhysicalSchema for the given StreamSource.</p> <p><code>buildStream</code> getValueSerde, getKeySerde and builds a Consumed.</p> <p><code>buildStream</code> builds a KStream (with the given StreamSource, the <code>Consumed</code> and a non-windowed <code>KeyGenerator</code>).</p> <p>In the end, <code>buildStream</code> creates a <code>KStreamHolder</code> for the <code>KStream</code>.</p> <p><code>buildStream</code> is used when:</p> <ul> <li><code>KSPlanBuilder</code> is requested to visitStreamSource</li> </ul>"},{"location":"SourceBuilderV1/#buildkstream","text":"","title":"buildKStream <pre><code>KStream&lt;K, GenericRow&gt; buildKStream(\n  SourceStep&lt;?&gt; streamSource,\n  RuntimeBuildContext buildContext,\n  Consumed&lt;K, GenericRow&gt; consumed,\n  Function&lt;K, Collection&lt;?&gt;&gt; keyGenerator)\n</code></pre> <p><code>buildKStream</code>...FIXME</p> <p><code>buildKStream</code> is used when:</p> <ul> <li><code>SourceBuilderV1</code> is requested to buildStream and buildWindowedStream</li> </ul>"},{"location":"SourceStep/","text":"<p><code>SourceStep&lt;K&gt;</code> is an extension of the ExecutionStep abstraction for source execution steps.</p>","title":"SourceStep"},{"location":"SourceStep/#implementations","text":"<ul> <li>StreamSource</li> <li><code>TableSource</code></li> <li><code>TableSourceV1</code></li> <li><code>WindowedStreamSource</code></li> <li><code>WindowedTableSource</code></li> </ul>","title":"Implementations"},{"location":"SourceStep/#creating-instance","text":"<p><code>SourceStep</code> takes the following to be created:</p> <ul> <li> <code>ExecutionStepPropertiesV1</code> <li> Topic Name <li> <code>Formats</code> <li> <code>TimestampColumn</code> <li> <code>LogicalSchema</code> <li> Pseudo Column Version   <p>Abstract Class</p> <p><code>SourceStep</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete SourceSteps.</p>","title":"Creating Instance"},{"location":"SqlPrimitiveType/","text":"<p><code>SqlPrimitiveType</code> is...FIXME</p>","title":"SqlPrimitiveType"},{"location":"SqlTypeParser/","text":"","title":"SqlTypeParser"},{"location":"SqlTypeParser/#demo","text":"<pre><code>import io.confluent.ksql.schema.ksql.SqlTypeParser\nval typeParser = SqlTypeParser.create(TypeRegistry.EMPTY)\n</code></pre>","title":"Demo"},{"location":"SqlTypeParser/#creating-instance","text":"<p><code>SqlTypeParser</code> takes the following to be created:</p> <ul> <li> TypeRegistry  <p><code>SqlTypeParser</code> is created using create factory.</p>","title":"Creating Instance"},{"location":"SqlTypeParser/#creating-sqltypeparser","text":"","title":"Creating SqlTypeParser <pre><code>SqlTypeParser create(\n  TypeRegistry typeRegistry)\n</code></pre> <p><code>create</code> creates a SqlTypeParser with the given <code>TypeRegistry</code>.</p> <p><code>create</code> is used when:</p> <ul> <li><code>UserFunctionLoader</code> is created</li> <li><code>AstBuilder.Visitor</code> is created</li> <li><code>SchemaParser</code> is requested to <code>parse</code> a schema</li> <li><code>SqlTypeDeserializer</code> is requested to <code>deserialize</code></li> <li><code>KsqlTargetUtil</code> is requested to <code>createSchema</code></li> </ul>"},{"location":"StreamSource/","text":"<p><code>StreamSource</code> is a SourceStep that builds a <code>KStream</code> (Kafka Streams).</p>","title":"StreamSource"},{"location":"StreamSource/#creating-instance","text":"<p><code>StreamSource</code> takes the following to be created:</p> <ul> <li> <code>ExecutionStepPropertiesV1</code> <li> Topic Name <li> <code>Formats</code> <li> <code>TimestampColumn</code> <li> <code>LogicalSchema</code> <li> Pseudo Column Version  <p><code>StreamSource</code> is created when:</p> <ul> <li><code>ExecutionStepFactory</code> is requested for a StreamSource</li> </ul>","title":"Creating Instance"},{"location":"StreamSource/#building-kstreamholder","text":"","title":"Building KStreamHolder <pre><code>KStreamHolder&lt;GenericKey&gt; build(\n  PlanBuilder builder,\n  PlanInfo info)\n</code></pre> <p><code>build</code> requests the given PlanBuilder to visitStreamSource (with this <code>StreamSource</code> and the given <code>PlanInfo</code>).</p> <p><code>build</code> is part of the ExecutionStep abstraction.</p>"},{"location":"TransientQueryMetadata/","text":"<p><code>TransientQueryMetadata</code> is...FIXME</p>","title":"TransientQueryMetadata"},{"location":"UserFunctionLoader/","text":"<p><code>UserFunctionLoader</code> is...FIXME</p>","title":"UserFunctionLoader"},{"location":"VersionCheckerAgent/","text":"<p><code>VersionCheckerAgent</code> is...FIXME</p>","title":"VersionCheckerAgent"},{"location":"debugging/","text":"<p>Start KsqlServerMain with the following JPDA configuration as part of <code>KSQL_OPTS</code> environment variable:</p> <pre><code>KSQL_OPTS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005\" \\\n./bin/ksql-run-class io.confluent.ksql.rest.server.KsqlServerMain \\\n  config/ksql-server.properties \\\n  --queries-file create-stream.sql\n</code></pre> <p>Create a new Configuration for Remove JVM Debug to attach to <code>KsqlServerMain</code>. Enjoy!</p>","title":"Debugging ksqlDB"},{"location":"overview/","text":"<p>ksqlDB is \"the database purpose-built for stream processing applications.\"</p> <p>ksqlDB uses KsqlServerMain to handle SQL queries (from the command line or sent through a REST endpoint, e.g. using ksql).</p> <pre><code>$ ./bin/ksql-server-start config/ksql-server.properties\n\n                  ===========================================\n                  =       _              _ ____  ____       =\n                  =      | | _____  __ _| |  _ \\| __ )      =\n                  =      | |/ / __|/ _` | | | | |  _ \\      =\n                  =      |   &lt;\\__ \\ (_| | | |_| | |_) |     =\n                  =      |_|\\_\\___/\\__, |_|____/|____/      =\n                  =                   |_|                   =\n                  =        The Database purpose-built       =\n                  =        for stream processing apps       =\n                  ===========================================\n\nCopyright 2017-2021 Confluent Inc.\n\nServer 7.2.0-0 listening on http://0.0.0.0:8088\n\nTo access the KSQL CLI, run:\nksql http://0.0.0.0:8088\n</code></pre> <p>ksqlDB uses Ksql as the command-line interactive environment.</p> <pre><code>$ ./bin/ksql\nksql&gt;\n</code></pre>","title":"ksqlDB"},{"location":"persistent-queries/","text":"<p>Persistent Queries (per <code>PersistentQueryType</code>) can be the following queries:</p> <ul> <li>CREATE_SOURCE</li> <li><code>CREATE_AS</code></li> <li><code>INSERT</code></li> </ul> <p>When Analyzer is requested to analyze a query it creates a Visitor with a flag to indicate whether the sink is defined or not for persistent queries.</p>","title":"Persistent Queries"},{"location":"persistent-queries/#create_source","text":"","title":"CREATE_SOURCE <p><code>CREATE_SOURCE</code>s don't write to a topic (so <code>EngineExecutor</code> does not have to check for read-only topics the other query types could attempt to write to).</p> <p>It is forbidden to terminate <code>CREATE_SOURCE</code> queries when linked to a source table (and <code>ValidatedCommandFactory</code> throws a KsqlStatementException):</p> <pre><code>Cannot terminate query '[queryId]' because it is linked to a source table.\n</code></pre> <p><code>EngineExecutor</code> will not execute <code>CREATE_SOURCE</code> plans when ksql.source.table.materialization.enabled is disabled and prints out the following INFO message to the logs instead:</p> <pre><code>Source table query '[statementText]' won't be materialized because 'ksql.source.table.materialization.enabled' is disabled.\n</code></pre> <p><code>CREATE_SOURCE</code> is used when:</p> <ul> <li><code>KsqlPlanV1</code> is requested for the getPersistentQueryType (with the queryPlan and the ddlCommand specified as a source <code>CreateTableCommand</code>)</li> <li><code>QueryBuilder</code> is requested to buildPersistentQueryInDedicatedRuntime and buildPersistentQueryInSharedRuntime</li> <li><code>QueryRegistryImpl</code> is requested to registerPersistentQuery and unregisterQuery</li> </ul>"},{"location":"cli/Cli/","text":"","title":"Cli"},{"location":"cli/Cli/#runcommand","text":"","title":"runCommand <pre><code>void runCommand(\n  String command)\n</code></pre> <p><code>runCommand</code> handleLine.</p> <p><code>runCommand</code> is used when:</p> <ul> <li><code>Ksql</code> is requested to run</li> </ul>"},{"location":"cli/Cli/#runinteractively","text":"","title":"runInteractively <pre><code>void runInteractively()\n</code></pre> <p><code>runInteractively</code>...FIXME</p> <p><code>runInteractively</code> is used when:</p> <ul> <li><code>Ksql</code> is requested to run</li> </ul>"},{"location":"cli/Cli/#handleline","text":"","title":"handleLine <pre><code>void handleLine(\n  String line)\n</code></pre> <p><code>handleLine</code> removes any leading and trailing spaces from the given <code>line</code> and handleStatements.</p> <p><code>handleLine</code> simply returns back when the given <code>line</code> is empty after trimming.</p> <p><code>handleLine</code> is used when:</p> <ul> <li><code>Cli</code> is requested to runScript, runCommand, runInteractively</li> </ul>"},{"location":"cli/Cli/#handlestatements","text":"","title":"handleStatements <pre><code>void handleStatements(\n  String line)\n</code></pre> <p><code>handleStatements</code> requests the DefaultKsqlParser to parse the given line (into <code>ParsedStatement</code>s).</p>  <p>Note</p> <p>There could be one or more <code>ParsedStatement</code>s in the given <code>line</code>.</p>  <p>For every <code>ParsedStatement</code>, <code>handleStatements</code> substituteVariables and...FIXME</p> <p><code>handleStatements</code>...FIXME</p>"},{"location":"cli/Cli/#substitutevariables","text":"","title":"substituteVariables <pre><code>ParsedStatement substituteVariables(\n  ParsedStatement statement)\n</code></pre> <p><code>substituteVariables</code>...FIXME</p>"},{"location":"cli/Cli/#isvariablesubstitutionenabled","text":"","title":"isVariableSubstitutionEnabled <pre><code>boolean isVariableSubstitutionEnabled()\n</code></pre> <p><code>isVariableSubstitutionEnabled</code>...FIXME</p>"},{"location":"cli/Ksql/","text":"<p><code>Ksql</code> is a standalone (command-line) application.</p>","title":"Ksql"},{"location":"cli/Ksql/#ksql-shell-script","text":"","title":"ksql Shell Script <p><code>Ksql</code> can be launched using <code>ksql</code> shell script (or <code>ksql-run-class</code> directly).</p> <pre><code>./bin/ksql-run-class io.confluent.ksql.Ksql\n</code></pre>"},{"location":"cli/Ksql/#launching-command-line-application","text":"","title":"Launching Command-Line Application <p><code>main</code>...FIXME</p>"},{"location":"cli/Ksql/#run","text":"","title":"run <pre><code>void run()\n</code></pre> <p><code>run</code>...FIXME</p>"},{"location":"embedded/EmbeddedKsql/","text":"<p><code>EmbeddedKsql</code> is a standalone (command-line) application.</p>","title":"EmbeddedKsql"},{"location":"embedded/KsqlContext/","text":"","title":"KsqlContext"},{"location":"embedded/KsqlContext/#creating-instance","text":"<p><code>KsqlContext</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlConfig <li> KsqlEngine <li> <code>BiFunction&lt;KsqlExecutionContext, ServiceContext, Injector&gt;</code>  <p><code>KsqlContext</code> is created when:</p> <ul> <li><code>KsqlContext</code> utility is used to create a KsqlContext</li> </ul>","title":"Creating Instance"},{"location":"embedded/KsqlContext/#creating-ksqlcontext","text":"","title":"Creating KsqlContext <pre><code>KsqlContext create(\n  KsqlConfig ksqlConfig,\n  ProcessingLogContext processingLogContext)\n</code></pre> <p><code>create</code>...FIXME</p> <p><code>create</code> is used when:</p> <ul> <li>EmbeddedKsql standalone application is launched</li> </ul>"},{"location":"parser/","text":"<p>ksqlDB uses AstBuilder to parse SQL statements (and build Statement nodes).</p>","title":"Query Parsing"},{"location":"parser/AstBuilder/","text":"<p><code>AstBuilder</code> uses Visitor to parse SQL statements (using ANTLR).</p>","title":"AstBuilder"},{"location":"parser/AstBuilder/#creating-instance","text":"<p><code>AstBuilder</code> takes the following to be created:</p> <ul> <li> <code>TypeRegistry</code>  <p><code>AstBuilder</code> is created when:</p> <ul> <li><code>QueryAnonymizer.Visitor</code> is requested to <code>visitExpression</code></li> <li><code>DefaultKsqlParser</code> is requested to prepare</li> <li><code>ExpressionParser</code> is requested to <code>parseSelectExpression</code>, <code>parseExpression</code>, <code>parseWindowExpression</code></li> </ul>","title":"Creating Instance"},{"location":"parser/AstBuilder/#building-statement","text":"","title":"Building Statement <pre><code>Statement buildStatement(\n  ParserRuleContext parseTree)\n</code></pre> <p><code>buildStatement</code> collects the source names (in a SQL statement) and builds a Statement.</p> <p><code>buildStatement</code> is used when:</p> <ul> <li><code>DefaultKsqlParser</code> is requested to prepare a ParsedStatement</li> </ul>"},{"location":"parser/AstBuilder/#collecting-source-names","text":"","title":"Collecting Source Names <pre><code>Set&lt;SourceName&gt; getSources(\n  ParseTree parseTree)\n</code></pre> <p><code>getSources</code> creates a SourceAccumulator to visit (the nodes of) the given <code>ParseTree</code>. In the end, <code>getSources</code> requests the <code>SourceAccumulator</code> for the sources.</p>"},{"location":"parser/AstBuilder/#building-parsed-tree-build","text":"","title":"Building Parsed Tree (build) <pre><code>&lt;T extends Node&gt; T build(\n  Optional&lt;Set&lt;SourceName&gt;&gt; sources, // (1)!\n  ParserRuleContext parseTree)\n</code></pre> <ol> <li>Only given when <code>AstBuilder</code> is requested to build a Statement</li> </ol> <p><code>build</code> creates a Visitor to build a node tree (for a given <code>ParserRuleContext</code> that represents a parsed SQL text).</p> <p><code>build</code> is used when:</p> <ul> <li><code>AstBuilder</code> is requested to build a Statement, an Expression, a WindowExpression and an AssertStatement</li> </ul>"},{"location":"parser/AstBuilder_Visitor/","text":"<p><code>Visitor</code> is a <code>SqlBaseBaseVisitor</code> to build a Node (that <code>AstBuilder</code> uses to build a parsed tree).</p>  <p>ANTLR</p> <p><code>SqlBaseBaseVisitor</code> is generated from <code>SqlBase.g4</code> SQL grammar by ANTLR at build time.</p>","title":"AstBuilder.Visitor"},{"location":"parser/AstBuilder_Visitor/#creating-instance","text":"<p><code>Visitor</code> takes the following to be created:</p> <ul> <li> Source Names <li> <code>TypeRegistry</code>  <p><code>Visitor</code> is created when:</p> <ul> <li><code>AstBuilder</code> is requested to build a parsed tree</li> </ul>","title":"Creating Instance"},{"location":"parser/AstBuilder_Visitor/#visitquery","text":"","title":"visitQuery <pre><code>Query visitQuery(\n  SqlBaseParser.QueryContext context)\n</code></pre> <p><code>visitQuery</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>SELECT</code> statements (queries).</p> <pre><code>query\n    : SELECT selectItem (',' selectItem)*\n      FROM from=relation\n      (WINDOW  windowExpression)?\n      (WHERE where=booleanExpression)?\n      (GROUP BY groupBy)?\n      (PARTITION BY partitionBy)?\n      (HAVING having=booleanExpression)?\n      (EMIT resultMaterialization)?\n      limitClause?\n    ;\n</code></pre> <p><code>visitQuery</code>...FIXME</p>"},{"location":"parser/AstBuilder_Visitor/#parsing-create-stream-statement-visitcreatestream","text":"","title":"Parsing CREATE STREAM Statement (visitCreateStream) <pre><code>Node visitCreateStream(\n  SqlBaseParser.CreateStreamContext context)\n</code></pre> <p><code>visitCreateStream</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE STREAM</code> statements.</p> <pre><code>CREATE (OR REPLACE)? (SOURCE)? STREAM (IF NOT EXISTS)? sourceName\n(tableElements)?\n(WITH tableProperties)?\n</code></pre> <p><code>visitCreateStream</code> creates an CreateStream.</p>"},{"location":"parser/AstBuilder_Visitor/#parsing-create-table-statement-visitcreatetable","text":"","title":"Parsing CREATE TABLE Statement (visitCreateTable) <pre><code>Node visitCreateTable(\n  SqlBaseParser.CreateTableContext context)\n</code></pre> <p><code>visitCreateTable</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>CREATE TABLE</code> statements.</p> <pre><code>CREATE (OR REPLACE)? (SOURCE)? TABLE (IF NOT EXISTS)? sourceName\n(tableElements)?\n(WITH tableProperties)?\n</code></pre> <p><code>visitCreateTable</code> creates an CreateTable.</p>"},{"location":"parser/AstBuilder_Visitor/#parsing-insert-into-statement-visitinsertinto","text":"","title":"Parsing INSERT INTO Statement (visitInsertInto) <pre><code>Node visitInsertInto(\n  SqlBaseParser.InsertIntoContext context)\n</code></pre> <p><code>visitInsertInto</code> is part of the <code>SqlBaseBaseVisitor</code> abstraction to handle <code>INSERT INTO</code> statements.</p> <pre><code>INSERT INTO sourceName (WITH tableProperties)? query\n</code></pre> <p><code>visitInsertInto</code> creates an InsertInto.</p>"},{"location":"parser/AstNode/","text":"<p><code>AstNode</code> is an extension of the Node abstraction for AST nodes.</p>","title":"AstNode"},{"location":"parser/AstNode/#contract","text":"","title":"Contract"},{"location":"parser/AstNode/#accept","text":"","title":"accept <pre><code>R accept(\n  AstVisitor&lt;R, C&gt; visitor,\n  C context)\n</code></pre> <p>Used when:</p> <ul> <li><code>AstVisitor</code> is requested to process a node</li> </ul>"},{"location":"parser/AstNode/#implementations","text":"<ul> <li>AstNode</li> <li><code>AlterOption</code></li> <li><code>AssertStatement</code></li> <li><code>GroupBy</code></li> <li><code>PartitionBy</code></li> <li><code>Relation</code></li> <li><code>Select</code></li> <li><code>SelectItem</code></li> <li>Statement</li> <li><code>Statements</code></li> <li><code>TableElement</code></li> <li><code>WindowExpression</code></li> <li><code>WithinExpression</code></li> </ul>","title":"Implementations"},{"location":"parser/AstVisitor/","text":"<p><code>AstVisitor&lt;R, C&gt;</code> is an abstraction of AST visitors.</p>","title":"AstVisitor"},{"location":"parser/AstVisitor/#implementations","text":"<ul> <li>DefaultTraversalVisitor</li> <li>others</li> </ul>","title":"Implementations"},{"location":"parser/CommonCreateConfigs/","text":"","title":"CommonCreateConfigs"},{"location":"parser/CommonCreateConfigs/#format","text":"","title":"FORMAT"},{"location":"parser/CommonCreateConfigs/#kafka_topic","text":"","title":"KAFKA_TOPIC <p>The topic that stores the data of the source</p> <p>Default: (undefined)</p>"},{"location":"parser/CommonCreateConfigs/#timestamp_format","text":"","title":"TIMESTAMP_FORMAT"},{"location":"parser/CommonCreateConfigs/#value_format","text":"","title":"VALUE_FORMAT <p>The format of the serialized value</p> <p>Default: (undefined)</p> <p>Overrides KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG</p> <p>Must not be specified with FORMAT</p> <p>Used when:</p> <ul> <li><code>DefaultSchemaInjector</code> is requested to <code>shouldInferSchema</code></li> <li><code>CreateSourceAsProperties</code> is requested for the value_format</li> <li><code>CreateSourceProperties</code> is requested for the value_format and to withFormats</li> </ul>"},{"location":"parser/CommonCreateConfigs/#partitions","text":"","title":"PARTITIONS <p>The number of partitions in the backing topic. Required if creating a source without an existing topic.</p> <p>Default: (undefined)</p>"},{"location":"parser/CommonCreateConfigs/#addtoconfigdef","text":"","title":"addToConfigDef <pre><code>void addToConfigDef(\n  ConfigDef configDef,\n  boolean topicNameRequired)\n</code></pre> <p><code>addToConfigDef</code> defines configuration properties (in the given <code>ConfigDef</code>).</p> <p><code>addToConfigDef</code> is used when:</p> <ul> <li><code>CreateAsConfigs</code> is created</li> <li><code>CreateConfigs</code> is created</li> </ul>"},{"location":"parser/CreateAsSelect/","text":"<p><code>CreateAsSelect</code> is...FIXME</p>","title":"CreateAsSelect"},{"location":"parser/CreateSource/","text":"<p><code>CreateSource</code> is an extension of the Statement abstraction for CREATE SOURCE statements.</p>","title":"CreateSource"},{"location":"parser/CreateSource/#contract","text":"","title":"Contract"},{"location":"parser/CreateSource/#copywith","text":"","title":"copyWith <pre><code>CreateSource copyWith(\n  TableElements elements,\n  CreateSourceProperties properties)\n</code></pre>"},{"location":"parser/CreateSource/#getsourcetype","text":"","title":"getSourceType <pre><code>SourceType getSourceType()\n</code></pre>"},{"location":"parser/CreateSource/#implementations","text":"<ul> <li>CreateStream</li> <li><code>CreateTable</code></li> </ul>","title":"Implementations"},{"location":"parser/CreateSource/#creating-instance","text":"<p><code>CreateSource</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>SourceName</code> <li> <code>TableElements</code> <li> <code>orReplace</code> flag <li> <code>notExists</code> flag <li> CreateSourceProperties <li> <code>isSource</code> flag   <p>Abstract Class</p> <p><code>CreateSource</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete CreateSources.</p>","title":"Creating Instance"},{"location":"parser/CreateSourceAsProperties/","text":"<p><code>CreateSourceAsProperties</code> is...FIXME</p>","title":"CreateSourceAsProperties"},{"location":"parser/CreateSourceProperties/","text":"","title":"CreateSourceProperties"},{"location":"parser/CreateSourceProperties/#creating-instance","text":"<p><code>CreateSourceProperties</code> takes the following to be created:</p> <ul> <li> Originals (<code>Map&lt;String, Literal&gt;</code>) <li> Duration Parser (<code>Function&lt;String, Duration&gt;</code>)  <p><code>CreateSourceProperties</code> is created using from factory and when:</p> <ul> <li>withKeyValueSchemaName</li> <li>withPartitions</li> <li>withFormats</li> </ul> <p>While being created, <code>CreateSourceProperties</code> creates a PropertiesConfig and performs parameter validations.</p>","title":"Creating Instance"},{"location":"parser/CreateSourceProperties/#creating-createsourceproperties","text":"","title":"Creating CreateSourceProperties <pre><code>CreateSourceProperties from(\n  Map&lt;String, Literal&gt; literals)\n</code></pre> <p><code>from</code> creates a CreateSourceProperties (with the given <code>literals</code> and the default <code>DurationParser</code>).</p> <p><code>from</code> is used when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to visitCreateTable, visitCreateStream, visitAssertStream and visitAssertTable</li> </ul>"},{"location":"parser/CreateSourceProperties/#propertiesconfig","text":"","title":"PropertiesConfig <p>When created, <code>CreateSourceProperties</code> creates a <code>PropertiesConfig</code> with the following configuration properties.</p>"},{"location":"parser/CreateSourceProperties/#source_connector","text":"","title":"SOURCE_CONNECTOR <p>Indicates that this source was created by a connector with the given name.</p> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#window_size","text":"","title":"WINDOW_SIZE <p>Window size of <code>HOPPING</code> or <code>TUMBLING</code> windows, e.g. <code>20 SECONDS</code></p> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#window_type","text":"","title":"WINDOW_TYPE <p>Supported values:</p> <ul> <li><code>SESSION</code></li> <li><code>HOPPING</code></li> <li><code>TUMBLING</code></li> </ul> <p>Default: <code>null</code></p>"},{"location":"parser/CreateSourceProperties/#value_format","text":"","title":"value_format <pre><code>Optional&lt;FormatInfo&gt; getValueFormat()\n</code></pre> <p><code>getValueFormat</code> takes FORMAT (if defined) or defaults to VALUE_FORMAT property (using the PropertiesConfig).</p> <p>If defined (using either configuration property), the value format is converted to <code>FormatInfo</code> (with getValueFormatProperties).</p> <p><code>getValueFormat</code> is used when:</p> <ul> <li><code>DefaultFormatInjector</code> is requested to <code>injectForCreateStatement</code></li> <li><code>SourcePropertiesUtil</code> is requested to getValueFormat</li> </ul>"},{"location":"parser/CreateStream/","text":"<p><code>CreateStream</code> is a CreateSource and a ExecutableDdlStatement that represents the following SQL statements:</p> <pre><code>CREATE (OR REPLACE)? (SOURCE)? STREAM (IF NOT EXISTS)? sourceName\n  (tableElements)?\n  (WITH tableProperties)?\n</code></pre> <pre><code>ASSERT STREAM sourceName (tableElements)? (WITH tableProperties)?\n</code></pre>","title":"CreateStream"},{"location":"parser/CreateStream/#creating-instance","text":"<p><code>CreateStream</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>SourceName</code> <li> <code>TableElements</code> <li> <code>orReplace</code> flag <li> <code>notExists</code> flag <li> CreateSourceProperties <li> <code>isSource</code> flag  <p><code>CreateStream</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to visitCreateStream and visitAssertStream</li> </ul>","title":"Creating Instance"},{"location":"parser/CreateTable/","text":"<p><code>CreateTable</code> is...FIXME</p>","title":"CreateTable"},{"location":"parser/DdlStatement/","text":"<p><code>DdlStatement</code> is...FIXME</p>","title":"DdlStatement"},{"location":"parser/DefaultKsqlParser/","text":"<p><code>DefaultKsqlParser</code> is a KsqlParser.</p>","title":"DefaultKsqlParser"},{"location":"parser/DefaultKsqlParser/#creating-instance","text":"<p><code>DefaultKsqlParser</code> takes no arguments to be created.</p> <p><code>DefaultKsqlParser</code> is created when:</p> <ul> <li><code>Cli</code> is created</li> <li><code>EngineContext</code> utility is used to create an EngineContext and createSandbox</li> <li><code>KsqlResource</code> is requested for TERMINATE_CLUSTER</li> </ul>","title":"Creating Instance"},{"location":"parser/DefaultKsqlParser/#parsing-sql-statements-parse","text":"","title":"Parsing SQL Statements (parse) <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p><code>parse</code> parses the given <code>sql</code> (using ANTLR) and creates as many <code>ParsedStatement</code>s as there are SQL statements in the <code>sql</code>.</p>  <p>ANTLR</p> <p>This is when a SQL text is parsed (transformed) using ANTLR into a collection of ksqlDB's <code>ParsedStatement</code>s according to the <code>SqlBase.g4</code> grammar:</p> <pre><code>statements\n    : (singleStatement)* EOF\n    ;\n</code></pre> <p>Every <code>ParsedStatement</code>s maps exactly to a <code>singleStatement</code>.</p>  <p><code>parse</code> is part of the KsqlParser abstraction.</p>"},{"location":"parser/DefaultKsqlParser/#preparing-parsedstatement-prepare","text":"","title":"Preparing ParsedStatement (prepare) <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement stmt,\n  TypeRegistry typeRegistry)\n</code></pre> <p><code>prepare</code> creates an AstBuilder (with the given <code>TypeRegistry</code>) to build a Statement.</p> <p>In the end, <code>prepare</code> creates a <code>PreparedStatement</code> (with the SQL query in text format and as the Statement).</p>  <p><code>prepare</code> is part of the KsqlParser abstraction.</p>"},{"location":"parser/DefaultTraversalVisitor/","text":"<p><code>DefaultTraversalVisitor</code> is an extension of the AstVisitor abstraction for AST visitors with default implementation of the parent abstraction.</p>","title":"DefaultTraversalVisitor"},{"location":"parser/DefaultTraversalVisitor/#implementations","text":"<ul> <li><code>SourceTopicsExtractor</code></li> <li>Analyzer.Visitor</li> <li><code>DataSourceExtractor.Visitor</code></li> </ul>","title":"Implementations"},{"location":"parser/ExecutableDdlStatement/","text":"<p><code>ExecutableDdlStatement</code> is...FIXME</p>","title":"ExecutableDdlStatement"},{"location":"parser/Expression/","text":"<p><code>Expression</code> is...FIXME</p>","title":"Expression"},{"location":"parser/InsertInto/","text":"<p><code>InsertInto</code> is a Statement and a QueryContainer.</p>","title":"InsertInto"},{"location":"parser/InsertInto/#creating-instance","text":"<p><code>InsertInto</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> Source Name <li> Query <li> <code>InsertIntoProperties</code>  <p><code>InsertInto</code> is created when:</p> <ul> <li><code>AstBuilder.Visitor</code> is requested to parse INSERT INTO statement</li> <li><code>StatementRewriter.Rewriter</code> is requested to <code>visitInsertInto</code></li> </ul>","title":"Creating Instance"},{"location":"parser/KsqlParser/","text":"<p><code>KsqlParser</code> is an abstraction of SQL parsers.</p>","title":"KsqlParser"},{"location":"parser/KsqlParser/#contract","text":"","title":"Contract"},{"location":"parser/KsqlParser/#parsing-sql-statements","text":"","title":"Parsing SQL Statements <pre><code>List&lt;ParsedStatement&gt; parse(\n  String sql)\n</code></pre> <p>Parses the given SQL text into a collection of <code>ParsedStatement</code>s. There can be zero, one or more SQL statements in the given SQL text.</p> <p>See DefaultKsqlParser</p> <p>Used when:</p> <ul> <li><code>Cli</code> is requested to substituteVariables and handleStatements</li> <li><code>EngineContext</code> is requested to parse SQL statements</li> <li><code>KsqlResource</code> is requested for TERMINATE_CLUSTER</li> </ul>"},{"location":"parser/KsqlParser/#preparing-parsedstatement","text":"","title":"Preparing ParsedStatement <pre><code>PreparedStatement&lt;?&gt; prepare(\n  ParsedStatement statement,\n  TypeRegistry typeRegistry)\n</code></pre> <p>See DefaultKsqlParser</p> <p>Used when:</p> <ul> <li><code>EngineContext</code> is requested to prepare a ParsedStatement</li> </ul>"},{"location":"parser/KsqlParser/#implementations","text":"<ul> <li>DefaultKsqlParser</li> </ul>","title":"Implementations"},{"location":"parser/KsqlWindowExpression/","text":"<p><code>KsqlWindowExpression</code> is...FIXME</p>","title":"KsqlWindowExpression"},{"location":"parser/Node/","text":"<p><code>Node</code> is an abstraction of nodes of trees that are result of parsing SQL statements (using AstBuilder.Visitor).</p>","title":"Node"},{"location":"parser/Node/#implementations","text":"<ul> <li>AstNode</li> <li>Expression</li> <li>KsqlWindowExpression</li> </ul>","title":"Implementations"},{"location":"parser/Node/#creating-instance","text":"<p><code>Node</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> (with line and column numbers)   <p>Abstract Class</p> <p><code>Node</code> is an abstract class and cannot be created directly. It is created indirectly for the concrete Nodes.</p>","title":"Creating Instance"},{"location":"parser/Query/","text":"<p><code>Query</code> is a Statement.</p>","title":"Query"},{"location":"parser/Query/#creating-instance","text":"<p><code>Query</code> takes the following to be created:</p> <ul> <li> <code>NodeLocation</code> <li> <code>Select</code> <li> <code>Relation</code> <li> <code>WindowExpression</code> <li> <code>Expression</code> <li> <code>GroupBy</code> <li> <code>PartitionBy</code> <li> <code>Expression</code> <li> <code>RefinementInfo</code> <li> <code>pullQuery</code> flag <li> Limit  <p><code>Query</code> is created when:</p> <ul> <li><code>EngineExecutor</code> is requested to sourceTablePlan</li> <li><code>Rewriter</code> is requested to <code>visitQuery</code></li> <li><code>AstBuilder.Visitor</code> is requested to visitQuery</li> </ul>","title":"Creating Instance"},{"location":"parser/QueryContainer/","text":"<p><code>QueryContainer</code> is an abstraction of SQL statements with a query.</p>","title":"QueryContainer"},{"location":"parser/QueryContainer/#contract","text":"","title":"Contract"},{"location":"parser/QueryContainer/#getquery","text":"","title":"getQuery <pre><code>Query getQuery()\n</code></pre> <p>Query</p> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a ConfiguredStatement</li> <li><code>TopicCreateInjector</code> is requested to <code>injectForCreateAsSelect</code></li> <li><code>DefaultTraversalVisitor</code> is requested to visitInsertInto, visitCreateStreamAsSelect, visitCreateTableAsSelect</li> <li>a few others</li> </ul>"},{"location":"parser/QueryContainer/#getqueryid","text":"","title":"getQueryId <pre><code>Optional&lt;String&gt; getQueryId()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a ConfiguredStatement</li> </ul>"},{"location":"parser/QueryContainer/#getsink","text":"","title":"getSink <pre><code>Sink getSink()\n</code></pre> <p>Used when:</p> <ul> <li><code>EngineExecutor</code> is requested to plan a statement</li> </ul>"},{"location":"parser/QueryContainer/#implementations","text":"<ul> <li>CreateAsSelect</li> <li>InsertInto</li> </ul>","title":"Implementations"},{"location":"parser/SourceAccumulator/","text":"<p><code>SourceAccumulator</code> is a <code>SqlBaseBaseVisitor</code> to collect source relations (possibly aliased) in a SQL query.</p> <pre><code>aliasedRelation\n    : relationPrimary (AS? sourceName)?\n    ;\n\nrelationPrimary\n    : sourceName                        #tableName\n    ;\n</code></pre>  <p>Note</p> <p><code>SqlBaseBaseVisitor</code> is generated from <code>io/confluent/ksql/parser/SqlBase.g4</code> at build time by ANTLR.</p>","title":"SourceAccumulator"},{"location":"parser/SourceAccumulator/#visitcreatestream","text":"","title":"visitCreateStream <p>Creates a CreateStream</p>"},{"location":"parser/SourcePropertiesUtil/","text":"","title":"SourcePropertiesUtil"},{"location":"parser/SourcePropertiesUtil/#getvalueformat","text":"","title":"getValueFormat <pre><code>FormatInfo getValueFormat(\n  CreateSourceProperties properties)\n</code></pre> <p><code>getValueFormat</code> takes the value_format property from the given CreateSourceProperties or throws an <code>IllegalStateException</code>:</p> <pre><code>Value format not present\n</code></pre> <p><code>getValueFormat</code> is used when:</p> <ul> <li><code>CreateSourceFactory</code> is requested to buildFormats</li> <li><code>DefaultSchemaInjector</code> is requested to <code>getValueSchema</code></li> <li><code>SchemaRegisterInjector</code> is requested to <code>registerForCreateSource</code></li> </ul>"},{"location":"parser/Statement/","text":"<p><code>Statement</code> is an extension of the AstNode abstraction for SQL statements after parsing from an AST tree.</p>","title":"Statement"},{"location":"parser/Statement/#implementations","text":"<ul> <li><code>AlterSource</code></li> <li><code>AlterSystemProperty</code></li> <li>CreateAsSelect</li> <li><code>CreateConnector</code></li> <li>CreateSource</li> <li><code>DefineVariable</code></li> <li><code>DescribeConnector</code></li> <li><code>DescribeFunction</code></li> <li><code>DropConnector</code></li> <li><code>DropStatement</code></li> <li><code>DropType</code></li> <li><code>Explain</code></li> <li>InsertInto</li> <li><code>InsertValues</code></li> <li><code>ListConnectorPlugins</code></li> <li><code>ListConnectors</code></li> <li><code>ListFunctions</code></li> <li><code>ListProperties</code></li> <li><code>ListTypes</code></li> <li><code>ListVariables</code></li> <li><code>PrintTopic</code></li> <li>Query</li> <li><code>RegisterType</code></li> <li><code>SetProperty</code></li> <li><code>StatementWithExtendedClause</code></li> <li><code>TerminateCluster</code></li> <li><code>TerminateQuery</code></li> <li><code>UndefineVariable</code></li> <li><code>UnsetProperty</code></li> </ul>","title":"Implementations"},{"location":"parser/VariableSubstitutor/","text":"","title":"VariableSubstitutor"},{"location":"parser/VariableSubstitutor/#variable-substitution-substitute","text":"","title":"Variable Substitution (substitute) <pre><code>String substitute(\n  KsqlParser.ParsedStatement parsedStatement,\n  Map&lt;String, String&gt; valueMap)\nString substitute(\n  String string,\n  Map&lt;String, String&gt; valueMap)\n</code></pre> <p><code>substitute</code> replaces variables in the SQL text (either as a <code>ParsedStatement</code> or a <code>String</code> using SqlSubstitutorVisitor).</p> <p><code>substitute</code> is used when:</p> <ul> <li><code>Cli</code> is requested to substituteVariables</li> <li><code>EngineContext</code> is requested to substituteVariables</li> <li><code>CommandParser</code> is used</li> </ul>"},{"location":"parser/VariableSubstitutor/#sqlsubstitutorvisitor","text":"","title":"SqlSubstitutorVisitor <p><code>SqlSubstitutorVisitor</code> is a <code>SqlBaseBaseVisitor</code> (that <code>VariableSubstitutor</code> uses for variable substitution).</p>  <p>ANTLR</p> <p><code>SqlBaseBaseVisitor</code> is generated from <code>SqlBase.g4</code> SQL grammar by ANTLR at build time.</p>"},{"location":"parser/VariableSubstitutor/#replace","text":"","title":"replace <pre><code>String replace(\n  SqlBaseParser.SingleStatementContext singleStatementContext)\n</code></pre> <p><code>replace</code> walks the statement tree (using <code>visit</code>) and then uses <code>StringSubstitutor.replace</code> (Commons Text) to substitute variables.</p>"},{"location":"rest/Command/","text":"","title":"Command"},{"location":"rest/Command/#creating-instance","text":"<p><code>Command</code> takes the following to be created:</p> <ul> <li> Statement Text <li> Overwrite Properties (<code>Map&lt;String, Object&gt;</code>) <li> Original Properties (<code>Map&lt;String, String&gt;</code>) <li> KsqlPlan <li> Version <li> Expected Version  <p><code>Command</code> is created using of utilities and when:</p> <ul> <li><code>RestoreCommandsCompactor</code> is requested to <code>compact</code></li> </ul>","title":"Creating Instance"},{"location":"rest/Command/#creating-command","text":"","title":"Creating Command <pre><code>Command of(\n  ConfiguredKsqlPlan configuredPlan)\nCommand of(\n  ConfiguredStatement&lt;?&gt; configuredStatement)\n</code></pre> <p><code>of</code> creates a Command.</p> <p><code>of</code> is used when:</p> <ul> <li><code>ValidatedCommandFactory</code> utility is used to createForPlannedQuery, createCommand, createForAlterSystemQuery, createForTerminateQuery</li> </ul>"},{"location":"rest/CommandQueue/","text":"<p><code>CommandQueue</code> is an abstraction of command queues.</p>","title":"CommandQueue"},{"location":"rest/CommandQueue/#contract-subset","text":"","title":"Contract (Subset)"},{"location":"rest/CommandQueue/#enqueuecommand","text":"","title":"enqueueCommand <pre><code>QueuedCommandStatus enqueueCommand(\n  CommandId commandId,\n  Command command,\n  Producer&lt;CommandId, Command&gt; transactionalProducer)\n</code></pre> <p>See CommandStore</p> <p>Used when:</p> <ul> <li><code>DistributingExecutor</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/CommandQueue/#implementations","text":"<ul> <li>CommandStore</li> </ul>","title":"Implementations"},{"location":"rest/CommandRunner/","text":"","title":"CommandRunner"},{"location":"rest/CommandRunner/#creating-instance","text":"<p><code>CommandRunner</code> takes the following to be created:</p> <ul> <li> InteractiveStatementExecutor <li> CommandQueue <li> <code>maxRetries</code> <li> <code>ClusterTerminator</code> <li> <code>ServerState</code> <li> ksql Service ID <li> commandRunnerHealth Timeout <li> metricsGroup Prefix <li>Command Deserializer</li> <li> Error Handler <li> <code>KafkaTopicClient</code> <li> Name of the Command Topic <li> <code>Metrics</code>  <p><code>CommandRunner</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication</li> </ul>","title":"Creating Instance"},{"location":"rest/CommandRunner/#command-deserializer","text":"","title":"Command Deserializer <p><code>CommandRunner</code> is given a <code>Deserializer</code> (Apache Kafka) of Commands when created.</p> <p>The <code>Deserializer</code> is used in the following:</p> <ul> <li>processPriorCommands</li> <li>start (to fetchAndRunCommands and executeStatement)</li> </ul>"},{"location":"rest/CommandRunner/#start-processing-queued-commands","text":"","title":"Start Processing Queued Commands <pre><code>void start()\n</code></pre> <p><code>start</code> creates and starts a Java thread (on a single-threaded thread pool) to continuously fetchAndRunCommands.</p> <p>Every time fetchAndRunCommands is executed, the thread prints out the following TRACE message to the logs:</p> <pre><code>Polling for new writes to command topic\n</code></pre> <p><code>start</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> </ul>"},{"location":"rest/CommandRunner/#fetching-and-running-queued-commands","text":"","title":"Fetching and Running Queued Commands <pre><code>void fetchAndRunCommands()\n</code></pre> <p><code>fetchAndRunCommands</code> requests the CommandQueue for new commands.</p> <p><code>fetchAndRunCommands</code> prints out the following DEBUG message to the logs:</p> <pre><code>Found [size] new writes to command topic\n</code></pre> <p>For every queued command, <code>fetchAndRunCommands</code> execute the statement.</p>"},{"location":"rest/CommandRunner/#executing-statement","text":"","title":"Executing Statement <pre><code>void executeStatement(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>executeStatement</code> uses the commandDeserializer to deserialize a SQL statement (from the <code>QueuedCommand</code>).</p> <p><code>executeStatement</code> prints out the following INFO message to the logs:</p> <pre><code>Executing statement: [commandStatement]\n</code></pre> <p><code>executeStatement</code> creates a Java <code>Runnable</code> which, when run, requests the InteractiveStatementExecutor to handle the statement and prints out the following INFO message to the logs:</p> <pre><code>Executed statement: [commandStatement]\n</code></pre>"},{"location":"rest/CommandRunner/#processpriorcommands","text":"","title":"processPriorCommands <pre><code>void processPriorCommands(\n  PersistentQueryCleanupImpl queryCleanup)\n</code></pre> <p><code>processPriorCommands</code>...FIXME</p> <p><code>processPriorCommands</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to initialize</li> </ul>"},{"location":"rest/CommandStore/","text":"","title":"CommandStore"},{"location":"rest/CommandStore/#creating-instance","text":"<p><code>CommandStore</code> takes the following to be created:</p> <ul> <li> Name of the Command Topic <li> <code>CommandTopic</code> <li> <code>SequenceNumberFutureStore</code> <li> Kafka Consumer Properties <li> Kafka Producer Properties <li> Command Queue Catchup Timeout <li> <code>Serializer&lt;CommandId&gt;</code> <li> <code>Serializer&lt;Command&gt;</code> <li> <code>Deserializer&lt;CommandId&gt;</code> <li> <code>CommandTopicBackup</code>  <p><code>CommandStore</code> is created using create utility.</p>","title":"Creating Instance"},{"location":"rest/CommandStore/#creating-commandstore","text":"","title":"Creating CommandStore <pre><code>CommandStore create(\n  KsqlConfig ksqlConfig,\n  String commandTopicName,\n  Duration commandQueueCatchupTimeout,\n  Map&lt;String, Object&gt; kafkaConsumerProperties,\n  Map&lt;String, Object&gt; kafkaProducerProperties,\n  ServiceContext serviceContext)\n</code></pre> <p><code>create</code>...FIXME</p> <p><code>create</code> is used when:</p> <ul> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication instance</li> </ul>"},{"location":"rest/CommandStore/#enqueuecommand","text":"","title":"enqueueCommand <pre><code>QueuedCommandStatus enqueueCommand(\n  CommandId commandId,\n  Command command,\n  Producer&lt;CommandId, Command&gt; transactionalProducer)\n</code></pre> <p><code>enqueueCommand</code> creates a <code>ProducerRecord</code> (Apache Kafka) as follows:</p> <ul> <li>Topic: commandTopicName</li> <li>Partition: <code>0</code></li> <li>Key: the given <code>commandId</code></li> <li>Value: the given Command</li> </ul> <p><code>enqueueCommand</code> requests the given <code>transactionalProducer</code> to send the record.</p> <p><code>enqueueCommand</code> returns a <code>QueuedCommandStatus</code> with the record offset (and a <code>CommandStatusFuture</code>).</p> <p><code>enqueueCommand</code> is part of the CommandQueue abstraction.</p>"},{"location":"rest/CustomExecutors/","text":"<p><code>CustomExecutors</code> is a collection of StatementExecutors that do not need to be distributed.</p> <p>    Enum Name Class StatementExecutor      <code>CreateConnector</code> <code>ConnectExecutor::execute</code>    <code>DefineVariable</code> <code>VariableExecutor::set</code>    <code>DescribeConnector</code> <code>DescribeConnectorExecutor::execute</code>    <code>DescribeFunction</code> <code>DescribeFunctionExecutor::execute</code>   <code>DESCRIBE_STREAMS</code> <code>DescribeStreams</code> <code>ListSourceExecutor::describeStreams</code>   <code>DESCRIBE_TABLES</code> <code>DescribeTables</code> <code>ListSourceExecutor::describeTables</code>    <code>DropConnector</code> <code>DropConnectorExecutor::execute</code>    <code>Explain</code> <code>ExplainExecutor::execute</code>    <code>InsertValues</code> <code>InsertValuesExecutor::execute</code>   <code>LIST_CONNECTORS</code> <code>ListConnectors</code> <code>ListConnectorsExecutor::execute</code>   <code>LIST_CONNECTOR_PLUGINS</code> <code>ListConnectorPlugins</code> <code>ListConnectorPluginsExecutor::execute</code>   <code>LIST_FUNCTIONS</code> <code>ListFunctions</code> <code>ListFunctionsExecutor::execute</code>   <code>LIST_PROPERTIES</code> <code>ListProperties</code> <code>ListPropertiesExecutor::execute</code>   <code>LIST_QUERIES</code> <code>ListQueries</code> <code>ListQueriesExecutor::execute</code>   <code>LIST_STREAMS</code> <code>ListStreams</code> <code>ListSourceExecutor::streams</code>   <code>LIST_TABLES</code> <code>ListTables</code> <code>ListSourceExecutor::tables</code>   <code>LIST_TOPICS</code> <code>ListTopics</code> <code>ListTopicsExecutor::execute</code>   <code>LIST_TYPES</code> <code>ListTypes</code> <code>ListTypesExecutor::execute</code>   <code>LIST_VARIABLES</code> <code>ListVariables</code> <code>ListVariablesExecutor::execute</code>    <code>SetProperty</code> <code>PropertyExecutor::set</code>    <code>ShowColumns</code> <code>ListSourceExecutor::columns</code>    <code>TerminateQuery</code> <code>TerminateQueryExecutor::execute</code>    <code>UndefineVariable</code> <code>VariableExecutor::unset</code>    <code>UnsetProperty</code> <code>PropertyExecutor::unset</code>","title":"CustomExecutors"},{"location":"rest/DistributingExecutor/","text":"","title":"DistributingExecutor"},{"location":"rest/DistributingExecutor/#creating-instance","text":"<p><code>DistributingExecutor</code> takes the following to be created:</p> <ul> <li> KsqlConfig <li> CommandQueue <li> Distributed Command Response Timeout <li> <code>BiFunction&lt;KsqlExecutionContext, ServiceContext, Injector&gt;</code> <li> <code>KsqlAuthorizationValidator</code> <li> ValidatedCommandFactory <li> Error Handler <li> CommandRunner Warning (<code>Supplier&lt;String&gt;</code>)  <p><code>DistributingExecutor</code> is created when:</p> <ul> <li><code>KsqlResource</code> is requested to configure (and creates a RequestHandler)</li> </ul>","title":"Creating Instance"},{"location":"rest/DistributingExecutor/#executing-statement","text":"","title":"Executing Statement <pre><code>StatementExecutorResponse execute(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext executionContext,\n  KsqlSecurityContext securityContext)\n</code></pre> <p><code>execute</code> requests the injectorFactory to inject into the given <code>ConfiguredStatement</code>.</p> <p>For InsertIntos, <code>execute</code> validateInsertIntoQueries.</p> <p><code>execute</code> requests the CommandQueue for a transactional Kafka producer (<code>Producer&lt;CommandId, Command&gt;</code> to produce to the command topic).</p> <p><code>execute</code> initialize transactions (using Kafka's Producer.initTransactions).</p> <p><code>execute</code> starts a transaction (using Kafka's Producer.beginTransaction).</p> <p><code>execute</code> requests the CommandQueue to waitForCommandConsumer.</p> <p><code>execute</code>...FIXME</p> <p><code>execute</code> requests the CommandQueue to enqueue the command and commits the transaction (using Kafka's Producer.commitTransaction).</p> <p><code>execute</code>...FIXME</p> <p><code>execute</code> is used when:</p> <ul> <li><code>RequestHandler</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/Executable/","text":"<p><code>Executable</code> is an abstraction of executables.</p>","title":"Executable"},{"location":"rest/Executable/#contract","text":"","title":"Contract"},{"location":"rest/Executable/#awaitterminated","text":"","title":"awaitTerminated <pre><code>void awaitTerminated()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>awaitTerminated</code></li> </ul>"},{"location":"rest/Executable/#notifyterminated","text":"","title":"notifyTerminated <pre><code>void notifyTerminated()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>notifyTerminated</code></li> </ul>"},{"location":"rest/Executable/#shutdown","text":"","title":"shutdown <pre><code>void shutdown()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>shutdown</code></li> </ul>"},{"location":"rest/Executable/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p>Used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to tryStartApp</li> <li><code>MultiExecutable</code> is requested to <code>startAsync</code></li> </ul>"},{"location":"rest/Executable/#implementations","text":"<ul> <li>StandaloneExecutor</li> <li><code>MultiExecutable</code></li> <li><code>ConnectExecutable</code></li> <li>KsqlRestApplication</li> </ul>","title":"Implementations"},{"location":"rest/InteractiveStatementExecutor/","text":"","title":"InteractiveStatementExecutor"},{"location":"rest/InteractiveStatementExecutor/#handlestatement","text":"","title":"handleStatement <pre><code>void handleStatement(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>handleStatement</code>...FIXME</p> <p><code>handleStatement</code> is used when:</p> <ul> <li><code>CommandRunner</code> is requested to execute a statement</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#handlerestore","text":"","title":"handleRestore <pre><code>void handleRestore(\n  QueuedCommand queuedCommand)\n</code></pre> <p><code>handleRestore</code>...FIXME</p> <p><code>handleRestore</code> is used when:</p> <ul> <li><code>CommandRunner</code> is requested to processPriorCommands</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#handlestatementwithterminatedqueries","text":"","title":"handleStatementWithTerminatedQueries <pre><code>void handleStatementWithTerminatedQueries(\n  Command command,\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture,\n  Mode mode,\n  long offset)\n</code></pre> <p>If the given Command has a KsqlPlan, <code>handleStatementWithTerminatedQueries</code> executes the plan.</p> <p>Otherwise, <code>handleStatementWithTerminatedQueries</code>...FIXME</p> <p><code>handleStatementWithTerminatedQueries</code> is used when:</p> <ul> <li><code>InteractiveStatementExecutor</code> is requested to handleStatement and handleRestore</li> </ul>"},{"location":"rest/InteractiveStatementExecutor/#executing-plan","text":"","title":"Executing Plan <pre><code>void executePlan(\n  Command command,\n  CommandId commandId,\n  Optional&lt;CommandStatusFuture&gt; commandStatusFuture,\n  KsqlPlan plan,\n  Mode mode,\n  long offset)\n</code></pre> <p><code>executePlan</code> requests the KsqlEngine to execute the plan.</p>"},{"location":"rest/InternalKsqlClientFactory/","text":"<p><code>InternalKsqlClientFactory</code> is...FIXME</p>","title":"InternalKsqlClientFactory"},{"location":"rest/KsqlConfigurable/","text":"<p><code>KsqlConfigurable</code> is an abstraction of configurable services (of a ksqlDB API server instance).</p>","title":"KsqlConfigurable"},{"location":"rest/KsqlConfigurable/#contract","text":"","title":"Contract"},{"location":"rest/KsqlConfigurable/#configuring-service","text":"","title":"Configuring Service <pre><code>void configure(\n  KsqlConfig config)\n</code></pre> <p>Configures this service with the given KsqlConfig</p> <p>Used when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to startAsync</li> </ul>"},{"location":"rest/KsqlConfigurable/#implementations","text":"<ul> <li><code>InteractiveStatementExecutor</code></li> <li>KsqlResource</li> <li><code>StreamedQueryResource</code></li> </ul>","title":"Implementations"},{"location":"rest/KsqlResource/","text":"","title":"KsqlResource"},{"location":"rest/KsqlResource/#configure","text":"","title":"configure <pre><code>void configure(\n  KsqlConfig config)\n</code></pre> <p><code>configure</code>...FIXME</p> <p><code>configure</code> is part of the KsqlConfigurable abstraction.</p>"},{"location":"rest/KsqlResource/#requesthandler","text":"","title":"RequestHandler <p><code>KsqlResource</code> creates a RequestHandler when requested to configure.</p> <p><code>RequestHandler</code> is used when:</p> <ul> <li>terminateCluster</li> <li>handleKsqlStatements</li> </ul>"},{"location":"rest/KsqlResource/#handleksqlstatements","text":"","title":"handleKsqlStatements <pre><code>EndpointResponse handleKsqlStatements(\n  KsqlSecurityContext securityContext,\n  KsqlRequest request)\n</code></pre> <p><code>handleKsqlStatements</code> prints out the following INFO message to the logs:</p> <pre><code>Received: [request]\n</code></pre> <p><code>handleKsqlStatements</code>...FIXME</p> <p><code>handleKsqlStatements</code> requests the KsqlEngine to parse the SQL text.</p> <p><code>handleKsqlStatements</code>...FIXME</p> <p><code>handleKsqlStatements</code> requests the RequestHandler to execute the SQL statements.</p> <p><code>handleKsqlStatements</code>...FIXME</p> <p><code>handleKsqlStatements</code> is used when:</p> <ul> <li><code>KsqlServerEndpoints</code> is requested to <code>executeKsqlRequest</code></li> <li><code>ServerInternalKsqlClient</code> is requested to <code>makeKsqlRequest</code></li> </ul>"},{"location":"rest/KsqlRestApplication/","text":"<p><code>KsqlRestApplication</code> is a ksqlDB API server (that can be started using ksql-server-start shell script).</p>","title":"KsqlRestApplication"},{"location":"rest/KsqlRestApplication/#creating-instance","text":"<p><code>KsqlRestApplication</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlEngine <li> KsqlConfig <li> KsqlRestConfig <li>CommandRunner</li> <li> CommandStore <li> <code>StatusResource</code> <li> <code>StreamedQueryResource</code> <li> KsqlResource <li> VersionCheckerAgent <li> <code>KsqlSecurityContextProvider</code> <li> <code>KsqlSecurityExtension</code> <li> <code>AuthenticationPlugin</code> <li> <code>ServerState</code> <li> <code>ProcessingLogContext</code> <li> <code>KsqlServerPrecondition</code>s <li>KsqlConfigurables</li> <li> RocksDB Config Setter Handler (Function of KsqlConfig) <li> <code>HeartbeatAgent</code> <li> <code>LagReportingAgent</code> <li> Vert.x <li> <code>DenyListPropertyValidator</code> <li> <code>PullQueryExecutorMetrics</code> <li> <code>ScalablePushQueryMetrics</code> <li> <code>LocalCommands</code> <li> QueryExecutor   <p>When created, <code>KsqlRestApplication</code> prints out the following DEBUG message to the logs:</p> <pre><code>Creating instance of ksqlDB API server\n</code></pre> <p>In the end, <code>KsqlRestApplication</code> prints out the following DEBUG message to the logs:</p> <pre><code>ksqlDB API server instance created\n</code></pre>  <p><code>KsqlRestApplication</code> is created using buildApplication utility.</p>","title":"Creating Instance"},{"location":"rest/KsqlRestApplication/#commandrunner","text":"","title":"CommandRunner <p><code>KsqlRestApplication</code> is given a CommandRunner when created.</p> <p>The <code>CommandRunner</code> is requested to processPriorCommands followed by starting command execution in initialize. The <code>CommandRunner</code> is up and running until shutdown (when it is requested to close).</p> <p>The <code>CommandRunner</code> is used to create a HealthCheckResource when <code>KsqlRestApplication</code> is created.</p>"},{"location":"rest/KsqlRestApplication/#ksqlconfigurables","text":"","title":"KsqlConfigurables <p><code>KsqlRestApplication</code> is given KsqlConfigurables when created.</p> <p>All the given KsqlConfigurables are also given separately to create the <code>KsqlRestApplication</code>:</p> <ul> <li>KsqlResource</li> <li>StreamedQueryResource</li> <li><code>InteractiveStatementExecutor</code> (that is part of the StatusResource)</li> </ul> <p><code>KsqlConfigurable</code>s are requested to configure (with a KsqlConfig with an application.server property assigned) in startAsync.</p>"},{"location":"rest/KsqlRestApplication/#building-ksqlrestapplication","text":"","title":"Building KsqlRestApplication <pre><code>KsqlRestApplication buildApplication(\n  KsqlRestConfig restConfig,\n  MetricCollectors metricCollectors)\n</code></pre> <p><code>buildApplication</code> creates a Vert.x subsystem.</p>  <p>Vert.x</p> <p>Vert.x allows writing reactive applications on the JVM with support for HTTP, TCP, UDP, file system, asynchronous streams. etc.</p>  <p><code>buildApplication</code> creates an internal KsqlClient.</p> <p><code>buildApplication</code> creates a <code>KsqlSchemaRegistryClientFactory</code> and <code>DefaultConnectClientFactory</code>.</p> <p><code>buildApplication</code> determines the Kafka Cluster ID and reads the ksql.service.id configuration property (from the KsqlConfig).</p> <p><code>buildApplication</code> creates a KsqlRestConfig.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> creates a KsqlEngine.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> builds the name of the command topic (to create a CommandStore and a CommandRunner).</p> <p><code>buildApplication</code> creates a CommandStore.</p> <p><code>buildApplication</code>...FIXME</p> <p><code>buildApplication</code> creates a QueryExecutor.</p> <p><code>buildApplication</code>...FIXME</p> <p>In the end, <code>buildApplication</code> creates a KsqlRestApplication.</p> <p><code>buildApplication</code> is used when:</p> <ul> <li><code>KsqlServerMain</code> is requested for an Executable</li> </ul>"},{"location":"rest/KsqlRestApplication/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p><code>startAsync</code> prints out the following DEBUG message to the logs:</p> <pre><code>Starting the ksqlDB API server\n</code></pre> <p><code>startAsync</code>...FIXME</p> <p>In the end, <code>startAsync</code> prints out the following INFO message to the logs followed by displayWelcomeMessage.</p> <pre><code>ksqlDB API server listening on [comma-separated listeners]\n</code></pre>  <p><code>startAsync</code> is part of the Executable abstraction.</p>"},{"location":"rest/KsqlRestApplication/#displaywelcomemessage","text":"","title":"displayWelcomeMessage <pre><code>void displayWelcomeMessage()\n</code></pre> <p><code>displayWelcomeMessage</code>...FIXME</p> <p>In the end, <code>displayWelcomeMessage</code> prints out the following to the standard output:</p> <pre><code>Server [version] listening on [comma-separated listeners]\n\nTo access the KSQL CLI, run:\nksql [listener]\n</code></pre>"},{"location":"rest/KsqlRestApplication/#startksql","text":"","title":"startKsql <pre><code>void startKsql(\n  KsqlConfig ksqlConfigWithPort)\n</code></pre> <p><code>startKsql</code>...FIXME</p>"},{"location":"rest/KsqlRestApplication/#initialize","text":"","title":"initialize <pre><code>void initialize(\n  KsqlConfig configWithApplicationServer)\n</code></pre> <p><code>initialize</code>...FIXME</p>"},{"location":"rest/KsqlRestApplication/#registercommandtopic","text":"","title":"registerCommandTopic <pre><code>void registerCommandTopic()\n</code></pre> <p><code>registerCommandTopic</code>...FIXME</p>"},{"location":"rest/KsqlRestConfig/","text":"<p><code>KsqlRestConfig</code> is...FIXME</p>","title":"KsqlRestConfig"},{"location":"rest/KsqlServerEndpoints/","text":"<p><code>KsqlServerEndpoints</code> is...FIXME</p>","title":"KsqlServerEndpoints"},{"location":"rest/KsqlServerMain/","text":"<p><code>KsqlServerMain</code> is a standalone application to start an Executable:</p> <ol> <li>StandaloneExecutor for queries file</li> <li>KsqlRestApplication unless ksql.connect.worker.config configuration property is specified</li> <li><code>MultiExecutable</code> with a <code>ConnectExecutable</code> and the <code>KsqlRestApplication</code></li> </ol> <p><code>KsqlServerMain</code> supports command-line options.</p> <p><code>KsqlServerMain</code> can be launched on command line using ksql-server-start shell script.</p>","title":"KsqlServerMain"},{"location":"rest/KsqlServerMain/#ksql-server-start-shell-script","text":"","title":"ksql-server-start Shell Script <p><code>ksql-server-start</code> shell script (indirectly or <code>ksql-run-class</code> directly) is used to launch KsqlServerMain on command line.</p> <pre><code>./bin/ksql-run-class io.confluent.ksql.rest.server.KsqlServerMain\n</code></pre> <pre><code>$ ./bin/ksql-server-start --help\nNAME\n        server - KSQL Cluster\n\nSYNOPSIS\n        server [ {-h | --help} ] [ --queries-file &lt;queriesFile&gt; ] [--]\n                &lt;config-file&gt;\n\nOPTIONS\n        -h, --help\n            Display help information\n\n        --queries-file &lt;queriesFile&gt;\n            Path to the query file on the local machine.\n\n        --\n            This option can be used to separate command-line options from the\n            list of arguments (useful when arguments might be mistaken for\n            command-line options)\n\n        &lt;config-file&gt;\n            A file specifying configs for the KSQL Server, KSQL, and its\n            underlying Kafka Streams instance(s). Refer to KSQL documentation\n            for a list of available configs.\n\n            This option may occur a maximum of 1 times\n</code></pre>"},{"location":"rest/KsqlServerMain/#creating-instance","text":"","title":"Creating Instance <p><code>KsqlServerMain</code> takes the following to be created:</p> <ul> <li> Executable <li> Shutdown Handler  <p><code>KsqlServerMain</code> is created when:</p> <ul> <li><code>KsqlServerMain</code> standalone application is launched</li> </ul>"},{"location":"rest/KsqlServerMain/#launching-ksqlservermain-on-command-line","text":"","title":"Launching KsqlServerMain (on Command Line) <p><code>main</code> parses the command-line options and loads the required properties file (with the Java system properties applied overriding earlier values).</p> <p><code>main</code> creates and validates a KsqlConfig.</p> <p><code>main</code> configures QueryLogger (with the <code>KsqlConfig</code>).</p> <p><code>main</code> creates an Executable based on the following:</p> <ol> <li>Properties with the Java system properties applied</li> <li>queries file command-line option (if defined)</li> <li><code>ksql.server.install.dir</code> configuration property from the properties file</li> <li>A new KsqlConfig with the config and system properties</li> <li>A new <code>MetricCollectors</code></li> </ol> <p><code>main</code> creates a new KsqlServerMain (with the <code>Executable</code>) and starts it up.</p>  <p>Note</p> <p><code>main</code> is paused when starting up the executable (using awaitTerminated) until notifyTerminated which happens as part of a Java Virtual Machine shutdown hook.</p>"},{"location":"rest/KsqlServerMain/#creating-executable","text":"","title":"Creating Executable <pre><code>Executable createExecutable(\n  Map&lt;String, String&gt; properties,\n  Optional&lt;String&gt; queriesFile,\n  String installDir,\n  KsqlConfig ksqlConfig,\n  MetricCollectors metricCollectors)\n</code></pre> <p>With queries file specified, <code>createExecutable</code> returns a new StandaloneExecutor.</p> <p>Otherwise, <code>createExecutable</code> creates a KsqlRestConfig (with the given <code>properties</code>) to build a KsqlRestApplication (with the <code>KsqlRestConfig</code> and the given <code>MetricCollectors</code>).</p> <p>With no ksql.connect.worker.config configuration property specified, <code>createExecutable</code> returns the <code>KsqlRestApplication</code>. Otherwise, <code>createExecutable</code> creates a <code>ConnectExecutable</code> and returns a <code>MultiExecutable</code> (with the <code>ConnectExecutable</code> and the <code>KsqlRestApplication</code>).</p>"},{"location":"rest/KsqlServerMain/#trystartapp","text":"","title":"tryStartApp <pre><code>void tryStartApp()\n</code></pre> <p><code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Starting server\n</code></pre> <p><code>tryStartApp</code> requests the Executable to startAsync.</p> <p><code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Server up and running\n</code></pre> <p><code>tryStartApp</code> requests the Executable to awaitTerminated.</p> <p>Finally (when the Executable was requested to terminate), <code>tryStartApp</code> prints out the following INFO message to the logs:</p> <pre><code>Server shutting down\n</code></pre> <p><code>tryStartApp</code> requests the Executable to shutdown.</p>"},{"location":"rest/ProcessingLogServerUtils/","text":"<p><code>ProcessingLogServerUtils</code> is...FIXME</p>","title":"ProcessingLogServerUtils"},{"location":"rest/QueryExecutor/","text":"","title":"QueryExecutor"},{"location":"rest/QueryExecutor/#creating-instance","text":"<p><code>QueryExecutor</code> takes the following to be created:</p> <ul> <li> KsqlEngine <li> <code>KsqlRestConfig</code> <li> KsqlConfig <li> <code>PullQueryExecutorMetrics</code> <li> <code>ScalablePushQueryMetrics</code> <li> <code>RateLimiter</code> <li> <code>ConcurrencyLimiter</code> <li> <code>SlidingWindowRateLimiter</code> <li> <code>SlidingWindowRateLimiter</code> <li> <code>HARouting</code> <li> <code>PushRouting</code> <li> <code>LocalCommands</code>  <p><code>QueryExecutor</code> is created when:</p> <ul> <li><code>KsqlRestApplication</code> is requested to buildApplication</li> </ul>","title":"Creating Instance"},{"location":"rest/QueryExecutor/#handlestatement","text":"","title":"handleStatement <pre><code>QueryMetadataHolder handleStatement(\n  ServiceContext serviceContext,\n  Map&lt;String, Object&gt; configOverrides,\n  Map&lt;String, Object&gt; requestProperties,\n  PreparedStatement&lt;?&gt; statement,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Context context,\n  boolean excludeTombstones)\n</code></pre> <p><code>handleStatement</code>...FIXME</p> <p><code>handleStatement</code> is used when:</p> <ul> <li><code>QueryEndpoint</code> is requested to createQueryPublisher</li> <li><code>StreamedQueryResource</code> is requested to <code>handleStatement</code></li> <li><code>WSQueryEndpoint</code> is requested to <code>handleStatement</code></li> </ul>"},{"location":"rest/QueryExecutor/#handlequery","text":"","title":"handleQuery <pre><code>QueryMetadataHolder handleQuery(\n  ServiceContext serviceContext,\n  PreparedStatement&lt;Query&gt; statement,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  MetricsCallbackHolder metricsCallbackHolder,\n  Map&lt;String, Object&gt; configOverrides,\n  Map&lt;String, Object&gt; requestProperties,\n  Context context,\n  boolean excludeTombstones)\n</code></pre> <p><code>handleQuery</code>...FIXME</p>"},{"location":"rest/QueryExecutor/#handlepushquery","text":"","title":"handlePushQuery <pre><code>QueryMetadataHolder handlePushQuery(\n  ServiceContext serviceContext,\n  PreparedStatement&lt;Query&gt; statement,\n  Map&lt;String, Object&gt; streamsProperties,\n  boolean excludeTombstones)\n</code></pre> <p><code>handlePushQuery</code>...FIXME</p>"},{"location":"rest/QueryExecutor/#handletablepullquery","text":"","title":"handleTablePullQuery <pre><code>QueryMetadataHolder handleTablePullQuery(\n  ImmutableAnalysis analysis,\n  ServiceContext serviceContext,\n  ConfiguredStatement&lt;Query&gt; configured,\n  Map&lt;String, Object&gt; requestProperties,\n  Optional&lt;Boolean&gt; isInternalRequest,\n  SlidingWindowRateLimiter pullBandRateLimiter,\n  AtomicReference&lt;PullQueryResult&gt; resultForMetrics,\n  Optional&lt;ConsistencyOffsetVector&gt; consistencyOffsetVector)\n</code></pre> <p><code>handleTablePullQuery</code>...FIXME</p>"},{"location":"rest/RequestHandler/","text":"","title":"RequestHandler"},{"location":"rest/RequestHandler/#creating-instance","text":"<p><code>RequestHandler</code> takes the following to be created:</p> <ul> <li> CustomExecutors <li>DistributingExecutor</li> <li>KsqlEngine</li> <li> <code>CommandQueueSync</code>  <p><code>RequestHandler</code> is created when:</p> <ul> <li><code>KsqlResource</code> is requested to configure</li> </ul>","title":"Creating Instance"},{"location":"rest/RequestHandler/#ksqlengine","text":"","title":"KsqlEngine <p><code>RequestHandler</code> is given a KsqlEngine when created.</p> <p>The <code>KsqlEngine</code> is used for the following:</p> <ul> <li>Executing SQL Statements (and executeStatement)</li> <li>isVariableSubstitutionEnabled</li> </ul>"},{"location":"rest/RequestHandler/#distributingexecutor","text":"","title":"DistributingExecutor <p><code>RequestHandler</code> is given a DistributingExecutor when created.</p> <p>The <code>DistributingExecutor</code> is used for executing SQL statements.</p>"},{"location":"rest/RequestHandler/#executing-sql-statements","text":"","title":"Executing SQL Statements <pre><code>KsqlEntityList execute(\n  KsqlSecurityContext securityContext,\n  List&lt;ParsedStatement&gt; statements,\n  SessionProperties sessionProperties)\n</code></pre> <p><code>execute</code>...FIXME</p> <p><code>execute</code> executes the SQL statement.</p> <p><code>execute</code>...FIXME</p> <p><code>execute</code> is used when:</p> <ul> <li><code>KsqlResource</code> is requested to terminateCluster and handleKsqlStatements</li> </ul>"},{"location":"rest/RequestHandler/#executing-statement","text":"","title":"Executing Statement <pre><code>&lt;T extends Statement&gt; Optional&lt;KsqlEntity&gt; executeStatement(\n  KsqlSecurityContext securityContext,\n  PreparedStatement&lt;T&gt; prepared,\n  SessionProperties sessionProperties,\n  KsqlEntityList entities)\n</code></pre> <p><code>executeStatement</code> requests the given <code>PreparedStatement</code> for the Statement and its Java class that is used to request the CommandQueueSync to <code>waitFor</code>.</p> <p><code>executeStatement</code> creates a <code>ConfiguredStatement</code> for the given <code>PreparedStatement</code> (with a new <code>SessionConfig</code>).</p> <p><code>executeStatement</code> looks up the StatementExecutor for the <code>Statement</code> class in the CustomExecutors registry (or defaults to the DistributingExecutor to execute the statement).</p> <p><code>executeStatement</code> requests the <code>StatementExecutor</code> to execute the statement.</p> <p>Unless handled, <code>executeStatement</code> requests the DistributingExecutor to execute the statement.</p>"},{"location":"rest/RequestValidator/","text":"<p><code>RequestValidator</code> is...FIXME</p>","title":"RequestValidator"},{"location":"rest/ReservedInternalTopics/","text":"","title":"ReservedInternalTopics"},{"location":"rest/ReservedInternalTopics/#creating-instance","text":"<p><code>ReservedInternalTopics</code> takes the following to be created:</p> <ul> <li> KsqlConfig  <p><code>ReservedInternalTopics</code> is created mainly alongside a KsqlServerEndpoints and a DistributingExecutor but also when:</p> <ul> <li><code>InsertValuesExecutor</code> is requested to <code>getDataSource</code></li> <li><code>ListTopicsExecutor</code> is requested to <code>listTopics</code></li> </ul>","title":"Creating Instance"},{"location":"rest/ReservedInternalTopics/#internal-ksql-command-topic","text":"","title":"Internal KSQL Command Topic"},{"location":"rest/ReservedInternalTopics/#commandtopic","text":"","title":"commandTopic <pre><code>String commandTopic(\n  KsqlConfig ksqlConfig)\n</code></pre> <p><code>commandTopic</code>...FIXME</p> <p><code>commandTopic</code> is used when:</p> <ul> <li><code>KafkaBrokerCheck</code> is requested to <code>check</code></li> <li><code>KsqlRestApplication</code> utility is used to build a KsqlRestApplication (and creates a CommandStore)</li> <li><code>KsqlRestoreCommandTopic</code> is created</li> </ul>"},{"location":"rest/ReservedInternalTopics/#topic-name-prefix","text":"","title":"Topic Name Prefix <p><code>ReservedInternalTopics</code> assumes <code>command_topic</code> as the prefix of the name of the command topic.</p>"},{"location":"rest/ServerOptions/","text":"<p><code>ServerOptions</code> is used to handle the command-line options of KsqlServerMain.</p> <p><code>ServerOptions</code> uses Airline annotation-driven Java library for building Command Line Interfaces (CLIs).</p>","title":"ServerOptions"},{"location":"rest/ServerOptions/#properties-file","text":"","title":"Properties File <p>(required) A file with the configuration properties for the KSQL Server, KSQL, and underlying Kafka Streams instances.</p>"},{"location":"rest/ServerOptions/#query-file","text":"","title":"Query File <p>A path to a query file on the local machine.</p> <p>A query file can be specified using the following (in the order of precedence):</p> <ol> <li><code>--queries-file</code> command-line option</li> <li><code>ksql.queries.file</code> Java property</li> </ol>"},{"location":"rest/StandaloneExecutor/","text":"<p><code>StandaloneExecutor</code> is an Executable.</p>","title":"StandaloneExecutor"},{"location":"rest/StandaloneExecutor/#creating-instance","text":"<p><code>StandaloneExecutor</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> <code>ProcessingLogConfig</code> <li> KsqlConfig <li> KsqlEngine <li> Queries File <li> UserFunctionLoader <li> <code>failOnNoQueries</code> flag <li> VersionCheckerAgent <li> <code>injectorFactory</code> function <code>BiFunction&lt;KsqlExecutionContext, ServiceContext, Injector&gt;</code> <li> <code>MetricCollectors</code>  <p><code>StandaloneExecutor</code> is created when:</p> <ul> <li><code>StandaloneExecutorFactory</code> utility is used to create a StandaloneExecutor</li> </ul>","title":"Creating Instance"},{"location":"rest/StandaloneExecutor/#startasync","text":"","title":"startAsync <pre><code>void startAsync()\n</code></pre> <p><code>startAsync</code> requests the UserFunctionLoader to load.</p> <p><code>startAsync</code> maybeCreateProcessingLogTopic.</p> <p>With <code>stream.auto.create</code> enabled, <code>startAsync</code> prints out the following WARN message to the logs:</p> <pre><code>processing log auto-create is enabled, but this is not supported for headless mode.\n</code></pre> <p><code>startAsync</code> reads the queriesFile to process.</p> <p><code>startAsync</code> showWelcomeMessage.</p> <p>In the end, <code>startAsync</code> requests the VersionCheckerAgent to start (with the <code>SERVER</code> module type and non-null configuration properties of the KsqlConfig).</p>  <p><code>startAsync</code> is part of the Executable abstraction.</p>"},{"location":"rest/StandaloneExecutor/#loading-queries-file","text":"","title":"Loading Queries File <pre><code>String readQueriesFile(\n  String queryFilePath)\n</code></pre> <p><code>readQueriesFile</code> reads the given <code>queryFilePath</code> with <code>UTF_8</code> encoding.</p>"},{"location":"rest/StandaloneExecutor/#processing-queries","text":"","title":"Processing Queries <pre><code>void processesQueryFile(\n  String queries)\n</code></pre> <p><code>processesQueryFile</code> requests the KsqlEngine to parse the SQL queries (into a collection of <code>ParsedStatement</code>s).</p> <p><code>processesQueryFile</code> validates the ParsedStatements.</p> <p><code>processesQueryFile</code> uses the injectorFactory to create an <code>Injector</code> (with the KsqlEngine and the ServiceContext).</p> <p><code>processesQueryFile</code>...FIXME</p>"},{"location":"rest/StandaloneExecutor/#validating-parsedstatements","text":"","title":"Validating ParsedStatements <pre><code>void validateStatements(\n  List&lt;ParsedStatement&gt; statements)\n</code></pre> <p><code>validateStatements</code> requests the KsqlEngine to create a SandboxedExecutionContext (with the ServiceContext).</p> <p><code>validateStatements</code> uses the injectorFactory to create an <code>Injector</code> (with the SandboxedExecutionContext and its ServiceContext).</p> <p><code>validateStatements</code> creates a StatementExecutor to execute the ParsedStatements.</p> <p>In the end, if failOnNoQueries and there was no QueryContainer, <code>validateStatements</code> throws a <code>KsqlException</code>:</p> <pre><code>The SQL file does not contain any persistent queries.\ni.e. it contains no 'INSERT INTO', 'CREATE TABLE x AS SELECT' or\n'CREATE STREAM x AS SELECT' style statements.\n</code></pre>"},{"location":"rest/StandaloneExecutor/#executing-statements","text":"","title":"Executing Statements <pre><code>boolean executeStatements(\n  List&lt;ParsedStatement&gt; statements,\n  StatementExecutor executor)\n</code></pre> <p><code>executeStatements</code> requests the given StatementExecutor to execute the given <code>ParsedStatement</code>s one by one.</p> <p>In the end, <code>executeStatements</code> returns whether there was a <code>ParsedStatement</code> with a query.</p> <p><code>executeStatements</code> is used when:</p> <ul> <li><code>StandaloneExecutor</code> is requested to processes a query file and validate statements</li> </ul>"},{"location":"rest/StandaloneExecutorFactory/","text":"","title":"StandaloneExecutorFactory"},{"location":"rest/StandaloneExecutorFactory/#creating-standaloneexecutor","text":"","title":"Creating StandaloneExecutor <pre><code>StandaloneExecutor create(\n  Map&lt;String, String&gt; properties,\n  String queriesFile,\n  String installDir)\n</code></pre> <p><code>create</code>...FIXME</p> <p><code>create</code> is used when:</p> <ul> <li><code>KsqlServerMain</code> is requested to createExecutable (with a queries file)</li> </ul>"},{"location":"rest/StandaloneExecutor_StatementExecutor/","text":"<p><code>StatementExecutor</code> is a <code>private static final class</code> of StandaloneExecutor with statement handlers.</p>","title":"StatementExecutor"},{"location":"rest/StandaloneExecutor_StatementExecutor/#creating-instance","text":"<p><code>StatementExecutor</code> takes the following to be created:</p> <ul> <li> ServiceContext <li> KsqlExecutionContext <li> <code>Injector</code> <li> KsqlConfig  <p><code>StatementExecutor</code> is created when:</p> <ul> <li><code>StandaloneExecutor</code> is requested to processesQueryFile and validateStatements</li> </ul>","title":"Creating Instance"},{"location":"rest/StandaloneExecutor_StatementExecutor/#statement-handlers","text":"","title":"Statement Handlers <p><code>StatementExecutor</code> creates <code>HANDLERS</code> collection of handlers (functions) of Statements.</p>    SQL Statement Class Handler      SET <code>SetProperty</code> <code>StatementExecutor::handleSetProperty</code>   UNSET <code>UnsetProperty</code> <code>StatementExecutor::handleUnsetProperty</code>   CREATE STREAM CreateStream <code>StatementExecutor::handleExecutableDdl</code>   CREATE TABLE <code>CreateTable</code> <code>StatementExecutor::handleExecutableDdl</code>   REGISTER TYPE <code>RegisterType</code> <code>StatementExecutor::handleExecutableDdl</code>    CREATE STREAM AS SELECT <code>CreateStreamAsSelect</code> handlePersistentQuery    CREATE TABLE AS SELECT <code>CreateTableAsSelect</code> handlePersistentQuery    INSERT INTO InsertInto handlePersistentQuery    <p>The <code>HANDLERS</code> is used in execute and generateSupportedMessage.</p>"},{"location":"rest/StandaloneExecutor_StatementExecutor/#handlepersistentquery","text":"","title":"handlePersistentQuery <pre><code>void handlePersistentQuery(\n  ConfiguredStatement&lt;?&gt; statement)\n</code></pre> <p><code>handlePersistentQuery</code> requests the KsqlExecutionContext to execute the given statement (in the ServiceContext) to produce a QueryMetadata.</p> <p><code>handlePersistentQuery</code> makes sure that the <code>QueryMetadata</code> is a <code>PersistentQueryMetadata</code> or throws a <code>KsqlStatementException</code>:</p> <pre><code>Could not build the query\n</code></pre> <p><code>handlePersistentQuery</code> is used when:</p> <ul> <li><code>StatementExecutor</code> is requested to handle CREATE STREAM AS SELECT, CREATE TABLE AS SELECT and INSERT INTO SQL statements</li> </ul>"},{"location":"rest/StatementExecutor/","text":"<p><code>StatementExecutor</code> is an abstraction of executors of Statements.</p> <p><code>StatementExecutor</code> is a <code>FunctionalInterface</code> (Java).</p>","title":"StatementExecutor"},{"location":"rest/StatementExecutor/#contract","text":"","title":"Contract"},{"location":"rest/StatementExecutor/#executing-statement","text":"","title":"Executing Statement <pre><code>StatementExecutorResponse execute(\n  ConfiguredStatement&lt;T&gt; statement,\n  SessionProperties sessionProperties,\n  KsqlExecutionContext executionContext,\n  ServiceContext serviceContext)\n</code></pre> <p>Used when:</p> <ul> <li><code>CustomExecutors</code> is requested to execute</li> <li><code>RequestHandler</code> is requested to execute a SQL statement</li> </ul>"},{"location":"rest/StatementExecutor/#implementations","text":"<ul> <li>many</li> </ul>","title":"Implementations"},{"location":"rest/ValidatedCommandFactory/","text":"<p><code>ValidatedCommandFactory</code> is a collection of utilities to create validated commands (that are safe to enqueue onto the command queue).</p>","title":"ValidatedCommandFactory"},{"location":"rest/ValidatedCommandFactory/#creating-validated-command","text":"","title":"Creating Validated Command <pre><code>Command create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\nCommand create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context\n</code></pre> <p><code>create</code> creates a Command.</p> <p><code>create</code>...FIXME</p> <p><code>create</code> is used when:</p> <ul> <li><code>DistributingExecutor</code> is requested to execute a statement</li> <li><code>RequestValidator</code> is requested to validate</li> </ul>"},{"location":"rest/ValidatedCommandFactory/#creating-command","text":"","title":"Creating Command <pre><code>Command create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\nCommand create(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context\n</code></pre> <p><code>createCommand</code>...FIXME</p>"},{"location":"rest/ValidatedCommandFactory/#createforaltersystemquery","text":"","title":"createForAlterSystemQuery <pre><code>Command createForAlterSystemQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForAlterSystemQuery</code>...FIXME</p> <p><code>createForAlterSystemQuery</code> is used when:</p> <ul> <li>FIXME</li> </ul>"},{"location":"rest/ValidatedCommandFactory/#createforplannedquery","text":"","title":"createForPlannedQuery <pre><code>Command createForPlannedQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  ServiceContext serviceContext,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForPlannedQuery</code>...FIXME</p>"},{"location":"rest/ValidatedCommandFactory/#createforterminatequery","text":"","title":"createForTerminateQuery <pre><code>Command createForTerminateQuery(\n  ConfiguredStatement&lt;? extends Statement&gt; statement,\n  KsqlExecutionContext context)\n</code></pre> <p><code>createForTerminateQuery</code> assumes that the given <code>statement</code> is a <code>TerminateQuery</code>.</p> <p><code>createForTerminateQuery</code> handles the following cases:</p> <ol> <li>No <code>queryId</code> defined to close all the running persistent queries</li> <li><code>queryId</code>s with the <code>transient_</code> query name prefix</li> <li>Non-<code>CREATE_SOURCE</code> persistent queries</li> </ol>  <p>With no <code>queryId</code> defined, <code>createForTerminateQuery</code> requests all the running persistent queries (in the given KsqlExecutionContext) to close and returns a Command with the given <code>statement</code>.</p> <p>For a <code>queryId</code> that contains the <code>transient_</code> query name prefix, <code>createForTerminateQuery</code> returns a Command with the given <code>statement</code>.</p> <p>For all the other <code>queryId</code>s, <code>createForTerminateQuery</code> looks up the query (in the given KsqlExecutionContext) to close it.</p> <p>In the end, <code>createForTerminateQuery</code> returns a Command with the given <code>statement</code>.</p>  <p><code>createForTerminateQuery</code> throws a <code>KsqlStatementException</code> for <code>CREATE_SOURCE</code> queries:</p> <pre><code>Cannot terminate query '[queryId]' because it is linked to a source table.\n</code></pre>"}]}